<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Subversion: Filesystem interaction subsystem</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Subversion
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Filesystem interaction subsystem</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__svn__fs__bdb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__bdb.html">Berkeley DB filesystems</a></td></tr>
<tr class="memdesc:group__svn__fs__bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subversion filesystems based on Berkeley DB. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__svn__fs__access__ctx"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__access__ctx.html">Filesystem access contexts</a></td></tr>
<tr class="memdesc:group__svn__fs__access__ctx"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filesystem Access Contexts. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__svn__fs__nodes"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__nodes.html">Filesystem nodes</a></td></tr>
<tr class="memdesc:group__svn__fs__nodes"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filesystem Nodes and Node-Revisions. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__svn__fs__txns"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__txns.html">Filesystem transactions</a></td></tr>
<tr class="memdesc:group__svn__fs__txns"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filesystem Transactions. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__svn__fs__roots"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__roots.html">Filesystem roots</a></td></tr>
<tr class="memdesc:group__svn__fs__roots"><td class="mdescLeft">&#160;</td><td class="mdescRight">Roots. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__svn__fs__directories"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__directories.html">Filesystem directories</a></td></tr>
<tr class="memdesc:group__svn__fs__directories"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directory entry names and directory paths. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__svn__fs__locks"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__locks.html">Filesystem locks</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__fs__dirent__t.html">svn_fs_dirent_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a Subversion directory entry.  <a href="structsvn__fs__dirent__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga2419fff1bb2c1e523b00e276ed3862e3"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a></td></tr>
<tr class="memdesc:ga2419fff1bb2c1e523b00e276ed3862e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object representing a Subversion filesystem.  <a href="#ga2419fff1bb2c1e523b00e276ed3862e3">More...</a><br/></td></tr>
<tr class="separator:ga2419fff1bb2c1e523b00e276ed3862e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa2c790fffb1abbd103c954a5d983646"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gafa2c790fffb1abbd103c954a5d983646">svn_fs_warning_callback_t</a> )(void *baton, <a class="el" href="structsvn__error__t.html">svn_error_t</a> *err)</td></tr>
<tr class="memdesc:gafa2c790fffb1abbd103c954a5d983646"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a warning callback function.  <a href="#gafa2c790fffb1abbd103c954a5d983646">More...</a><br/></td></tr>
<tr class="separator:gafa2c790fffb1abbd103c954a5d983646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0baf65b94f952b09dee2983871a691cd"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga0baf65b94f952b09dee2983871a691cd">svn_fs_progress_notify_func_t</a> )(<a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> revision, void *baton, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga0baf65b94f952b09dee2983871a691cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function type for progress notification.  <a href="#ga0baf65b94f952b09dee2983871a691cd">More...</a><br/></td></tr>
<tr class="separator:ga0baf65b94f952b09dee2983871a691cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18d5e6d8766261e5a0b362d3ca4c219a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga18d5e6d8766261e5a0b362d3ca4c219a">svn_fs_freeze_func_t</a> )(void *baton, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga18d5e6d8766261e5a0b362d3ca4c219a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for <a class="el" href="group__fs__handling.html#ga354b9fd5754cc10ce1cd2acd46bdd4c6" title="Take an exclusive lock on fs to prevent commits and then invoke freeze_func passing freeze_baton...">svn_fs_freeze()</a>.  <a href="#ga18d5e6d8766261e5a0b362d3ca4c219a">More...</a><br/></td></tr>
<tr class="separator:ga18d5e6d8766261e5a0b362d3ca4c219a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa31b679ed9ca7b53241ebda04c035140"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__fs__handling.html#gaa31b679ed9ca7b53241ebda04c035140">svn_fs_history_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gaa31b679ed9ca7b53241ebda04c035140">svn_fs_history_t</a></td></tr>
<tr class="memdesc:gaa31b679ed9ca7b53241ebda04c035140"><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque node history object.  <a href="#gaa31b679ed9ca7b53241ebda04c035140">More...</a><br/></td></tr>
<tr class="separator:gaa31b679ed9ca7b53241ebda04c035140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2697d2b291384d9511aef9857daf8aa1"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structsvn__fs__dirent__t.html">svn_fs_dirent_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga2697d2b291384d9511aef9857daf8aa1">svn_fs_dirent_t</a></td></tr>
<tr class="memdesc:ga2697d2b291384d9511aef9857daf8aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a Subversion directory entry.  <a href="#ga2697d2b291384d9511aef9857daf8aa1">More...</a><br/></td></tr>
<tr class="separator:ga2697d2b291384d9511aef9857daf8aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabf75bf085ab7f392eff150cec4e49a3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gaabf75bf085ab7f392eff150cec4e49a3">svn_fs_process_contents_func_t</a> )(const unsigned char *contents, apr_size_t len, void *baton, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:gaabf75bf085ab7f392eff150cec4e49a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function type used with <a class="el" href="group__fs__handling.html#ga48972a36b2007b043bc7983be1ddd1b9" title="Efficiently deliver the contents of the file path in root via processor (with baton), setting *success to TRUE upon doing so. ">svn_fs_try_process_file_contents()</a> that delivers the immutable, non-NULL <em>contents</em> of <em>len</em> bytes.  <a href="#gaabf75bf085ab7f392eff150cec4e49a3">More...</a><br/></td></tr>
<tr class="separator:gaabf75bf085ab7f392eff150cec4e49a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32fc8b28e63f9f0e7cab74c8a44f819c"><td class="memItemLeft" align="right" valign="top">typedef enum <br class="typebreak"/>
<a class="el" href="group__fs__handling.html#ga7c9b681798a28beb90cb747c0626b5b2">svn_fs_pack_notify_action_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga32fc8b28e63f9f0e7cab74c8a44f819c">svn_fs_pack_notify_action_t</a></td></tr>
<tr class="memdesc:ga32fc8b28e63f9f0e7cab74c8a44f819c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The kind of action being taken by 'pack'.  <a href="#ga32fc8b28e63f9f0e7cab74c8a44f819c">More...</a><br/></td></tr>
<tr class="separator:ga32fc8b28e63f9f0e7cab74c8a44f819c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga418eae984b0da828404197edf9fcc46e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga418eae984b0da828404197edf9fcc46e">svn_fs_pack_notify_t</a> )(void *baton, apr_int64_t shard, <a class="el" href="group__fs__handling.html#ga7c9b681798a28beb90cb747c0626b5b2">svn_fs_pack_notify_action_t</a> action, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga418eae984b0da828404197edf9fcc46e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a pack notification function.  <a href="#ga418eae984b0da828404197edf9fcc46e">More...</a><br/></td></tr>
<tr class="separator:ga418eae984b0da828404197edf9fcc46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga7c9b681798a28beb90cb747c0626b5b2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga7c9b681798a28beb90cb747c0626b5b2">svn_fs_pack_notify_action_t</a> { <br/>
&#160;&#160;<a class="el" href="group__fs__handling.html#gga7c9b681798a28beb90cb747c0626b5b2afba8e92df732aad1d260c907a671d974">svn_fs_pack_notify_start</a> = 0, 
<br/>
&#160;&#160;<a class="el" href="group__fs__handling.html#gga7c9b681798a28beb90cb747c0626b5b2a418f1ef1d170f644d49d055b4d4e244f">svn_fs_pack_notify_end</a>, 
<br/>
&#160;&#160;<a class="el" href="group__fs__handling.html#gga7c9b681798a28beb90cb747c0626b5b2a7e2b473fa5c9367b08a76f92f7e856fa">svn_fs_pack_notify_start_revprop</a>, 
<br/>
&#160;&#160;<a class="el" href="group__fs__handling.html#gga7c9b681798a28beb90cb747c0626b5b2a3d08320b848ebe9a3f5b6846e67cda2f">svn_fs_pack_notify_end_revprop</a>
<br/>
 }</td></tr>
<tr class="memdesc:ga7c9b681798a28beb90cb747c0626b5b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The kind of action being taken by 'pack'.  <a href="group__fs__handling.html#ga7c9b681798a28beb90cb747c0626b5b2">More...</a><br/></td></tr>
<tr class="separator:ga7c9b681798a28beb90cb747c0626b5b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf3bce1e26521c4432f14f3adfc617f17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gaf3bce1e26521c4432f14f3adfc617f17">svn_fs_initialize</a> (apr_pool_t *pool)</td></tr>
<tr class="memdesc:gaf3bce1e26521c4432f14f3adfc617f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callers should invoke this function to initialize global state in the FS library before creating FS objects.  <a href="#gaf3bce1e26521c4432f14f3adfc617f17">More...</a><br/></td></tr>
<tr class="separator:gaf3bce1e26521c4432f14f3adfc617f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc881c866ebe2cbd41767374264532e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gabc881c866ebe2cbd41767374264532e8">svn_fs_set_warning_func</a> (<a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, <a class="el" href="group__fs__handling.html#gafa2c790fffb1abbd103c954a5d983646">svn_fs_warning_callback_t</a> warning, void *warning_baton)</td></tr>
<tr class="memdesc:gabc881c866ebe2cbd41767374264532e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a callback function, <em>warning</em>, that <em>fs</em> should use to report (non-fatal) errors.  <a href="#gabc881c866ebe2cbd41767374264532e8">More...</a><br/></td></tr>
<tr class="separator:gabc881c866ebe2cbd41767374264532e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24b9cee11c6d584ddb0b9d74efca5dd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga24b9cee11c6d584ddb0b9d74efca5dd5">svn_fs_create</a> (<a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> **fs_p, const char *path, apr_hash_t *fs_config, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga24b9cee11c6d584ddb0b9d74efca5dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new, empty Subversion filesystem, stored in the directory <em>path</em>, and return a pointer to it in <em>*fs_p</em>.  <a href="#ga24b9cee11c6d584ddb0b9d74efca5dd5">More...</a><br/></td></tr>
<tr class="separator:ga24b9cee11c6d584ddb0b9d74efca5dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf31aff19f6ddd70e665235ff1857fc35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gaf31aff19f6ddd70e665235ff1857fc35">svn_fs_open</a> (<a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> **fs_p, const char *path, apr_hash_t *fs_config, apr_pool_t *pool)</td></tr>
<tr class="memdesc:gaf31aff19f6ddd70e665235ff1857fc35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a Subversion filesystem located in the directory <em>path</em>, and return a pointer to it in <em>*fs_p</em>.  <a href="#gaf31aff19f6ddd70e665235ff1857fc35">More...</a><br/></td></tr>
<tr class="separator:gaf31aff19f6ddd70e665235ff1857fc35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64cb2a37367de523f56b89e5ec603a73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga64cb2a37367de523f56b89e5ec603a73">svn_fs_upgrade</a> (const char *path, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga64cb2a37367de523f56b89e5ec603a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upgrade the Subversion filesystem located in the directory <em>path</em> to the latest version supported by this library.  <a href="#ga64cb2a37367de523f56b89e5ec603a73">More...</a><br/></td></tr>
<tr class="separator:ga64cb2a37367de523f56b89e5ec603a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae771342c2800751277423c552cfeee48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gae771342c2800751277423c552cfeee48">svn_fs_type</a> (const char **fs_type, const char *path, apr_pool_t *pool)</td></tr>
<tr class="memdesc:gae771342c2800751277423c552cfeee48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return, in <em>*fs_type</em>, a string identifying the back-end type of the Subversion filesystem located in <em>path</em>.  <a href="#gae771342c2800751277423c552cfeee48">More...</a><br/></td></tr>
<tr class="separator:gae771342c2800751277423c552cfeee48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1a79172a1faa38b234d365240079c3a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gaa1a79172a1faa38b234d365240079c3a">svn_fs_path</a> (<a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, apr_pool_t *pool)</td></tr>
<tr class="memdesc:gaa1a79172a1faa38b234d365240079c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the path to <em>fs's</em> repository, allocated in <em>pool</em>.  <a href="#gaa1a79172a1faa38b234d365240079c3a">More...</a><br/></td></tr>
<tr class="separator:gaa1a79172a1faa38b234d365240079c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4275158ceab7ec93162f62c7cc5cfbae"><td class="memItemLeft" align="right" valign="top">apr_hash_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga4275158ceab7ec93162f62c7cc5cfbae">svn_fs_config</a> (<a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga4275158ceab7ec93162f62c7cc5cfbae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a shallow copy of the configuration parameters used to open <em>fs</em>, allocated in <em>pool</em>.  <a href="#ga4275158ceab7ec93162f62c7cc5cfbae">More...</a><br/></td></tr>
<tr class="separator:ga4275158ceab7ec93162f62c7cc5cfbae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d1642cd31bc5e860d521c8c80058058"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga6d1642cd31bc5e860d521c8c80058058">svn_fs_delete_fs</a> (const char *path, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga6d1642cd31bc5e860d521c8c80058058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the filesystem at <em>path</em>.  <a href="#ga6d1642cd31bc5e860d521c8c80058058">More...</a><br/></td></tr>
<tr class="separator:ga6d1642cd31bc5e860d521c8c80058058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0d6cd72d57ad6818843a30cdba5e3e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gab0d6cd72d57ad6818843a30cdba5e3e1">svn_fs_hotcopy2</a> (const char *src_path, const char *dest_path, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> clean, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> incremental, <a class="el" href="svn__types_8h.html#addaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a> cancel_func, void *cancel_baton, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:gab0d6cd72d57ad6818843a30cdba5e3e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a possibly live Subversion filesystem from <em>src_path</em> to <em>dest_path</em>.  <a href="#gab0d6cd72d57ad6818843a30cdba5e3e1">More...</a><br/></td></tr>
<tr class="separator:gab0d6cd72d57ad6818843a30cdba5e3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2909d84e561fbfd8b0f321dbded129b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga2909d84e561fbfd8b0f321dbded129b6">svn_fs_hotcopy</a> (const char *src_path, const char *dest_path, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> clean, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga2909d84e561fbfd8b0f321dbded129b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="group__fs__handling.html#gab0d6cd72d57ad6818843a30cdba5e3e1" title="Copy a possibly live Subversion filesystem from src_path to dest_path. ">svn_fs_hotcopy2()</a>, but with <em>incremental</em> always passed as <code>TRUE</code> and without cancellation support.  <a href="#ga2909d84e561fbfd8b0f321dbded129b6">More...</a><br/></td></tr>
<tr class="separator:ga2909d84e561fbfd8b0f321dbded129b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6f1f42958e3f56326185b91fc1ae679"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gaf6f1f42958e3f56326185b91fc1ae679">svn_fs_recover</a> (const char *path, <a class="el" href="svn__types_8h.html#addaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a> cancel_func, void *cancel_baton, apr_pool_t *pool)</td></tr>
<tr class="memdesc:gaf6f1f42958e3f56326185b91fc1ae679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform any necessary non-catastrophic recovery on the Subversion filesystem located at <em>path</em>.  <a href="#gaf6f1f42958e3f56326185b91fc1ae679">More...</a><br/></td></tr>
<tr class="separator:gaf6f1f42958e3f56326185b91fc1ae679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga354b9fd5754cc10ce1cd2acd46bdd4c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga354b9fd5754cc10ce1cd2acd46bdd4c6">svn_fs_freeze</a> (<a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, <a class="el" href="group__fs__handling.html#ga18d5e6d8766261e5a0b362d3ca4c219a">svn_fs_freeze_func_t</a> freeze_func, void *freeze_baton, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga354b9fd5754cc10ce1cd2acd46bdd4c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take an exclusive lock on <em>fs</em> to prevent commits and then invoke <em>freeze_func</em> passing <em>freeze_baton</em>.  <a href="#ga354b9fd5754cc10ce1cd2acd46bdd4c6">More...</a><br/></td></tr>
<tr class="separator:ga354b9fd5754cc10ce1cd2acd46bdd4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8795c6c2a696353b550c2f733787a015"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga8795c6c2a696353b550c2f733787a015">svn_fs_check_path</a> (<a class="el" href="svn__types_8h.html#ac3ca125707a8ca1289c73236b5ce7f9a">svn_node_kind_t</a> *kind_p, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga8795c6c2a696353b550c2f733787a015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*kind_p</em> to the type of node present at <em>path</em> under <em>root</em>.  <a href="#ga8795c6c2a696353b550c2f733787a015">More...</a><br/></td></tr>
<tr class="separator:ga8795c6c2a696353b550c2f733787a015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2412ddc868b0ef6cdbbe3b682827885e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga2412ddc868b0ef6cdbbe3b682827885e">svn_fs_node_history</a> (<a class="el" href="group__fs__handling.html#gaa31b679ed9ca7b53241ebda04c035140">svn_fs_history_t</a> **history_p, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga2412ddc868b0ef6cdbbe3b682827885e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*history_p</em> to an opaque node history object which represents <em>path</em> under <em>root</em>.  <a href="#ga2412ddc868b0ef6cdbbe3b682827885e">More...</a><br/></td></tr>
<tr class="separator:ga2412ddc868b0ef6cdbbe3b682827885e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58dd5d7dc74bef946a4dc1129c342038"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga58dd5d7dc74bef946a4dc1129c342038">svn_fs_history_prev</a> (<a class="el" href="group__fs__handling.html#gaa31b679ed9ca7b53241ebda04c035140">svn_fs_history_t</a> **prev_history_p, <a class="el" href="group__fs__handling.html#gaa31b679ed9ca7b53241ebda04c035140">svn_fs_history_t</a> *history, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> cross_copies, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga58dd5d7dc74bef946a4dc1129c342038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*prev_history_p</em> to an opaque node history object which represents the previous (or "next oldest") interesting history location for the filesystem node represented by <em>history</em>, or <code>NULL</code> if no such previous history exists.  <a href="#ga58dd5d7dc74bef946a4dc1129c342038">More...</a><br/></td></tr>
<tr class="separator:ga58dd5d7dc74bef946a4dc1129c342038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga266d0597466eb198dc4b593fcd44490e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga266d0597466eb198dc4b593fcd44490e">svn_fs_history_location</a> (const char **path, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> *revision, <a class="el" href="group__fs__handling.html#gaa31b679ed9ca7b53241ebda04c035140">svn_fs_history_t</a> *history, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga266d0597466eb198dc4b593fcd44490e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*path</em> and <em>*revision</em> to the path and revision, respectively, of the <em>history</em> object.  <a href="#ga266d0597466eb198dc4b593fcd44490e">More...</a><br/></td></tr>
<tr class="separator:ga266d0597466eb198dc4b593fcd44490e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a5ecfab7f53876e9ad6def4265df7e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga1a5ecfab7f53876e9ad6def4265df7e6">svn_fs_is_dir</a> (<a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *is_dir, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga1a5ecfab7f53876e9ad6def4265df7e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*is_dir</em> to <code>TRUE</code> iff <em>path</em> in <em>root</em> is a directory.  <a href="#ga1a5ecfab7f53876e9ad6def4265df7e6">More...</a><br/></td></tr>
<tr class="separator:ga1a5ecfab7f53876e9ad6def4265df7e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84b9e2f502354e16162edd12e8f5cc5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga84b9e2f502354e16162edd12e8f5cc5b">svn_fs_is_file</a> (<a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *is_file, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga84b9e2f502354e16162edd12e8f5cc5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*is_file</em> to <code>TRUE</code> iff <em>path</em> in <em>root</em> is a file.  <a href="#ga84b9e2f502354e16162edd12e8f5cc5b">More...</a><br/></td></tr>
<tr class="separator:ga84b9e2f502354e16162edd12e8f5cc5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf59a66cf510e6da06dadfe2b3bb372e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gaf59a66cf510e6da06dadfe2b3bb372e1">svn_fs_node_id</a> (const <a class="el" href="group__svn__fs__nodes.html#gaeca8f1c373c50ca7bb08e3417242b106">svn_fs_id_t</a> **id_p, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>
<tr class="memdesc:gaf59a66cf510e6da06dadfe2b3bb372e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the id of a node.  <a href="#gaf59a66cf510e6da06dadfe2b3bb372e1">More...</a><br/></td></tr>
<tr class="separator:gaf59a66cf510e6da06dadfe2b3bb372e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3be25cd08e898319e14cce69580992e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gad3be25cd08e898319e14cce69580992e">svn_fs_node_created_rev</a> (<a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> *revision, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>
<tr class="memdesc:gad3be25cd08e898319e14cce69580992e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*revision</em> to the revision in which <em>path</em> under <em>root</em> was created.  <a href="#gad3be25cd08e898319e14cce69580992e">More...</a><br/></td></tr>
<tr class="separator:gad3be25cd08e898319e14cce69580992e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf26ebca946019f3761f48ad8dadd6eaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gaf26ebca946019f3761f48ad8dadd6eaa">svn_fs_node_origin_rev</a> (<a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> *revision, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>
<tr class="memdesc:gaf26ebca946019f3761f48ad8dadd6eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*revision</em> to the revision in which the line of history represented by <em>path</em> under <em>root</em> originated.  <a href="#gaf26ebca946019f3761f48ad8dadd6eaa">More...</a><br/></td></tr>
<tr class="separator:gaf26ebca946019f3761f48ad8dadd6eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf25b3de3d8930d857cf6c94777ce9bca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gaf25b3de3d8930d857cf6c94777ce9bca">svn_fs_node_created_path</a> (const char **created_path, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>
<tr class="memdesc:gaf25b3de3d8930d857cf6c94777ce9bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*created_path</em> to the path at which <em>path</em> under <em>root</em> was created.  <a href="#gaf25b3de3d8930d857cf6c94777ce9bca">More...</a><br/></td></tr>
<tr class="separator:gaf25b3de3d8930d857cf6c94777ce9bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga830b554597da876e1b6256f2836cf349"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga830b554597da876e1b6256f2836cf349">svn_fs_node_prop</a> (<a class="el" href="structsvn__string__t.html">svn_string_t</a> **value_p, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, const char *propname, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga830b554597da876e1b6256f2836cf349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*value_p</em> to the value of the property named <em>propname</em> of <em>path</em> in <em>root</em>.  <a href="#ga830b554597da876e1b6256f2836cf349">More...</a><br/></td></tr>
<tr class="separator:ga830b554597da876e1b6256f2836cf349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga079534da68d59ac24307ae171189dd61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga079534da68d59ac24307ae171189dd61">svn_fs_node_proplist</a> (apr_hash_t **table_p, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga079534da68d59ac24307ae171189dd61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*table_p</em> to the entire property list of <em>path</em> in <em>root</em>, as an APR hash table allocated in <em>pool</em>.  <a href="#ga079534da68d59ac24307ae171189dd61">More...</a><br/></td></tr>
<tr class="separator:ga079534da68d59ac24307ae171189dd61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75ce7073e254911b82f9acc4825d4247"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga75ce7073e254911b82f9acc4825d4247">svn_fs_change_node_prop</a> (<a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, const char *name, const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *value, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga75ce7073e254911b82f9acc4825d4247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change a node's property's value, or add/delete a property.  <a href="#ga75ce7073e254911b82f9acc4825d4247">More...</a><br/></td></tr>
<tr class="separator:ga75ce7073e254911b82f9acc4825d4247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac7c1a6f4732d24a8ee387abb33e33dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gaac7c1a6f4732d24a8ee387abb33e33dc">svn_fs_props_changed</a> (<a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *changed_p, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root1, const char *path1, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root2, const char *path2, apr_pool_t *pool)</td></tr>
<tr class="memdesc:gaac7c1a6f4732d24a8ee387abb33e33dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the properties of two path/root combinations are different.  <a href="#gaac7c1a6f4732d24a8ee387abb33e33dc">More...</a><br/></td></tr>
<tr class="separator:gaac7c1a6f4732d24a8ee387abb33e33dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed6116279287a80ec4f7de380a732f45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gaed6116279287a80ec4f7de380a732f45">svn_fs_copied_from</a> (<a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> *rev_p, const char **path_p, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>
<tr class="memdesc:gaed6116279287a80ec4f7de380a732f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discover a node's copy ancestry, if any.  <a href="#gaed6116279287a80ec4f7de380a732f45">More...</a><br/></td></tr>
<tr class="separator:gaed6116279287a80ec4f7de380a732f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d7839028ca775d36c6fdc851973f9ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga9d7839028ca775d36c6fdc851973f9ac">svn_fs_closest_copy</a> (<a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> **root_p, const char **path_p, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga9d7839028ca775d36c6fdc851973f9ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*root_p</em> and <em>*path_p</em> to the revision root and path of the destination of the most recent copy event that caused <em>path</em> to exist where it does in <em>root</em>, or to NULL if no such copy exists.  <a href="#ga9d7839028ca775d36c6fdc851973f9ac">More...</a><br/></td></tr>
<tr class="separator:ga9d7839028ca775d36c6fdc851973f9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga326d7cf7dbaf76ea00acf58ab23d16dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga326d7cf7dbaf76ea00acf58ab23d16dc">svn_fs_get_mergeinfo2</a> (svn_mergeinfo_catalog_t *catalog, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const apr_array_header_t *paths, <a class="el" href="svn__mergeinfo_8h.html#acd81e9d0f5bcc4eec4df7b8a140f435c">svn_mergeinfo_inheritance_t</a> inherit, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> include_descendants, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> adjust_inherited_mergeinfo, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:ga326d7cf7dbaf76ea00acf58ab23d16dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve mergeinfo for multiple nodes.  <a href="#ga326d7cf7dbaf76ea00acf58ab23d16dc">More...</a><br/></td></tr>
<tr class="separator:ga326d7cf7dbaf76ea00acf58ab23d16dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2976ec837ee7caa7771e61ed266933b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga2976ec837ee7caa7771e61ed266933b5">svn_fs_get_mergeinfo</a> (svn_mergeinfo_catalog_t *catalog, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const apr_array_header_t *paths, <a class="el" href="svn__mergeinfo_8h.html#acd81e9d0f5bcc4eec4df7b8a140f435c">svn_mergeinfo_inheritance_t</a> inherit, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> include_descendants, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga2976ec837ee7caa7771e61ed266933b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="group__fs__handling.html#ga326d7cf7dbaf76ea00acf58ab23d16dc" title="Retrieve mergeinfo for multiple nodes. ">svn_fs_get_mergeinfo2()</a>, but with <em>adjust_inherited_mergeinfo</em> set always set to <code>TRUE</code> and with only one pool.  <a href="#ga2976ec837ee7caa7771e61ed266933b5">More...</a><br/></td></tr>
<tr class="separator:ga2976ec837ee7caa7771e61ed266933b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc5df16564312635dc97077a29e73d8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gafc5df16564312635dc97077a29e73d8e">svn_fs_merge</a> (const char **conflict_p, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *source_root, const char *source_path, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *target_root, const char *target_path, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *ancestor_root, const char *ancestor_path, apr_pool_t *pool)</td></tr>
<tr class="memdesc:gafc5df16564312635dc97077a29e73d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge changes between two nodes into a third node.  <a href="#gafc5df16564312635dc97077a29e73d8e">More...</a><br/></td></tr>
<tr class="separator:gafc5df16564312635dc97077a29e73d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad254aea2a12fbd7c8c62c8aaa3c4624c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gad254aea2a12fbd7c8c62c8aaa3c4624c">svn_fs_dir_entries</a> (apr_hash_t **entries_p, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>
<tr class="memdesc:gad254aea2a12fbd7c8c62c8aaa3c4624c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*entries_p</em> to a newly allocated APR hash table containing the entries of the directory at <em>path</em> in <em>root</em>.  <a href="#gad254aea2a12fbd7c8c62c8aaa3c4624c">More...</a><br/></td></tr>
<tr class="separator:gad254aea2a12fbd7c8c62c8aaa3c4624c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8484e37e57a52bb38e5067c38bf41e16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga8484e37e57a52bb38e5067c38bf41e16">svn_fs_make_dir</a> (<a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga8484e37e57a52bb38e5067c38bf41e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new directory named <em>path</em> in <em>root</em>.  <a href="#ga8484e37e57a52bb38e5067c38bf41e16">More...</a><br/></td></tr>
<tr class="separator:ga8484e37e57a52bb38e5067c38bf41e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga528e3cf9010e463b511584f4143b6a72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga528e3cf9010e463b511584f4143b6a72">svn_fs_delete</a> (<a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga528e3cf9010e463b511584f4143b6a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the node named <em>path</em> in <em>root</em>.  <a href="#ga528e3cf9010e463b511584f4143b6a72">More...</a><br/></td></tr>
<tr class="separator:ga528e3cf9010e463b511584f4143b6a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9da8e22bd1058f877a275099699bb86b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga9da8e22bd1058f877a275099699bb86b">svn_fs_copy</a> (<a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *from_root, const char *from_path, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *to_root, const char *to_path, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga9da8e22bd1058f877a275099699bb86b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of <em>from_path</em> in <em>from_root</em> named <em>to_path</em> in <em>to_root</em>.  <a href="#ga9da8e22bd1058f877a275099699bb86b">More...</a><br/></td></tr>
<tr class="separator:ga9da8e22bd1058f877a275099699bb86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddd7ec5b6e3306c609e46d4f5a2b8a5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gaddd7ec5b6e3306c609e46d4f5a2b8a5c">svn_fs_revision_link</a> (<a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *from_root, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *to_root, const char *path, apr_pool_t *pool)</td></tr>
<tr class="memdesc:gaddd7ec5b6e3306c609e46d4f5a2b8a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="group__fs__handling.html#ga9da8e22bd1058f877a275099699bb86b" title="Create a copy of from_path in from_root named to_path in to_root. ">svn_fs_copy()</a>, but doesn't record copy history, and preserves the PATH.  <a href="#gaddd7ec5b6e3306c609e46d4f5a2b8a5c">More...</a><br/></td></tr>
<tr class="separator:gaddd7ec5b6e3306c609e46d4f5a2b8a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd675ec4bc28c7f4e72a121feeb60059"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gabd675ec4bc28c7f4e72a121feeb60059">svn_fs_file_length</a> (<a class="el" href="svn__types_8h.html#a726e581898461c1d3e7dbdb16d99dad0">svn_filesize_t</a> *length_p, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>
<tr class="memdesc:gabd675ec4bc28c7f4e72a121feeb60059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*length_p</em> to the length of the file <em>path</em> in <em>root</em>, in bytes.  <a href="#gabd675ec4bc28c7f4e72a121feeb60059">More...</a><br/></td></tr>
<tr class="separator:gabd675ec4bc28c7f4e72a121feeb60059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a35bf47dcd1d43fdf7572166eb0eeb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga3a35bf47dcd1d43fdf7572166eb0eeb4">svn_fs_file_checksum</a> (<a class="el" href="structsvn__checksum__t.html">svn_checksum_t</a> **checksum, <a class="el" href="svn__checksum_8h.html#a7a6c373d03d7e6ec6b832a039f5e0aa1">svn_checksum_kind_t</a> kind, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> force, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga3a35bf47dcd1d43fdf7572166eb0eeb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*checksum</em> to the checksum of type <em>kind</em> for the file <em>path</em>.  <a href="#ga3a35bf47dcd1d43fdf7572166eb0eeb4">More...</a><br/></td></tr>
<tr class="separator:ga3a35bf47dcd1d43fdf7572166eb0eeb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dfe5ed9f63bb8b222d2adb2b96f0220"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga9dfe5ed9f63bb8b222d2adb2b96f0220">svn_fs_file_md5_checksum</a> (unsigned char digest[], <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga9dfe5ed9f63bb8b222d2adb2b96f0220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="group__fs__handling.html#ga3a35bf47dcd1d43fdf7572166eb0eeb4" title="Set *checksum to the checksum of type kind for the file path. ">svn_fs_file_checksum()</a>, only always put the MD5 checksum of file <em>path</em> into <em>digest</em>, which should point to <code>APR_MD5_DIGESTSIZE</code> bytes of storage.  <a href="#ga9dfe5ed9f63bb8b222d2adb2b96f0220">More...</a><br/></td></tr>
<tr class="separator:ga9dfe5ed9f63bb8b222d2adb2b96f0220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe8eadb1c6950e3bfdca49bbb497d6fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gafe8eadb1c6950e3bfdca49bbb497d6fb">svn_fs_file_contents</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **contents, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>
<tr class="memdesc:gafe8eadb1c6950e3bfdca49bbb497d6fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*contents</em> to a readable generic stream that will yield the contents of the file <em>path</em> in <em>root</em>.  <a href="#gafe8eadb1c6950e3bfdca49bbb497d6fb">More...</a><br/></td></tr>
<tr class="separator:gafe8eadb1c6950e3bfdca49bbb497d6fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48972a36b2007b043bc7983be1ddd1b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga48972a36b2007b043bc7983be1ddd1b9">svn_fs_try_process_file_contents</a> (<a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *success, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, <a class="el" href="group__fs__handling.html#gaabf75bf085ab7f392eff150cec4e49a3">svn_fs_process_contents_func_t</a> processor, void *baton, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga48972a36b2007b043bc7983be1ddd1b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficiently deliver the contents of the file <em>path</em> in <em>root</em> via <em>processor</em> (with <em>baton</em>), setting <em>*success</em> to <code>TRUE</code> upon doing so.  <a href="#ga48972a36b2007b043bc7983be1ddd1b9">More...</a><br/></td></tr>
<tr class="separator:ga48972a36b2007b043bc7983be1ddd1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac760753f1ae74fc19991d5dab7cb643c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gac760753f1ae74fc19991d5dab7cb643c">svn_fs_make_file</a> (<a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>
<tr class="memdesc:gac760753f1ae74fc19991d5dab7cb643c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new file named <em>path</em> in <em>root</em>.  <a href="#gac760753f1ae74fc19991d5dab7cb643c">More...</a><br/></td></tr>
<tr class="separator:gac760753f1ae74fc19991d5dab7cb643c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ae7391b579009b76e238fe9ef5b8053"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga8ae7391b579009b76e238fe9ef5b8053">svn_fs_apply_textdelta</a> (<a class="el" href="group__svn__delta__txt__delta.html#ga1c0d461a3f244928d7f0339c1cbe3219">svn_txdelta_window_handler_t</a> *contents_p, void **contents_baton_p, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, const char *base_checksum, const char *result_checksum, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga8ae7391b579009b76e238fe9ef5b8053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a text delta to the file <em>path</em> in <em>root</em>.  <a href="#ga8ae7391b579009b76e238fe9ef5b8053">More...</a><br/></td></tr>
<tr class="separator:ga8ae7391b579009b76e238fe9ef5b8053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61f5a039a4ad8818de163578b9c054f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga61f5a039a4ad8818de163578b9c054f7">svn_fs_apply_text</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **contents_p, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, const char *result_checksum, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga61f5a039a4ad8818de163578b9c054f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data directly to the file <em>path</em> in <em>root</em>.  <a href="#ga61f5a039a4ad8818de163578b9c054f7">More...</a><br/></td></tr>
<tr class="separator:ga61f5a039a4ad8818de163578b9c054f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaede66ee7850d389bcdeb5ddef1540fdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gaede66ee7850d389bcdeb5ddef1540fdc">svn_fs_contents_changed</a> (<a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *changed_p, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root1, const char *path1, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root2, const char *path2, apr_pool_t *pool)</td></tr>
<tr class="memdesc:gaede66ee7850d389bcdeb5ddef1540fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the contents of two root/path combos have changed.  <a href="#gaede66ee7850d389bcdeb5ddef1540fdc">More...</a><br/></td></tr>
<tr class="separator:gaede66ee7850d389bcdeb5ddef1540fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4af11f84095941c21fad6e22f62dd31d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga4af11f84095941c21fad6e22f62dd31d">svn_fs_youngest_rev</a> (<a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> *youngest_p, <a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga4af11f84095941c21fad6e22f62dd31d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*youngest_p</em> to the number of the youngest revision in filesystem <em>fs</em>.  <a href="#ga4af11f84095941c21fad6e22f62dd31d">More...</a><br/></td></tr>
<tr class="separator:ga4af11f84095941c21fad6e22f62dd31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f29dd4915629fc66ea1af713b659ce5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga3f29dd4915629fc66ea1af713b659ce5">svn_fs_deltify_revision</a> (<a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> revision, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga3f29dd4915629fc66ea1af713b659ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide filesystem <em>fs</em> the opportunity to compress storage relating to associated with <em>revision</em> in filesystem <em>fs</em>.  <a href="#ga3f29dd4915629fc66ea1af713b659ce5">More...</a><br/></td></tr>
<tr class="separator:ga3f29dd4915629fc66ea1af713b659ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cd6959ee54cd16768477d608fd33c34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga0cd6959ee54cd16768477d608fd33c34">svn_fs_revision_prop</a> (<a class="el" href="structsvn__string__t.html">svn_string_t</a> **value_p, <a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> rev, const char *propname, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga0cd6959ee54cd16768477d608fd33c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*value_p</em> to the value of the property named <em>propname</em> on revision <em>rev</em> in the filesystem <em>fs</em>.  <a href="#ga0cd6959ee54cd16768477d608fd33c34">More...</a><br/></td></tr>
<tr class="separator:ga0cd6959ee54cd16768477d608fd33c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga423da8c30eacc9787ec7bc3dd1b9e351"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga423da8c30eacc9787ec7bc3dd1b9e351">svn_fs_revision_proplist</a> (apr_hash_t **table_p, <a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> rev, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga423da8c30eacc9787ec7bc3dd1b9e351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*table_p</em> to the entire property list of revision <em>rev</em> in filesystem <em>fs</em>, as an APR hash table allocated in <em>pool</em>.  <a href="#ga423da8c30eacc9787ec7bc3dd1b9e351">More...</a><br/></td></tr>
<tr class="separator:ga423da8c30eacc9787ec7bc3dd1b9e351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42e1c39fc4980da8c2f2f575fa7515ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga42e1c39fc4980da8c2f2f575fa7515ac">svn_fs_change_rev_prop2</a> (<a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> rev, const char *name, const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *const *old_value_p, const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *value, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga42e1c39fc4980da8c2f2f575fa7515ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change a revision's property's value, or add/delete a property.  <a href="#ga42e1c39fc4980da8c2f2f575fa7515ac">More...</a><br/></td></tr>
<tr class="separator:ga42e1c39fc4980da8c2f2f575fa7515ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab368d97a4f5093e8c71f8082f4664937"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gab368d97a4f5093e8c71f8082f4664937">svn_fs_change_rev_prop</a> (<a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> rev, const char *name, const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *value, apr_pool_t *pool)</td></tr>
<tr class="memdesc:gab368d97a4f5093e8c71f8082f4664937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="group__fs__handling.html#ga42e1c39fc4980da8c2f2f575fa7515ac" title="Change a revision&#39;s property&#39;s value, or add/delete a property. ">svn_fs_change_rev_prop2()</a>, but with <em>old_value_p</em> passed as <code>NULL</code>.  <a href="#gab368d97a4f5093e8c71f8082f4664937">More...</a><br/></td></tr>
<tr class="separator:gab368d97a4f5093e8c71f8082f4664937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2d4b1fa18c0bbda6719d4414b52f4c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gad2d4b1fa18c0bbda6719d4414b52f4c2">svn_fs_get_file_delta_stream</a> (<a class="el" href="group__svn__delta__txt__delta.html#gaf599af000e3c3b976c17fd4e101ff7cf">svn_txdelta_stream_t</a> **stream_p, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *source_root, const char *source_path, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *target_root, const char *target_path, apr_pool_t *pool)</td></tr>
<tr class="memdesc:gad2d4b1fa18c0bbda6719d4414b52f4c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*stream_p</em> to a pointer to a delta stream that will turn the contents of the file <em>source</em> into the contents of the file <em>target</em>.  <a href="#gad2d4b1fa18c0bbda6719d4414b52f4c2">More...</a><br/></td></tr>
<tr class="separator:gad2d4b1fa18c0bbda6719d4414b52f4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ce6bd7610fc7201f4ea6b4e20e49e67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga2ce6bd7610fc7201f4ea6b4e20e49e67">svn_fs_get_uuid</a> (<a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, const char **uuid, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga2ce6bd7610fc7201f4ea6b4e20e49e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate <em>*uuid</em> with the UUID associated with <em>fs</em>.  <a href="#ga2ce6bd7610fc7201f4ea6b4e20e49e67">More...</a><br/></td></tr>
<tr class="separator:ga2ce6bd7610fc7201f4ea6b4e20e49e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabec2453f61fb9356db9526d4c56f3a62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gabec2453f61fb9356db9526d4c56f3a62">svn_fs_set_uuid</a> (<a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, const char *uuid, apr_pool_t *pool)</td></tr>
<tr class="memdesc:gabec2453f61fb9356db9526d4c56f3a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">If not <code>NULL</code>, associate <em>*uuid</em> with <em>fs</em>.  <a href="#gabec2453f61fb9356db9526d4c56f3a62">More...</a><br/></td></tr>
<tr class="separator:gabec2453f61fb9356db9526d4c56f3a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26cf98c986a0f71fe9d86be0f73266b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga26cf98c986a0f71fe9d86be0f73266b6">svn_fs_print_modules</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *output, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga26cf98c986a0f71fe9d86be0f73266b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a textual list of all available FS modules to the stringbuf <em>output</em>.  <a href="#ga26cf98c986a0f71fe9d86be0f73266b6">More...</a><br/></td></tr>
<tr class="separator:ga26cf98c986a0f71fe9d86be0f73266b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga307aa2f60e82d9f78d7f7990991533c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga307aa2f60e82d9f78d7f7990991533c3">svn_fs_pack</a> (const char *db_path, <a class="el" href="group__fs__handling.html#ga418eae984b0da828404197edf9fcc46e">svn_fs_pack_notify_t</a> notify_func, void *notify_baton, <a class="el" href="svn__types_8h.html#addaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a> cancel_func, void *cancel_baton, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga307aa2f60e82d9f78d7f7990991533c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possibly update the filesystem located in the directory <em>path</em> to use disk space more efficiently.  <a href="#ga307aa2f60e82d9f78d7f7990991533c3">More...</a><br/></td></tr>
<tr class="separator:ga307aa2f60e82d9f78d7f7990991533c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c8730657b4f8b55ba45e1449ae4285f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga2c8730657b4f8b55ba45e1449ae4285f">svn_fs_verify</a> (const char *path, apr_hash_t *fs_config, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> start, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> end, <a class="el" href="group__fs__handling.html#ga0baf65b94f952b09dee2983871a691cd">svn_fs_progress_notify_func_t</a> notify_func, void *notify_baton, <a class="el" href="svn__types_8h.html#addaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a> cancel_func, void *cancel_baton, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:ga2c8730657b4f8b55ba45e1449ae4285f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform backend-specific data consistency and correctness validations to the Subversion filesystem (mainly the meta-data) located in the directory <em>path</em>.  <a href="#ga2c8730657b4f8b55ba45e1449ae4285f">More...</a><br/></td></tr>
<tr class="separator:ga2c8730657b4f8b55ba45e1449ae4285f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga146a85e2774e4d69743f63a0bf5db3ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga146a85e2774e4d69743f63a0bf5db3ae">svn_fs_verify_root</a> (<a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:ga146a85e2774e4d69743f63a0bf5db3ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform backend-specific data consistency and correctness validations of <em>root</em> in the Subversion filesystem <em>fs</em>.  <a href="#ga146a85e2774e4d69743f63a0bf5db3ae">More...</a><br/></td></tr>
<tr class="separator:ga146a85e2774e4d69743f63a0bf5db3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Filesystem configuration options</h2></td></tr>
<tr class="memitem:gaab167e36e29a071fa657b15690153fd6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaab167e36e29a071fa657b15690153fd6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SVN_FS_CONFIG_BDB_TXN_NOSYNC</b>&#160;&#160;&#160;&quot;bdb-txn-nosync&quot;</td></tr>
<tr class="separator:gaab167e36e29a071fa657b15690153fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga164c04ce6347133c7b3404c02237c885"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga164c04ce6347133c7b3404c02237c885"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SVN_FS_CONFIG_BDB_LOG_AUTOREMOVE</b>&#160;&#160;&#160;&quot;bdb-log-autoremove&quot;</td></tr>
<tr class="separator:ga164c04ce6347133c7b3404c02237c885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc9c69b38e7648f51d44c19d30264768"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gabc9c69b38e7648f51d44c19d30264768">SVN_FS_CONFIG_FSFS_CACHE_DELTAS</a>&#160;&#160;&#160;&quot;fsfs-cache-deltas&quot;</td></tr>
<tr class="memdesc:gabc9c69b38e7648f51d44c19d30264768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable / disable text delta caching for a FSFS repository.  <a href="#gabc9c69b38e7648f51d44c19d30264768">More...</a><br/></td></tr>
<tr class="separator:gabc9c69b38e7648f51d44c19d30264768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5723e5da32aff3655370c74df55869ec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga5723e5da32aff3655370c74df55869ec">SVN_FS_CONFIG_FSFS_CACHE_FULLTEXTS</a>&#160;&#160;&#160;&quot;fsfs-cache-fulltexts&quot;</td></tr>
<tr class="memdesc:ga5723e5da32aff3655370c74df55869ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable / disable full-text caching for a FSFS repository.  <a href="#ga5723e5da32aff3655370c74df55869ec">More...</a><br/></td></tr>
<tr class="separator:ga5723e5da32aff3655370c74df55869ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04ac02d7699702261a02744a2d642765"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga04ac02d7699702261a02744a2d642765">SVN_FS_CONFIG_FSFS_CACHE_REVPROPS</a>&#160;&#160;&#160;&quot;fsfs-cache-revprops&quot;</td></tr>
<tr class="memdesc:ga04ac02d7699702261a02744a2d642765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable / disable revprop caching for a FSFS repository.  <a href="#ga04ac02d7699702261a02744a2d642765">More...</a><br/></td></tr>
<tr class="separator:ga04ac02d7699702261a02744a2d642765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga485ed154fa256f6e8339c9c47b2690dd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga485ed154fa256f6e8339c9c47b2690dd">SVN_FS_CONFIG_FSFS_CACHE_NS</a>&#160;&#160;&#160;&quot;fsfs-cache-namespace&quot;</td></tr>
<tr class="memdesc:ga485ed154fa256f6e8339c9c47b2690dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select the cache namespace.  <a href="#ga485ed154fa256f6e8339c9c47b2690dd">More...</a><br/></td></tr>
<tr class="separator:ga485ed154fa256f6e8339c9c47b2690dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cce99342f8830d9541901fcbc5fa8b3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga8cce99342f8830d9541901fcbc5fa8b3">SVN_FS_CONFIG_FS_TYPE</a>&#160;&#160;&#160;&quot;fs-type&quot;</td></tr>
<tr class="separator:ga8cce99342f8830d9541901fcbc5fa8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29b820d53571bccdf8f381652f584ab9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga29b820d53571bccdf8f381652f584ab9">SVN_FS_TYPE_BDB</a>&#160;&#160;&#160;&quot;bdb&quot;</td></tr>
<tr class="separator:ga29b820d53571bccdf8f381652f584ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9fcc8cddb1a0cd207b53196d88152d8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gad9fcc8cddb1a0cd207b53196d88152d8">SVN_FS_TYPE_FSFS</a>&#160;&#160;&#160;&quot;fsfs&quot;</td></tr>
<tr class="separator:gad9fcc8cddb1a0cd207b53196d88152d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc13f77df450863a919070b29b21c781"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gadc13f77df450863a919070b29b21c781">SVN_FS_CONFIG_PRE_1_4_COMPATIBLE</a>&#160;&#160;&#160;&quot;pre-1.4-compatible&quot;</td></tr>
<tr class="memdesc:gadc13f77df450863a919070b29b21c781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create repository format compatible with Subversion versions earlier than 1.4.  <a href="#gadc13f77df450863a919070b29b21c781">More...</a><br/></td></tr>
<tr class="separator:gadc13f77df450863a919070b29b21c781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c752f75cbf1c1baa0e9162a69c3d726"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga1c752f75cbf1c1baa0e9162a69c3d726">SVN_FS_CONFIG_PRE_1_5_COMPATIBLE</a>&#160;&#160;&#160;&quot;pre-1.5-compatible&quot;</td></tr>
<tr class="memdesc:ga1c752f75cbf1c1baa0e9162a69c3d726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create repository format compatible with Subversion versions earlier than 1.5.  <a href="#ga1c752f75cbf1c1baa0e9162a69c3d726">More...</a><br/></td></tr>
<tr class="separator:ga1c752f75cbf1c1baa0e9162a69c3d726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a32c49aff9bb931c07c6cca5f4f80c9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga3a32c49aff9bb931c07c6cca5f4f80c9">SVN_FS_CONFIG_PRE_1_6_COMPATIBLE</a>&#160;&#160;&#160;&quot;pre-1.6-compatible&quot;</td></tr>
<tr class="memdesc:ga3a32c49aff9bb931c07c6cca5f4f80c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create repository format compatible with Subversion versions earlier than 1.6.  <a href="#ga3a32c49aff9bb931c07c6cca5f4f80c9">More...</a><br/></td></tr>
<tr class="separator:ga3a32c49aff9bb931c07c6cca5f4f80c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9213a51ce08005d34a107497c805cace"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga9213a51ce08005d34a107497c805cace">SVN_FS_CONFIG_PRE_1_8_COMPATIBLE</a>&#160;&#160;&#160;&quot;pre-1.8-compatible&quot;</td></tr>
<tr class="memdesc:ga9213a51ce08005d34a107497c805cace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create repository format compatible with Subversion versions earlier than 1.8.  <a href="#ga9213a51ce08005d34a107497c805cace">More...</a><br/></td></tr>
<tr class="separator:ga9213a51ce08005d34a107497c805cace"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga8cce99342f8830d9541901fcbc5fa8b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SVN_FS_CONFIG_FS_TYPE&#160;&#160;&#160;&quot;fs-type&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>New in 1.1. </dd></dl>

<p>Definition at line <a class="el" href="svn__fs_8h_source.html#l00118">118</a> of file <a class="el" href="svn__fs_8h_source.html">svn_fs.h</a>.</p>

</div>
</div>
<a class="anchor" id="gabc9c69b38e7648f51d44c19d30264768"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SVN_FS_CONFIG_FSFS_CACHE_DELTAS&#160;&#160;&#160;&quot;fsfs-cache-deltas&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable / disable text delta caching for a FSFS repository. </p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

<p>Definition at line <a class="el" href="svn__fs_8h_source.html#l00080">80</a> of file <a class="el" href="svn__fs_8h_source.html">svn_fs.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga5723e5da32aff3655370c74df55869ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SVN_FS_CONFIG_FSFS_CACHE_FULLTEXTS&#160;&#160;&#160;&quot;fsfs-cache-fulltexts&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable / disable full-text caching for a FSFS repository. </p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

<p>Definition at line <a class="el" href="svn__fs_8h_source.html#l00086">86</a> of file <a class="el" href="svn__fs_8h_source.html">svn_fs.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga485ed154fa256f6e8339c9c47b2690dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SVN_FS_CONFIG_FSFS_CACHE_NS&#160;&#160;&#160;&quot;fsfs-cache-namespace&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select the cache namespace. </p>
<p>If you potentially share the cache with another FS object for the same repository, objects read through one FS will not need to be read again for the other. In most cases, that is a very desirable behavior and the default is, therefore, an empty namespace.</p>
<p>If you want to be sure that your FS instance will actually read all requested data at least once, you need to specify a separate namespace for it. All repository verification code, for instance, should use some GUID here that is different each time you open an FS instance.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.8. </dd></dl>

<p>Definition at line <a class="el" href="svn__fs_8h_source.html#l00111">111</a> of file <a class="el" href="svn__fs_8h_source.html">svn_fs.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga04ac02d7699702261a02744a2d642765"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SVN_FS_CONFIG_FSFS_CACHE_REVPROPS&#160;&#160;&#160;&quot;fsfs-cache-revprops&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable / disable revprop caching for a FSFS repository. </p>
<p>"2" is allowed, too and means "enable if efficient", i.e. this will not create warning at runtime if there if no efficient support for revprop caching.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.8. </dd></dl>

<p>Definition at line <a class="el" href="svn__fs_8h_source.html#l00096">96</a> of file <a class="el" href="svn__fs_8h_source.html">svn_fs.h</a>.</p>

</div>
</div>
<a class="anchor" id="gadc13f77df450863a919070b29b21c781"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SVN_FS_CONFIG_PRE_1_4_COMPATIBLE&#160;&#160;&#160;&quot;pre-1.4-compatible&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create repository format compatible with Subversion versions earlier than 1.4. </p>
<dl class="section since"><dt>Since</dt><dd>New in 1.4. </dd></dl>

<p>Definition at line <a class="el" href="svn__fs_8h_source.html#l00129">129</a> of file <a class="el" href="svn__fs_8h_source.html">svn_fs.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga1c752f75cbf1c1baa0e9162a69c3d726"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SVN_FS_CONFIG_PRE_1_5_COMPATIBLE&#160;&#160;&#160;&quot;pre-1.5-compatible&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create repository format compatible with Subversion versions earlier than 1.5. </p>
<dl class="section since"><dt>Since</dt><dd>New in 1.5. </dd></dl>

<p>Definition at line <a class="el" href="svn__fs_8h_source.html#l00136">136</a> of file <a class="el" href="svn__fs_8h_source.html">svn_fs.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga3a32c49aff9bb931c07c6cca5f4f80c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SVN_FS_CONFIG_PRE_1_6_COMPATIBLE&#160;&#160;&#160;&quot;pre-1.6-compatible&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create repository format compatible with Subversion versions earlier than 1.6. </p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6. </dd></dl>

<p>Definition at line <a class="el" href="svn__fs_8h_source.html#l00143">143</a> of file <a class="el" href="svn__fs_8h_source.html">svn_fs.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga9213a51ce08005d34a107497c805cace"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SVN_FS_CONFIG_PRE_1_8_COMPATIBLE&#160;&#160;&#160;&quot;pre-1.8-compatible&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create repository format compatible with Subversion versions earlier than 1.8. </p>
<dl class="section since"><dt>Since</dt><dd>New in 1.8. </dd></dl>

<p>Definition at line <a class="el" href="svn__fs_8h_source.html#l00150">150</a> of file <a class="el" href="svn__fs_8h_source.html">svn_fs.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga29b820d53571bccdf8f381652f584ab9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SVN_FS_TYPE_BDB&#160;&#160;&#160;&quot;bdb&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>New in 1.1. </dd></dl>

<p>Definition at line <a class="el" href="svn__fs_8h_source.html#l00120">120</a> of file <a class="el" href="svn__fs_8h_source.html">svn_fs.h</a>.</p>

</div>
</div>
<a class="anchor" id="gad9fcc8cddb1a0cd207b53196d88152d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SVN_FS_TYPE_FSFS&#160;&#160;&#160;&quot;fsfs&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>New in 1.1. </dd></dl>

<p>Definition at line <a class="el" href="svn__fs_8h_source.html#l00122">122</a> of file <a class="el" href="svn__fs_8h_source.html">svn_fs.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga2697d2b291384d9511aef9857daf8aa1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structsvn__fs__dirent__t.html">svn_fs_dirent_t</a>  <a class="el" href="structsvn__fs__dirent__t.html">svn_fs_dirent_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of a Subversion directory entry. </p>

</div>
</div>
<a class="anchor" id="ga18d5e6d8766261e5a0b362d3ca4c219a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* svn_fs_freeze_func_t)(void *baton, apr_pool_t *pool)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback for <a class="el" href="group__fs__handling.html#ga354b9fd5754cc10ce1cd2acd46bdd4c6" title="Take an exclusive lock on fs to prevent commits and then invoke freeze_func passing freeze_baton...">svn_fs_freeze()</a>. </p>
<dl class="section since"><dt>Since</dt><dd>New in 1.8. </dd></dl>

<p>Definition at line <a class="el" href="svn__fs_8h_source.html#l00440">440</a> of file <a class="el" href="svn__fs_8h_source.html">svn_fs.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaa31b679ed9ca7b53241ebda04c035140"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__fs__handling.html#gaa31b679ed9ca7b53241ebda04c035140">svn_fs_history_t</a> <a class="el" href="group__fs__handling.html#gaa31b679ed9ca7b53241ebda04c035140">svn_fs_history_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An opaque node history object. </p>

<p>Definition at line <a class="el" href="svn__fs_8h_source.html#l01347">1347</a> of file <a class="el" href="svn__fs_8h_source.html">svn_fs.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga32fc8b28e63f9f0e7cab74c8a44f819c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group__fs__handling.html#ga7c9b681798a28beb90cb747c0626b5b2">svn_fs_pack_notify_action_t</a>  <a class="el" href="group__fs__handling.html#ga7c9b681798a28beb90cb747c0626b5b2">svn_fs_pack_notify_action_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The kind of action being taken by 'pack'. </p>

</div>
</div>
<a class="anchor" id="ga418eae984b0da828404197edf9fcc46e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* svn_fs_pack_notify_t)(void *baton, apr_int64_t shard, <a class="el" href="group__fs__handling.html#ga7c9b681798a28beb90cb747c0626b5b2">svn_fs_pack_notify_action_t</a> action, apr_pool_t *pool)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of a pack notification function. </p>
<p><em>shard</em> is the shard being acted upon; <em>action</em> is the type of action being performed. <em>baton</em> is the corresponding baton for the notification function, and <em>pool</em> can be used for temporary allocations, but will be cleared between invocations. </p>

<p>Definition at line <a class="el" href="svn__fs_8h_source.html#l02423">2423</a> of file <a class="el" href="svn__fs_8h_source.html">svn_fs.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaabf75bf085ab7f392eff150cec4e49a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* svn_fs_process_contents_func_t)(const unsigned char *contents, apr_size_t len, void *baton, apr_pool_t *scratch_pool)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function type used with <a class="el" href="group__fs__handling.html#ga48972a36b2007b043bc7983be1ddd1b9" title="Efficiently deliver the contents of the file path in root via processor (with baton), setting *success to TRUE upon doing so. ">svn_fs_try_process_file_contents()</a> that delivers the immutable, non-NULL <em>contents</em> of <em>len</em> bytes. </p>
<p><em>baton</em> is an implementation-specific closure.</p>
<p>Use <em>scratch_pool</em> for allocations.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.8. </dd></dl>

<p>Definition at line <a class="el" href="svn__fs_8h_source.html#l01914">1914</a> of file <a class="el" href="svn__fs_8h_source.html">svn_fs.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga0baf65b94f952b09dee2983871a691cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* svn_fs_progress_notify_func_t)(<a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> revision, void *baton, apr_pool_t *pool)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function type for progress notification. </p>
<p><em>revision</em> is the number of the revision currently begin processed, <a class="el" href="svn__types_8h.html#a8857d4630bf116eaba54a1b65d43ad92" title="The &#39;official&#39; invalid revision num. ">SVN_INVALID_REVNUM</a> if the current stage is not linked to any specific revision. <em>baton</em> is the callback baton.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.8. </dd></dl>

<p>Definition at line <a class="el" href="svn__fs_8h_source.html#l00292">292</a> of file <a class="el" href="svn__fs_8h_source.html">svn_fs.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga2419fff1bb2c1e523b00e276ed3862e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> <a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An object representing a Subversion filesystem. </p>

<p>Definition at line <a class="el" href="svn__fs_8h_source.html#l00066">66</a> of file <a class="el" href="svn__fs_8h_source.html">svn_fs.h</a>.</p>

</div>
</div>
<a class="anchor" id="gafa2c790fffb1abbd103c954a5d983646"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* svn_fs_warning_callback_t)(void *baton, <a class="el" href="structsvn__error__t.html">svn_error_t</a> *err)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of a warning callback function. </p>
<p><em>baton</em> is the value specified in the call to <a class="el" href="group__fs__handling.html#gabc881c866ebe2cbd41767374264532e8" title="Provide a callback function, warning, that fs should use to report (non-fatal) errors. ">svn_fs_set_warning_func()</a>; the filesystem passes it through to the callback. <em>err</em> contains the warning message.</p>
<p>The callback function should not clear the error that is passed to it; its caller should do that. </p>

<p>Definition at line <a class="el" href="svn__fs_8h_source.html#l00187">187</a> of file <a class="el" href="svn__fs_8h_source.html">svn_fs.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga7c9b681798a28beb90cb747c0626b5b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__fs__handling.html#ga7c9b681798a28beb90cb747c0626b5b2">svn_fs_pack_notify_action_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The kind of action being taken by 'pack'. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga7c9b681798a28beb90cb747c0626b5b2afba8e92df732aad1d260c907a671d974"></a>svn_fs_pack_notify_start</em>&nbsp;</td><td class="fielddoc">
<p>packing of the shard has commenced </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga7c9b681798a28beb90cb747c0626b5b2a418f1ef1d170f644d49d055b4d4e244f"></a>svn_fs_pack_notify_end</em>&nbsp;</td><td class="fielddoc">
<p>packing of the shard is completed </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga7c9b681798a28beb90cb747c0626b5b2a7e2b473fa5c9367b08a76f92f7e856fa"></a>svn_fs_pack_notify_start_revprop</em>&nbsp;</td><td class="fielddoc">
<p>packing of the shard revprops has commenced </p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga7c9b681798a28beb90cb747c0626b5b2a3d08320b848ebe9a3f5b6846e67cda2f"></a>svn_fs_pack_notify_end_revprop</em>&nbsp;</td><td class="fielddoc">
<p>packing of the shard revprops has completed </p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>
</td></tr>
</table>

<p>Definition at line <a class="el" href="svn__fs_8h_source.html#l02400">2400</a> of file <a class="el" href="svn__fs_8h_source.html">svn_fs.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga61f5a039a4ad8818de163578b9c054f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_apply_text </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **&#160;</td>
          <td class="paramname"><em>contents_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>result_checksum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data directly to the file <em>path</em> in <em>root</em>. </p>
<p><em>root</em> must be the root of a transaction, not a revision.</p>
<p>Set <em>*contents_p</em> to a stream ready to receive full textual data. When the caller closes this stream, the data replaces the previous contents of the file. The caller must write all file data and close the stream before making further changes to the transaction.</p>
<p>If <em>path</em> does not exist in <em>root</em>, return an error. (You cannot use this routine to create new files; use <a class="el" href="group__fs__handling.html#gac760753f1ae74fc19991d5dab7cb643c" title="Create a new file named path in root. ">svn_fs_make_file()</a> to create an empty file first.)</p>
<p><em>result_checksum</em> is the hex MD5 digest for the final fulltext written to the stream. It is ignored if NULL, but if not null, it must match the checksum of the result; if it does not, then the <em>*contents_p</em> call which detects the mismatch will return the error <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660ae0b4dcc1b314982153e251724ce8d40b" title="&quot;A checksum mismatch occurred&quot; ">SVN_ERR_CHECKSUM_MISMATCH</a>.</p>
<p>Do any necessary temporary allocation in <em>pool</em>.</p>
<h3>This is like <a class="el" href="group__fs__handling.html#ga8ae7391b579009b76e238fe9ef5b8053" title="Apply a text delta to the file path in root. ">svn_fs_apply_textdelta()</a>, but takes the text</h3>
<p>straight. It is currently used only by the loader, see libsvn_repos/load.c. It should accept a checksum, of course, which would come from an (optional) header in the dump file. See <a href="http://subversion.tigris.org/issues/show_bug.cgi?id=1102">http://subversion.tigris.org/issues/show_bug.cgi?id=1102</a> for more. </p>

</div>
</div>
<a class="anchor" id="ga8ae7391b579009b76e238fe9ef5b8053"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_apply_textdelta </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__delta__txt__delta.html#ga1c0d461a3f244928d7f0339c1cbe3219">svn_txdelta_window_handler_t</a> *&#160;</td>
          <td class="paramname"><em>contents_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>contents_baton_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>base_checksum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>result_checksum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a text delta to the file <em>path</em> in <em>root</em>. </p>
<p><em>root</em> must be the root of a transaction, not a revision.</p>
<p>Set <em>*contents_p</em> to a function ready to receive text delta windows describing how to change the file's contents, relative to its current contents. Set <em>*contents_baton_p</em> to a baton to pass to <em>*contents_p</em>.</p>
<p>If <em>path</em> does not exist in <em>root</em>, return an error. (You cannot use this routine to create new files; use <a class="el" href="group__fs__handling.html#gac760753f1ae74fc19991d5dab7cb643c" title="Create a new file named path in root. ">svn_fs_make_file()</a> to create an empty file first.)</p>
<p><em>base_checksum</em> is the hex MD5 digest for the base text against which the delta is to be applied; it is ignored if NULL, and may be ignored even if not NULL. If it is not ignored, it must match the checksum of the base text against which svndiff data is being applied; if not, <a class="el" href="group__fs__handling.html#ga8ae7391b579009b76e238fe9ef5b8053" title="Apply a text delta to the file path in root. ">svn_fs_apply_textdelta()</a> or the <em>*contents_p</em> call which detects the mismatch will return the error <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660ae0b4dcc1b314982153e251724ce8d40b" title="&quot;A checksum mismatch occurred&quot; ">SVN_ERR_CHECKSUM_MISMATCH</a> (if there is no base text, there may still be an error if <em>base_checksum</em> is neither NULL nor the checksum of the empty string).</p>
<p><em>result_checksum</em> is the hex MD5 digest for the fulltext that results from this delta application. It is ignored if NULL, but if not NULL, it must match the checksum of the result; if it does not, then the <em>*contents_p</em> call which detects the mismatch will return the error <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660ae0b4dcc1b314982153e251724ce8d40b" title="&quot;A checksum mismatch occurred&quot; ">SVN_ERR_CHECKSUM_MISMATCH</a>.</p>
<p>The caller must send all delta windows including the terminating NULL window to <em>*contents_p</em> before making further changes to the transaction.</p>
<p>Do temporary allocation in <em>pool</em>. </p>

</div>
</div>
<a class="anchor" id="ga75ce7073e254911b82f9acc4825d4247"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_change_node_prop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change a node's property's value, or add/delete a property. </p>
<ul>
<li><em>root</em> and <em>path</em> indicate the node whose property should change. <em>root</em> must be the root of a transaction, not the root of a revision.</li>
<li><em>name</em> is the name of the property to change.</li>
<li><em>value</em> is the new value of the property, or zero if the property should be removed altogether. Do any necessary temporary allocation in <em>pool</em>. </li>
</ul>

</div>
</div>
<a class="anchor" id="gab368d97a4f5093e8c71f8082f4664937"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_change_rev_prop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a>&#160;</td>
          <td class="paramname"><em>rev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="group__fs__handling.html#ga42e1c39fc4980da8c2f2f575fa7515ac" title="Change a revision&#39;s property&#39;s value, or add/delete a property. ">svn_fs_change_rev_prop2()</a>, but with <em>old_value_p</em> passed as <code>NULL</code>. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000207">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.6 API. </dd></dl>

</div>
</div>
<a class="anchor" id="ga42e1c39fc4980da8c2f2f575fa7515ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_change_rev_prop2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a>&#160;</td>
          <td class="paramname"><em>rev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *const *&#160;</td>
          <td class="paramname"><em>old_value_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change a revision's property's value, or add/delete a property. </p>
<ul>
<li><em>fs</em> is a filesystem, and <em>rev</em> is the revision in that filesystem whose property should change.</li>
<li><em>name</em> is the name of the property to change.</li>
<li>if <em>old_value_p</em> is not <code>NULL</code>, then changing the property will fail with error <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660a6dfc3b1c5aa7779e2a83373e735e1c88" title="&quot;Property value in filesystem differs from the provided &quot; &quot;base value&quot; ">SVN_ERR_FS_PROP_BASEVALUE_MISMATCH</a> if the present value of the property is not <em>*old_value_p</em>. (This is an atomic test-and-set). <em>*old_value_p</em> may be <code>NULL</code>, representing that the property must be not already set.</li>
<li><em>value</em> is the new value of the property, or zero if the property should be removed altogether.</li>
</ul>
<p>Note that revision properties are non-historied &mdash; you can change them after the revision has been committed. They are not protected via transactions.</p>
<p>Do any necessary temporary allocation in <em>pool</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8795c6c2a696353b550c2f733787a015"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_check_path </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#ac3ca125707a8ca1289c73236b5ce7f9a">svn_node_kind_t</a> *&#160;</td>
          <td class="paramname"><em>kind_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>*kind_p</em> to the type of node present at <em>path</em> under <em>root</em>. </p>
<p>If <em>path</em> does not exist under <em>root</em>, set <em>*kind_p</em> to <a class="el" href="svn__types_8h.html#ac3ca125707a8ca1289c73236b5ce7f9aae4066898ada99c4a3bc94e80aabe78b5" title="absent ">svn_node_none</a>. Use <em>pool</em> for temporary allocation. </p>

</div>
</div>
<a class="anchor" id="ga9d7839028ca775d36c6fdc851973f9ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_closest_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> **&#160;</td>
          <td class="paramname"><em>root_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>path_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>*root_p</em> and <em>*path_p</em> to the revision root and path of the destination of the most recent copy event that caused <em>path</em> to exist where it does in <em>root</em>, or to NULL if no such copy exists. </p>
<p><em>*path_p</em> might be a parent of <em>path</em>, rather than <em>path</em> itself. However, it will always be the deepest relevant path. That is, if a copy occurs underneath another copy in the same txn, this function makes sure to set <em>*path_p</em> to the longest copy destination path that is still a parent of or equal to <em>path</em>.</p>
<p>Values returned in <em>*root_p</em> and <em>*path_p</em> will be allocated from <em>pool</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.3. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4275158ceab7ec93162f62c7cc5cfbae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_hash_t* svn_fs_config </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a shallow copy of the configuration parameters used to open <em>fs</em>, allocated in <em>pool</em>. </p>
<p>It may be <code>NULL</code>. The contents of the hash contents remains valid only for <em>fs's</em> lifetime.</p>
<dl class="section note"><dt>Note</dt><dd>This is just what was passed to <a class="el" href="group__fs__handling.html#ga24b9cee11c6d584ddb0b9d74efca5dd5" title="Create a new, empty Subversion filesystem, stored in the directory path, and return a pointer to it i...">svn_fs_create()</a> or <a class="el" href="group__fs__handling.html#gaf31aff19f6ddd70e665235ff1857fc35" title="Open a Subversion filesystem located in the directory path, and return a pointer to it in *fs_p...">svn_fs_open()</a>. You may not modify it.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.8. </dd></dl>

</div>
</div>
<a class="anchor" id="gaede66ee7850d389bcdeb5ddef1540fdc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_contents_changed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *&#160;</td>
          <td class="paramname"><em>changed_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the contents of two root/path combos have changed. </p>
<p>Set <em>*changed_p</em> to 1 if the contents at <em>path1</em> under <em>root1</em> differ from those at <em>path2</em> under <em>root2</em>, or set it to 0 if they are the same. Both paths must exist under their respective roots, and both roots must be in the same filesystem. </p>

</div>
</div>
<a class="anchor" id="gaed6116279287a80ec4f7de380a732f45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_copied_from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> *&#160;</td>
          <td class="paramname"><em>rev_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>path_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discover a node's copy ancestry, if any. </p>
<p>If the node at <em>path</em> in <em>root</em> was copied from some other node, set <em>*rev_p</em> and <em>*path_p</em> to the revision and path (expressed as an absolute filesystem path) of the other node, allocating <em>*path_p</em> in <em>pool</em>.</p>
<p>Else if there is no copy ancestry for the node, set <em>*rev_p</em> to <a class="el" href="svn__types_8h.html#a8857d4630bf116eaba54a1b65d43ad92" title="The &#39;official&#39; invalid revision num. ">SVN_INVALID_REVNUM</a> and <em>*path_p</em> to NULL.</p>
<p>If an error is returned, the values of <em>*rev_p</em> and <em>*path_p</em> are undefined, but otherwise, if one of them is set as described above, you may assume the other is set correspondingly.</p>
<p><em>root</em> may be a revision root or a transaction root.</p>
<p>Notes:</p>
<ul>
<li>Copy ancestry does not descend. After copying directory D to E, E will have copy ancestry referring to D, but E's children may not. See also <a class="el" href="group__fs__handling.html#ga9da8e22bd1058f877a275099699bb86b" title="Create a copy of from_path in from_root named to_path in to_root. ">svn_fs_copy()</a>.</li>
<li>Copy ancestry <em>under</em> a copy is preserved. That is, if you copy /A/D/G/pi to /A/D/G/pi2, and then copy /A/D/G to /G, then /G/pi2 will still have copy ancestry pointing to /A/D/G/pi. We don't know if this is a feature or a bug yet; if it turns out to be a bug, then the fix is to make <a class="el" href="group__fs__handling.html#gaed6116279287a80ec4f7de380a732f45" title="Discover a node&#39;s copy ancestry, if any. ">svn_fs_copied_from()</a> observe the following logic, which currently callers may choose to follow themselves: if node X has copy history, but its ancestor A also has copy history, then you may ignore X's history if X's revision-of-origin is earlier than A's &ndash; because that would mean that X's copy history was preserved in a copy-under-a-copy scenario. If X's revision-of-origin is the same as A's, then it was copied under A during the same transaction that created A. (X's revision-of-origin cannot be greater than A's, if X has copy history.)<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>See how people like this, it can always be hidden behind the curtain if necessary.</dd></dl>
</li>
<li>Copy ancestry is not stored as a regular subversion property because it is not inherited. Copying foo to bar results in a revision of bar with copy ancestry; but committing a text change to bar right after that results in a new revision of bar without copy ancestry. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga9da8e22bd1058f877a275099699bb86b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>from_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>to_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a copy of <em>from_path</em> in <em>from_root</em> named <em>to_path</em> in <em>to_root</em>. </p>
<p>If <em>from_path</em> in <em>from_root</em> is a directory, copy the tree it refers to recursively.</p>
<p>The copy will remember its source; use <a class="el" href="group__fs__handling.html#gaed6116279287a80ec4f7de380a732f45" title="Discover a node&#39;s copy ancestry, if any. ">svn_fs_copied_from()</a> to access this information.</p>
<p><em>to_root</em> must be the root of a transaction; <em>from_root</em> must be the root of a revision. (Requiring <em>from_root</em> to be the root of a revision makes the implementation trivial: there is no detectable difference (modulo node revision ID's) between copying <em>from</em> and simply adding a reference to it. So the operation takes place in constant time. However, there's no reason not to extend this to mutable nodes &mdash; it's just more code.) Further, <em>to_root</em> and <em>from_root</em> must represent the same filesystem.</p>
<dl class="section note"><dt>Note</dt><dd>To do a copy without preserving copy history, use <a class="el" href="group__fs__handling.html#gaddd7ec5b6e3306c609e46d4f5a2b8a5c" title="Like svn_fs_copy(), but doesn&#39;t record copy history, and preserves the PATH. ">svn_fs_revision_link()</a>.</dd></dl>
<p>Do any necessary temporary allocation in <em>pool</em>. </p>

</div>
</div>
<a class="anchor" id="ga24b9cee11c6d584ddb0b9d74efca5dd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> **&#160;</td>
          <td class="paramname"><em>fs_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_hash_t *&#160;</td>
          <td class="paramname"><em>fs_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new, empty Subversion filesystem, stored in the directory <em>path</em>, and return a pointer to it in <em>*fs_p</em>. </p>
<p><em>path</em> must not currently exist, but its parent must exist. If <em>fs_config</em> is not <code>NULL</code>, the options it contains modify the behavior of the filesystem. The interpretation of <em>fs_config</em> is specific to the filesystem back-end. The new filesystem may be closed by destroying <em>pool</em>.</p>
<dl class="section note"><dt>Note</dt><dd>The lifetime of <em>fs_config</em> must not be shorter than <em>pool's</em>. It's a good idea to allocate <em>fs_config</em> from <em>pool</em> or one of its ancestors.</dd></dl>
<p>If <em>fs_config</em> contains a value for <a class="el" href="group__fs__handling.html#ga8cce99342f8830d9541901fcbc5fa8b3">SVN_FS_CONFIG_FS_TYPE</a>, that value determines the filesystem type for the new filesystem. Currently defined values are:</p>
<p>SVN_FS_TYPE_BDB Berkeley-DB implementation SVN_FS_TYPE_FSFS Native-filesystem implementation</p>
<p>If <em>fs_config</em> is <code>NULL</code> or does not contain a value for <a class="el" href="group__fs__handling.html#ga8cce99342f8830d9541901fcbc5fa8b3">SVN_FS_CONFIG_FS_TYPE</a> then the default filesystem type will be used. This will typically be BDB for version 1.1 and FSFS for later versions, though the caller should not rely upon any particular default if they wish to ensure that a filesystem of a specific type is created.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.1. </dd></dl>

</div>
</div>
<a class="anchor" id="ga528e3cf9010e463b511584f4143b6a72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete the node named <em>path</em> in <em>root</em>. </p>
<p>If the node being deleted is a directory, its contents will be deleted recursively. <em>root</em> must be the root of a transaction, not of a revision. Use <em>pool</em> for temporary allocation.</p>
<p>If return <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660afe8be58c4336e3738d014080bad824b5" title="&quot;Filesystem directory has no such entry&quot; ">SVN_ERR_FS_NO_SUCH_ENTRY</a>, then the basename of <em>path</em> is missing from its parent, that is, the final target of the deletion is missing.</p>
<p>Attempting to remove the root dir also results in an error, <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660ac8c62e965631f70a309adc10762fd2ac" title="&quot;Attempt to remove or recreate fs root dir&quot; ">SVN_ERR_FS_ROOT_DIR</a>, even if the dir is empty. </p>

</div>
</div>
<a class="anchor" id="ga6d1642cd31bc5e860d521c8c80058058"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_delete_fs </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete the filesystem at <em>path</em>. </p>
<dl class="section note"><dt>Note</dt><dd>: Deleting a filesystem that has an open svn_fs_t is not supported. Clear/destroy all pools used to create/open <em>path</em>. See issue 4264.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.1. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3f29dd4915629fc66ea1af713b659ce5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_deltify_revision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a>&#160;</td>
          <td class="paramname"><em>revision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide filesystem <em>fs</em> the opportunity to compress storage relating to associated with <em>revision</em> in filesystem <em>fs</em>. </p>
<p>Use <em>pool</em> for all allocations.</p>
<dl class="section note"><dt>Note</dt><dd>This can be a time-consuming process, depending the breadth of the changes made in <em>revision</em>, and the depth of the history of those changed paths. This may also be a no op. </dd></dl>

</div>
</div>
<a class="anchor" id="gad254aea2a12fbd7c8c62c8aaa3c4624c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_dir_entries </td>
          <td>(</td>
          <td class="paramtype">apr_hash_t **&#160;</td>
          <td class="paramname"><em>entries_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>*entries_p</em> to a newly allocated APR hash table containing the entries of the directory at <em>path</em> in <em>root</em>. </p>
<p>The keys of the table are entry names, as byte strings, excluding the final NULL character; the table's values are pointers to <a class="el" href="structsvn__fs__dirent__t.html" title="The type of a Subversion directory entry. ">svn_fs_dirent_t</a> structures. Allocate the table and its contents in <em>pool</em>. </p>

</div>
</div>
<a class="anchor" id="ga3a35bf47dcd1d43fdf7572166eb0eeb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_file_checksum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__checksum__t.html">svn_checksum_t</a> **&#160;</td>
          <td class="paramname"><em>checksum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__checksum_8h.html#a7a6c373d03d7e6ec6b832a039f5e0aa1">svn_checksum_kind_t</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>force</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>*checksum</em> to the checksum of type <em>kind</em> for the file <em>path</em>. </p>
<p><em>*checksum</em> will be allocated out of <em>pool</em>, which will also be used for temporary allocations.</p>
<p>If the filesystem does not have a prerecorded checksum of <em>kind</em> for <em>path</em>, and <em>force</em> is not TRUE, do not calculate a checksum dynamically, just put NULL into <em>checksum</em>. (By convention, the NULL checksum is considered to match any checksum.)</p>
<p>Notes:</p>
<p>You might wonder, why do we only provide this interface for file contents, and not for properties or directories?</p>
<p>The answer is that property lists and directory entry lists are essentially data structures, not text. We serialize them for transmission, but there is no guarantee that the consumer will parse them into the same form, or even the same order, as the producer. It's difficult to find a checksumming method that reaches the same result given such variation in input. (I suppose we could calculate an independent MD5 sum for each propname and value, and XOR them together; same with directory entry names. Maybe that's the solution?) Anyway, for now we punt. The most important data, and the only data that goes through svndiff processing, is file contents, so that's what we provide checksumming for.</p>
<p>Internally, of course, the filesystem checksums everything, because it has access to the lowest level storage forms: strings behind representations.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a class="anchor" id="gafe8eadb1c6950e3bfdca49bbb497d6fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_file_contents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>*contents</em> to a readable generic stream that will yield the contents of the file <em>path</em> in <em>root</em>. </p>
<p>Allocate the stream in <em>pool</em>. You can only use <em>*contents</em> for as long as the underlying filesystem is open. If <em>path</em> is not a file, return <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660aa450bc43bfe000e40bc1461ced205a8d" title="&quot;Name does not refer to a filesystem file&quot; ">SVN_ERR_FS_NOT_FILE</a>.</p>
<p>If <em>root</em> is the root of a transaction, it is possible that the contents of the file <em>path</em> will change between calls to <a class="el" href="group__fs__handling.html#gafe8eadb1c6950e3bfdca49bbb497d6fb" title="Set *contents to a readable generic stream that will yield the contents of the file path in root...">svn_fs_file_contents()</a>. In that case, the result of reading from <em>*contents</em> is undefined.</p>
<h3>todo 4.</h3>

</div>
</div>
<a class="anchor" id="gabd675ec4bc28c7f4e72a121feeb60059"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_file_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a726e581898461c1d3e7dbdb16d99dad0">svn_filesize_t</a> *&#160;</td>
          <td class="paramname"><em>length_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>*length_p</em> to the length of the file <em>path</em> in <em>root</em>, in bytes. </p>
<p>Do any necessary temporary allocation in <em>pool</em>. </p>

</div>
</div>
<a class="anchor" id="ga9dfe5ed9f63bb8b222d2adb2b96f0220"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_file_md5_checksum </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>digest</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="group__fs__handling.html#ga3a35bf47dcd1d43fdf7572166eb0eeb4" title="Set *checksum to the checksum of type kind for the file path. ">svn_fs_file_checksum()</a>, only always put the MD5 checksum of file <em>path</em> into <em>digest</em>, which should point to <code>APR_MD5_DIGESTSIZE</code> bytes of storage. </p>
<p>If the checksum doesn't exist, put all 0's into <em>digest</em>.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000206">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.5 API. </dd></dl>

</div>
</div>
<a class="anchor" id="ga354b9fd5754cc10ce1cd2acd46bdd4c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_freeze </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga18d5e6d8766261e5a0b362d3ca4c219a">svn_fs_freeze_func_t</a>&#160;</td>
          <td class="paramname"><em>freeze_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>freeze_baton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take an exclusive lock on <em>fs</em> to prevent commits and then invoke <em>freeze_func</em> passing <em>freeze_baton</em>. </p>
<dl class="section note"><dt>Note</dt><dd>The BDB backend doesn't implement this feature so most callers should not call this function directly but should use the higher level <a class="el" href="svn__repos_8h.html#ab01ddb7a9fb4325c721cbba41350ad9b" title="Take an exclusive lock on each of the repositories in paths to prevent commits and then while holding...">svn_repos_freeze()</a> instead.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="svn__repos_8h.html#ab01ddb7a9fb4325c721cbba41350ad9b" title="Take an exclusive lock on each of the repositories in paths to prevent commits and then while holding...">svn_repos_freeze()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.8. </dd></dl>

</div>
</div>
<a class="anchor" id="gad2d4b1fa18c0bbda6719d4414b52f4c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_get_file_delta_stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__delta__txt__delta.html#gaf599af000e3c3b976c17fd4e101ff7cf">svn_txdelta_stream_t</a> **&#160;</td>
          <td class="paramname"><em>stream_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>source_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>source_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>target_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>target_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>*stream_p</em> to a pointer to a delta stream that will turn the contents of the file <em>source</em> into the contents of the file <em>target</em>. </p>
<p>If <em>source_root</em> is zero, use a file with zero length as the source.</p>
<p>This function does not compare the two files' properties.</p>
<p>Allocate <em>*stream_p</em>, and do any necessary temporary allocation, in <em>pool</em>. </p>

</div>
</div>
<a class="anchor" id="ga2976ec837ee7caa7771e61ed266933b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_get_mergeinfo </td>
          <td>(</td>
          <td class="paramtype">svn_mergeinfo_catalog_t *&#160;</td>
          <td class="paramname"><em>catalog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const apr_array_header_t *&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#acd81e9d0f5bcc4eec4df7b8a140f435c">svn_mergeinfo_inheritance_t</a>&#160;</td>
          <td class="paramname"><em>inherit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>include_descendants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="group__fs__handling.html#ga326d7cf7dbaf76ea00acf58ab23d16dc" title="Retrieve mergeinfo for multiple nodes. ">svn_fs_get_mergeinfo2()</a>, but with <em>adjust_inherited_mergeinfo</em> set always set to <code>TRUE</code> and with only one pool. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000205">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.5 API. </dd></dl>

</div>
</div>
<a class="anchor" id="ga326d7cf7dbaf76ea00acf58ab23d16dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_get_mergeinfo2 </td>
          <td>(</td>
          <td class="paramtype">svn_mergeinfo_catalog_t *&#160;</td>
          <td class="paramname"><em>catalog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const apr_array_header_t *&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#acd81e9d0f5bcc4eec4df7b8a140f435c">svn_mergeinfo_inheritance_t</a>&#160;</td>
          <td class="paramname"><em>inherit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>include_descendants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>adjust_inherited_mergeinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve mergeinfo for multiple nodes. </p>
<p><em>*catalog</em> is a catalog for <em>paths</em>. It will never be <code>NULL</code>, but may be empty.</p>
<p><em>root</em> is revision root to use when looking up paths.</p>
<p><em>paths</em> are the paths you are requesting information for.</p>
<p><em>inherit</em> indicates whether to retrieve explicit, explicit-or-inherited, or only inherited mergeinfo.</p>
<p>If <em>adjust_inherited_mergeinfo</em> is <code>TRUE</code>, then any inherited mergeinfo returned in <em>*catalog</em> is normalized to represent the inherited mergeinfo on the path which inherits it. If <em>adjust_inherited_mergeinfo</em> is <code>FALSE</code>, then any inherited mergeinfo is the raw explicit mergeinfo from the nearest parent of the path with explicit mergeinfo, unadjusted for the path-wise difference between the path and its parent. This may include non-inheritable mergeinfo.</p>
<p>If <em>include_descendants</em> is TRUE, then additionally return the mergeinfo for any descendant of any element of <em>paths</em> which has the <a class="el" href="group__svn__prop__visible__props.html#gadfcde61bc857d2fa1741eb8e55588425" title="Merge info property used to record a resource&#39;s merge history. ">SVN_PROP_MERGEINFO</a> property explicitly set on it. (Note that inheritance is only taken into account for the elements in <em>paths</em>; descendants of the elements in <em>paths</em> which get their mergeinfo via inheritance are not included in <em>*catalog</em>.)</p>
<p>Allocate <em>*catalog</em> in result_pool. Do any necessary temporary allocations in <em>scratch_pool</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.8. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2ce6bd7610fc7201f4ea6b4e20e49e67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_get_uuid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>uuid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate <em>*uuid</em> with the UUID associated with <em>fs</em>. </p>
<p>Allocate <em>*uuid</em> in <em>pool</em>. </p>

</div>
</div>
<a class="anchor" id="ga266d0597466eb198dc4b593fcd44490e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_history_location </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> *&#160;</td>
          <td class="paramname"><em>revision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#gaa31b679ed9ca7b53241ebda04c035140">svn_fs_history_t</a> *&#160;</td>
          <td class="paramname"><em>history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>*path</em> and <em>*revision</em> to the path and revision, respectively, of the <em>history</em> object. </p>
<p>Use <em>pool</em> for all allocations. </p>

</div>
</div>
<a class="anchor" id="ga58dd5d7dc74bef946a4dc1129c342038"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_history_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#gaa31b679ed9ca7b53241ebda04c035140">svn_fs_history_t</a> **&#160;</td>
          <td class="paramname"><em>prev_history_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#gaa31b679ed9ca7b53241ebda04c035140">svn_fs_history_t</a> *&#160;</td>
          <td class="paramname"><em>history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>cross_copies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>*prev_history_p</em> to an opaque node history object which represents the previous (or "next oldest") interesting history location for the filesystem node represented by <em>history</em>, or <code>NULL</code> if no such previous history exists. </p>
<p>If <em>cross_copies</em> is <code>FALSE</code>, also return <code>NULL</code> if stepping backwards in history to <em>*prev_history_p</em> would cross a filesystem copy operation.</p>
<dl class="section note"><dt>Note</dt><dd>If this is the first call to <a class="el" href="group__fs__handling.html#ga58dd5d7dc74bef946a4dc1129c342038" title="Set *prev_history_p to an opaque node history object which represents the previous (or &quot;next oldest&quot;)...">svn_fs_history_prev()</a> for the <em>history</em> object, it could return a history object whose location is the same as the original. This will happen if the original location was an interesting one (where the node was modified, or took place in a copy event). This behavior allows looping callers to avoid the calling <a class="el" href="group__fs__handling.html#ga266d0597466eb198dc4b593fcd44490e" title="Set *path and *revision to the path and revision, respectively, of the history object. ">svn_fs_history_location()</a> on the object returned by <a class="el" href="group__fs__handling.html#ga2412ddc868b0ef6cdbbe3b682827885e" title="Set *history_p to an opaque node history object which represents path under root. ...">svn_fs_node_history()</a>, and instead go ahead and begin calling <a class="el" href="group__fs__handling.html#ga58dd5d7dc74bef946a4dc1129c342038" title="Set *prev_history_p to an opaque node history object which represents the previous (or &quot;next oldest&quot;)...">svn_fs_history_prev()</a>.</dd>
<dd>
This function uses node-id ancestry alone to determine modifiedness, and therefore does NOT claim that in any of the returned revisions file contents changed, properties changed, directory entries lists changed, etc.</dd>
<dd>
The revisions returned for <em>path</em> will be older than or the same age as the revision of that path in <em>root</em>. That is, if <em>root</em> is a revision root based on revision X, and <em>path</em> was modified in some revision(s) younger than X, those revisions younger than X will not be included for <em>path</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2909d84e561fbfd8b0f321dbded129b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_hotcopy </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dest_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>clean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <a class="el" href="group__fs__handling.html#gab0d6cd72d57ad6818843a30cdba5e3e1" title="Copy a possibly live Subversion filesystem from src_path to dest_path. ">svn_fs_hotcopy2()</a>, but with <em>incremental</em> always passed as <code>TRUE</code> and without cancellation support. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000191">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.7 API. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.1. </dd></dl>

</div>
</div>
<a class="anchor" id="gab0d6cd72d57ad6818843a30cdba5e3e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_hotcopy2 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dest_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>clean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>incremental</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#addaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a>&#160;</td>
          <td class="paramname"><em>cancel_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cancel_baton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a possibly live Subversion filesystem from <em>src_path</em> to <em>dest_path</em>. </p>
<p>If <em>clean</em> is <code>TRUE</code>, perform cleanup on the source filesystem as part of the copy operation; currently, this means deleting copied, unused logfiles for a Berkeley DB source filesystem.</p>
<p>If <em>incremental</em> is TRUE, make an effort to avoid re-copying information already present in the destination where possible. If incremental hotcopy is not implemented, raise <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660a4152fa8f6143f7bcd6f2f7d656096c8b" title="&quot;Trying to use an unsupported feature&quot; ">SVN_ERR_UNSUPPORTED_FEATURE</a>.</p>
<p>Use <em>scratch_pool</em> for temporary allocations.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.8. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf3bce1e26521c4432f14f3adfc617f17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_initialize </td>
          <td>(</td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callers should invoke this function to initialize global state in the FS library before creating FS objects. </p>
<p>If this function is invoked, no FS objects may be created in another thread at the same time as this invocation, and the provided <em>pool</em> must last longer than any FS object created subsequently.</p>
<p>If this function is not called, the FS library will make a best effort to bootstrap a mutex for protecting data common to FS objects; however, there is a small window of failure. Also, a small amount of data will be leaked if the Subversion FS library is dynamically unloaded, and using the bdb FS can potentially segfault or invoke other undefined behavior if this function is not called with an appropriate pool (such as the pool the module was loaded into) when loaded dynamically.</p>
<p>If this function is called multiple times before the pool passed to the first call is destroyed or cleared, the later calls will have no effect.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.2. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1a5ecfab7f53876e9ad6def4265df7e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_is_dir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *&#160;</td>
          <td class="paramname"><em>is_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>*is_dir</em> to <code>TRUE</code> iff <em>path</em> in <em>root</em> is a directory. </p>
<p>Do any necessary temporary allocation in <em>pool</em>. </p>

</div>
</div>
<a class="anchor" id="ga84b9e2f502354e16162edd12e8f5cc5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_is_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *&#160;</td>
          <td class="paramname"><em>is_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>*is_file</em> to <code>TRUE</code> iff <em>path</em> in <em>root</em> is a file. </p>
<p>Do any necessary temporary allocation in <em>pool</em>. </p>

</div>
</div>
<a class="anchor" id="ga8484e37e57a52bb38e5067c38bf41e16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_make_dir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new directory named <em>path</em> in <em>root</em>. </p>
<p>The new directory has no entries, and no properties. <em>root</em> must be the root of a transaction, not a revision.</p>
<p>Do any necessary temporary allocation in <em>pool</em>. </p>

</div>
</div>
<a class="anchor" id="gac760753f1ae74fc19991d5dab7cb643c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_make_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new file named <em>path</em> in <em>root</em>. </p>
<p>The file's initial contents are the empty string, and it has no properties. <em>root</em> must be the root of a transaction, not a revision.</p>
<p>Do any necessary temporary allocation in <em>pool</em>. </p>

</div>
</div>
<a class="anchor" id="gafc5df16564312635dc97077a29e73d8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_merge </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>conflict_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>source_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>source_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>target_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>target_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>ancestor_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ancestor_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge changes between two nodes into a third node. </p>
<p>Given nodes <em>source</em> and <em>target</em>, and a common ancestor <em>ancestor</em>, modify <em>target</em> to contain all the changes made between <em>ancestor</em> and <em>source</em>, as well as the changes made between <em>ancestor</em> and <em>target</em>. <em>target_root</em> must be the root of a transaction, not a revision.</p>
<p><em>source</em>, <em>target</em>, and <em>ancestor</em> are generally directories; this function recursively merges the directories' contents. If they are files, this function simply returns an error whenever <em>source</em>, <em>target</em>, and <em>ancestor</em> are all distinct node revisions.</p>
<p>If there are differences between <em>ancestor</em> and <em>source</em> that conflict with changes between <em>ancestor</em> and <em>target</em>, this function returns an <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660a2556cd0052d1516e3985bcc99760a66d" title="&quot;Merge conflict during commit&quot; ">SVN_ERR_FS_CONFLICT</a> error.</p>
<p>If the merge is successful, <em>target</em> is left in the merged state, and the base root of <em>target's</em> txn is set to the root node of <em>source</em>. If an error is returned (whether for conflict or otherwise), <em>target</em> is left unaffected.</p>
<p>If <em>conflict_p</em> is non-NULL, then: a conflict error sets <em>*conflict_p</em> to the name of the node in <em>target</em> which couldn't be merged, otherwise, success sets <em>*conflict_p</em> to NULL.</p>
<p>Do any necessary temporary allocation in <em>pool</em>. </p>

</div>
</div>
<a class="anchor" id="gaf25b3de3d8930d857cf6c94777ce9bca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_node_created_path </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>created_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>*created_path</em> to the path at which <em>path</em> under <em>root</em> was created. </p>
<p>Use <em>pool</em> for all allocations. Callers may use this function in conjunction with <a class="el" href="group__fs__handling.html#gad3be25cd08e898319e14cce69580992e" title="Set *revision to the revision in which path under root was created. ">svn_fs_node_created_rev()</a> to perform a reverse lookup of the mapping of (path, revision) -&gt; node-id that <a class="el" href="group__fs__handling.html#gaf59a66cf510e6da06dadfe2b3bb372e1" title="Get the id of a node. ">svn_fs_node_id()</a> performs. </p>

</div>
</div>
<a class="anchor" id="gad3be25cd08e898319e14cce69580992e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_node_created_rev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> *&#160;</td>
          <td class="paramname"><em>revision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>*revision</em> to the revision in which <em>path</em> under <em>root</em> was created. </p>
<p>Use <em>pool</em> for any temporary allocations. <em>*revision</em> will be set to <a class="el" href="svn__types_8h.html#a8857d4630bf116eaba54a1b65d43ad92" title="The &#39;official&#39; invalid revision num. ">SVN_INVALID_REVNUM</a> for uncommitted nodes (i.e. modified nodes under a transaction root). Note that the root of an unmodified transaction is not itself considered to be modified; in that case, return the revision upon which the transaction was based. </p>

</div>
</div>
<a class="anchor" id="ga2412ddc868b0ef6cdbbe3b682827885e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_node_history </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#gaa31b679ed9ca7b53241ebda04c035140">svn_fs_history_t</a> **&#160;</td>
          <td class="paramname"><em>history_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>*history_p</em> to an opaque node history object which represents <em>path</em> under <em>root</em>. </p>
<p><em>root</em> must be a revision root. Use <em>pool</em> for all allocations. </p>

</div>
</div>
<a class="anchor" id="gaf59a66cf510e6da06dadfe2b3bb372e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_node_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__svn__fs__nodes.html#gaeca8f1c373c50ca7bb08e3417242b106">svn_fs_id_t</a> **&#160;</td>
          <td class="paramname"><em>id_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the id of a node. </p>
<p>Set <em>*id_p</em> to the node revision ID of <em>path</em> in <em>root</em>, allocated in <em>pool</em>.</p>
<p>If <em>root</em> is the root of a transaction, keep in mind that other changes to the transaction can change which node <em>path</em> refers to, and even whether the path exists at all. </p>

</div>
</div>
<a class="anchor" id="gaf26ebca946019f3761f48ad8dadd6eaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_node_origin_rev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> *&#160;</td>
          <td class="paramname"><em>revision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>*revision</em> to the revision in which the line of history represented by <em>path</em> under <em>root</em> originated. </p>
<p>Use <em>pool</em> for any temporary allocations. If <em>root</em> is a transaction root, <em>*revision</em> will be set to <a class="el" href="svn__types_8h.html#a8857d4630bf116eaba54a1b65d43ad92" title="The &#39;official&#39; invalid revision num. ">SVN_INVALID_REVNUM</a> for any nodes newly added in that transaction (brand new files or directories created using <a class="el" href="group__fs__handling.html#ga8484e37e57a52bb38e5067c38bf41e16" title="Create a new directory named path in root. ">svn_fs_make_dir</a> or <a class="el" href="group__fs__handling.html#gac760753f1ae74fc19991d5dab7cb643c" title="Create a new file named path in root. ">svn_fs_make_file</a>).</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="ga830b554597da876e1b6256f2836cf349"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_node_prop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__string__t.html">svn_string_t</a> **&#160;</td>
          <td class="paramname"><em>value_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>propname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>*value_p</em> to the value of the property named <em>propname</em> of <em>path</em> in <em>root</em>. </p>
<p>If the node has no property by that name, set <em>*value_p</em> to zero. Allocate the result in <em>pool</em>. </p>

</div>
</div>
<a class="anchor" id="ga079534da68d59ac24307ae171189dd61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_node_proplist </td>
          <td>(</td>
          <td class="paramtype">apr_hash_t **&#160;</td>
          <td class="paramname"><em>table_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>*table_p</em> to the entire property list of <em>path</em> in <em>root</em>, as an APR hash table allocated in <em>pool</em>. </p>
<p>The resulting table maps property names to pointers to <a class="el" href="structsvn__string__t.html" title="A simple counted string. ">svn_string_t</a> objects containing the property value. </p>

</div>
</div>
<a class="anchor" id="gaf31aff19f6ddd70e665235ff1857fc35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> **&#160;</td>
          <td class="paramname"><em>fs_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_hash_t *&#160;</td>
          <td class="paramname"><em>fs_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a Subversion filesystem located in the directory <em>path</em>, and return a pointer to it in <em>*fs_p</em>. </p>
<p>If <em>fs_config</em> is not <code>NULL</code>, the options it contains modify the behavior of the filesystem. The interpretation of <em>fs_config</em> is specific to the filesystem back-end. The opened filesystem may be closed by destroying <em>pool</em>.</p>
<dl class="section note"><dt>Note</dt><dd>The lifetime of <em>fs_config</em> must not be shorter than <em>pool's</em>. It's a good idea to allocate <em>fs_config</em> from <em>pool</em> or one of its ancestors.</dd></dl>
<p>Only one thread may operate on any given filesystem object at once. Two threads may access the same filesystem simultaneously only if they open separate filesystem objects.</p>
<dl class="section note"><dt>Note</dt><dd>You probably don't want to use this directly. Take a look at <a class="el" href="svn__repos_8h.html#a515e52a79813e3fc34fffd8fedd40df0" title="Set *repos_p to a repository object for the repository at path. ">svn_repos_open2()</a> instead.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.1. </dd></dl>

</div>
</div>
<a class="anchor" id="ga307aa2f60e82d9f78d7f7990991533c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_pack </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga418eae984b0da828404197edf9fcc46e">svn_fs_pack_notify_t</a>&#160;</td>
          <td class="paramname"><em>notify_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>notify_baton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#addaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a>&#160;</td>
          <td class="paramname"><em>cancel_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cancel_baton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Possibly update the filesystem located in the directory <em>path</em> to use disk space more efficiently. </p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa1a79172a1faa38b234d365240079c3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* svn_fs_path </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the path to <em>fs's</em> repository, allocated in <em>pool</em>. </p>
<dl class="section note"><dt>Note</dt><dd>This is just what was passed to <a class="el" href="group__fs__handling.html#ga24b9cee11c6d584ddb0b9d74efca5dd5" title="Create a new, empty Subversion filesystem, stored in the directory path, and return a pointer to it i...">svn_fs_create()</a> or <a class="el" href="group__fs__handling.html#gaf31aff19f6ddd70e665235ff1857fc35" title="Open a Subversion filesystem located in the directory path, and return a pointer to it in *fs_p...">svn_fs_open()</a> &ndash; might be absolute, might not.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.1. </dd></dl>

</div>
</div>
<a class="anchor" id="ga26cf98c986a0f71fe9d86be0f73266b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_print_modules </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append a textual list of all available FS modules to the stringbuf <em>output</em>. </p>
<p>Third-party modules are only included if repository access has caused them to be loaded.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.2. </dd></dl>

</div>
</div>
<a class="anchor" id="gaac7c1a6f4732d24a8ee387abb33e33dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_props_changed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *&#160;</td>
          <td class="paramname"><em>changed_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the properties of two path/root combinations are different. </p>
<p>Set <em>*changed_p</em> to 1 if the properties at <em>path1</em> under <em>root1</em> differ from those at <em>path2</em> under <em>root2</em>, or set it to 0 if they are the same. Both paths must exist under their respective roots, and both roots must be in the same filesystem. </p>

</div>
</div>
<a class="anchor" id="gaf6f1f42958e3f56326185b91fc1ae679"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_recover </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#addaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a>&#160;</td>
          <td class="paramname"><em>cancel_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cancel_baton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform any necessary non-catastrophic recovery on the Subversion filesystem located at <em>path</em>. </p>
<p>If <em>cancel_func</em> is not <code>NULL</code>, it is called periodically with <em>cancel_baton</em> as argument to see if the client wishes to cancel recovery. BDB filesystems do not currently support cancellation.</p>
<p>Do any necessary allocation within <em>pool</em>.</p>
<p>For FSFS filesystems, recovery is currently limited to recreating the db/current file, and does not require exclusive access.</p>
<p>For BDB filesystems, recovery requires exclusive access, and is described in detail below.</p>
<p>After an unexpected server exit, due to a server crash or a system crash, a Subversion filesystem based on Berkeley DB needs to run recovery procedures to bring the database back into a consistent state and release any locks that were held by the deceased process. The recovery procedures require exclusive access to the database &mdash; while they execute, no other process or thread may access the database.</p>
<p>In a server with multiple worker processes, like Apache, if a worker process accessing the filesystem dies, you must stop the other worker processes, and run recovery. Then, the other worker processes can re-open the database and resume work.</p>
<p>If the server exited cleanly, there is no need to run recovery, but there is no harm in it, either, and it take very little time. So it's a fine idea to run recovery when the server process starts, before it begins handling any requests.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="gaddd7ec5b6e3306c609e46d4f5a2b8a5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_revision_link </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>from_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>to_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <a class="el" href="group__fs__handling.html#ga9da8e22bd1058f877a275099699bb86b" title="Create a copy of from_path in from_root named to_path in to_root. ">svn_fs_copy()</a>, but doesn't record copy history, and preserves the PATH. </p>
<p>You cannot use <a class="el" href="group__fs__handling.html#gaed6116279287a80ec4f7de380a732f45" title="Discover a node&#39;s copy ancestry, if any. ">svn_fs_copied_from()</a> later to find out where this copy came from.</p>
<p>Use <a class="el" href="group__fs__handling.html#gaddd7ec5b6e3306c609e46d4f5a2b8a5c" title="Like svn_fs_copy(), but doesn&#39;t record copy history, and preserves the PATH. ">svn_fs_revision_link()</a> in situations where you don't care about the copy history, and where <em>to_path</em> and <em>from_path</em> are the same, because it is cheaper than <a class="el" href="group__fs__handling.html#ga9da8e22bd1058f877a275099699bb86b" title="Create a copy of from_path in from_root named to_path in to_root. ">svn_fs_copy()</a>. </p>

</div>
</div>
<a class="anchor" id="ga0cd6959ee54cd16768477d608fd33c34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_revision_prop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__string__t.html">svn_string_t</a> **&#160;</td>
          <td class="paramname"><em>value_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a>&#160;</td>
          <td class="paramname"><em>rev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>propname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>*value_p</em> to the value of the property named <em>propname</em> on revision <em>rev</em> in the filesystem <em>fs</em>. </p>
<p>If <em>rev</em> has no property by that name, set <em>*value_p</em> to zero. Allocate the result in <em>pool</em>. </p>

</div>
</div>
<a class="anchor" id="ga423da8c30eacc9787ec7bc3dd1b9e351"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_revision_proplist </td>
          <td>(</td>
          <td class="paramtype">apr_hash_t **&#160;</td>
          <td class="paramname"><em>table_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a>&#160;</td>
          <td class="paramname"><em>rev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>*table_p</em> to the entire property list of revision <em>rev</em> in filesystem <em>fs</em>, as an APR hash table allocated in <em>pool</em>. </p>
<p>The table maps <code>char *</code> property names to <a class="el" href="structsvn__string__t.html" title="A simple counted string. ">svn_string_t</a> * values; the names and values are allocated in <em>pool</em>. </p>

</div>
</div>
<a class="anchor" id="gabec2453f61fb9356db9526d4c56f3a62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_set_uuid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>uuid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If not <code>NULL</code>, associate <em>*uuid</em> with <em>fs</em>. </p>
<p>Otherwise (if <em>uuid</em> is <code>NULL</code>), generate a new UUID for <em>fs</em>. Use <em>pool</em> for any scratch work. </p>

</div>
</div>
<a class="anchor" id="gabc881c866ebe2cbd41767374264532e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_fs_set_warning_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#gafa2c790fffb1abbd103c954a5d983646">svn_fs_warning_callback_t</a>&#160;</td>
          <td class="paramname"><em>warning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>warning_baton</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide a callback function, <em>warning</em>, that <em>fs</em> should use to report (non-fatal) errors. </p>
<p>To print an error, the filesystem will call <em>warning</em>, passing it <em>warning_baton</em> and the error.</p>
<p>By default, this is set to a function that will crash the process. Dumping to <code>stderr</code> or <code>/dev/tty</code> is not acceptable default behavior for server processes, since those may both be equivalent to <code>/dev/null</code>. </p>

</div>
</div>
<a class="anchor" id="ga48972a36b2007b043bc7983be1ddd1b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_try_process_file_contents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *&#160;</td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#gaabf75bf085ab7f392eff150cec4e49a3">svn_fs_process_contents_func_t</a>&#160;</td>
          <td class="paramname"><em>processor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>baton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Efficiently deliver the contents of the file <em>path</em> in <em>root</em> via <em>processor</em> (with <em>baton</em>), setting <em>*success</em> to <code>TRUE</code> upon doing so. </p>
<p>Use <em>pool</em> for allocations.</p>
<p>This function is intended to support zero copy data processing. It may not be implemented for all data backends or not applicable for certain content. In that case, <em>*success</em> will always be <code>FALSE</code>. Also, this is a best-effort function which means that there is no guarantee that <em>processor</em> gets called at all for some content.</p>
<dl class="section note"><dt>Note</dt><dd><em>processor</em> is expected to be relatively short function with at most O(content size) runtime.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.8. </dd></dl>

</div>
</div>
<a class="anchor" id="gae771342c2800751277423c552cfeee48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_type </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>fs_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return, in <em>*fs_type</em>, a string identifying the back-end type of the Subversion filesystem located in <em>path</em>. </p>
<p>Allocate <em>*fs_type</em> in <em>pool</em>.</p>
<p>The string should be equal to one of the <code>SVN_FS_TYPE_*</code> defined constants, unless the filesystem is a new back-end type added in a later version of Subversion.</p>
<p>In general, the type should make no difference in the filesystem's semantics, but there are a few situations (such as backups) where it might matter.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.3. </dd></dl>

</div>
</div>
<a class="anchor" id="ga64cb2a37367de523f56b89e5ec603a73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_upgrade </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Upgrade the Subversion filesystem located in the directory <em>path</em> to the latest version supported by this library. </p>
<p>Return <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660a51588550b5e7e9b961b68dbe4acb128c" title="&quot;Filesystem upgrade is not supported&quot; ">SVN_ERR_FS_UNSUPPORTED_UPGRADE</a> and make no changes to the filesystem if the requested upgrade is not supported. Use <em>pool</em> for necessary allocations.</p>
<dl class="section note"><dt>Note</dt><dd>You probably don't want to use this directly. Take a look at <a class="el" href="svn__repos_8h.html#afa89fd30c6a04e09d025bcf1e30148cd" title="Similar to svn_repos_upgrade2(), but with start_callback and baton, rather than a notify_callback / b...">svn_repos_upgrade()</a> instead.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2c8730657b4f8b55ba45e1449ae4285f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_verify </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_hash_t *&#160;</td>
          <td class="paramname"><em>fs_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga0baf65b94f952b09dee2983871a691cd">svn_fs_progress_notify_func_t</a>&#160;</td>
          <td class="paramname"><em>notify_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>notify_baton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#addaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a>&#160;</td>
          <td class="paramname"><em>cancel_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cancel_baton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform backend-specific data consistency and correctness validations to the Subversion filesystem (mainly the meta-data) located in the directory <em>path</em>. </p>
<p>Use the backend-specific configuration <em>fs_config</em> when opening the filesystem. <em>NULL</em> is valid for all backends. Use <em>scratch_pool</em> for temporary allocations.</p>
<p><em>start</em> and <em>end</em> define the (minimum) range of revisions to check. If <em>start</em> is <a class="el" href="svn__types_8h.html#a8857d4630bf116eaba54a1b65d43ad92" title="The &#39;official&#39; invalid revision num. ">SVN_INVALID_REVNUM</a>, it defaults to <code>r0</code>. Likewise, <em>end</em> will default to the current youngest repository revision when given as <a class="el" href="svn__types_8h.html#a8857d4630bf116eaba54a1b65d43ad92" title="The &#39;official&#39; invalid revision num. ">SVN_INVALID_REVNUM</a>. Since meta data checks may have to touch other revisions as well, you may receive notifications for revisions outside the specified range. In fact, it is perfectly legal for a FS implementation to always check all revisions.</p>
<p>Global invariants are only guaranteed to get verified when <em>r0</em> has been included in the range of revisions to check.</p>
<p>The optional <em>notify_func</em> callback is only a general feedback that the operation is still in process but may be called in random revisions order and more than once for the same revision, i.e. r2, r1, r2 would be a valid sequence.</p>
<p>The optional <em>cancel_func</em> callback will be invoked as usual to allow the user to preempt this potentially lengthy operation.</p>
<dl class="section note"><dt>Note</dt><dd>You probably don't want to use this directly. Take a look at <a class="el" href="group__svn__repos__dump__load.html#gaa03411f59dbccf0eced1b0d0f83d2ec9" title="Verify the contents of the file system in repos. ">svn_repos_verify_fs2()</a> instead, which does non-backend-specific verifications as well.</dd>
<dd>
To ensure a full verification using all tests and covering all revisions, you must call this function <em>and</em> <a class="el" href="group__fs__handling.html#ga146a85e2774e4d69743f63a0bf5db3ae" title="Perform backend-specific data consistency and correctness validations of root in the Subversion files...">svn_fs_verify_root</a>.</dd>
<dd>
Implementors, please do tests that can be done efficiently for a single revision in <a class="el" href="group__fs__handling.html#ga146a85e2774e4d69743f63a0bf5db3ae" title="Perform backend-specific data consistency and correctness validations of root in the Subversion files...">svn_fs_verify_root</a>. This function is meant for global checks or tests that require an expensive context setup.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__svn__repos__dump__load.html#gaa03411f59dbccf0eced1b0d0f83d2ec9" title="Verify the contents of the file system in repos. ">svn_repos_verify_fs2()</a> </dd>
<dd>
<a class="el" href="group__fs__handling.html#ga146a85e2774e4d69743f63a0bf5db3ae" title="Perform backend-specific data consistency and correctness validations of root in the Subversion files...">svn_fs_verify_root()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.8. </dd></dl>

</div>
</div>
<a class="anchor" id="ga146a85e2774e4d69743f63a0bf5db3ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_verify_root </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform backend-specific data consistency and correctness validations of <em>root</em> in the Subversion filesystem <em>fs</em>. </p>
<p><em>root</em> is typically a revision root (see <a class="el" href="group__svn__fs__roots.html#gadee7737a4690e802c3ffda2318e07b8d" title="Set *root_p to the root directory of revision rev in filesystem fs. ">svn_fs_revision_root()</a>), but may be a transaction root. Use <em>scratch_pool</em> for temporary allocations.</p>
<dl class="section note"><dt>Note</dt><dd>You probably don't want to use this directly. Take a look at <a class="el" href="group__svn__repos__dump__load.html#gaa03411f59dbccf0eced1b0d0f83d2ec9" title="Verify the contents of the file system in repos. ">svn_repos_verify_fs2()</a> instead, which does non-backend-specific verifications as well.</dd>
<dd>
To ensure a full verification using all available tests and covering all revisions, you must call both this function and <a class="el" href="group__fs__handling.html#ga2c8730657b4f8b55ba45e1449ae4285f" title="Perform backend-specific data consistency and correctness validations to the Subversion filesystem (m...">svn_fs_verify</a>.</dd>
<dd>
Implementors, please perform tests that cannot be done efficiently for a single revision in <a class="el" href="group__fs__handling.html#ga2c8730657b4f8b55ba45e1449ae4285f" title="Perform backend-specific data consistency and correctness validations to the Subversion filesystem (m...">svn_fs_verify</a>. This function is intended for local checks that don't require an expensive context setup.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__svn__repos__dump__load.html#gaa03411f59dbccf0eced1b0d0f83d2ec9" title="Verify the contents of the file system in repos. ">svn_repos_verify_fs2()</a> </dd>
<dd>
<a class="el" href="group__fs__handling.html#ga2c8730657b4f8b55ba45e1449ae4285f" title="Perform backend-specific data consistency and correctness validations to the Subversion filesystem (m...">svn_fs_verify()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.8. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4af11f84095941c21fad6e22f62dd31d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_youngest_rev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> *&#160;</td>
          <td class="paramname"><em>youngest_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>*youngest_p</em> to the number of the youngest revision in filesystem <em>fs</em>. </p>
<p>Use <em>pool</em> for all temporary allocation.</p>
<p>The oldest revision in any filesystem is numbered zero. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Aug 19 2015 09:37:24 for Subversion by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
