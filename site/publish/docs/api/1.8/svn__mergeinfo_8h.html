<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Subversion: svn_mergeinfo.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Subversion
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_c37f7789c49aa9e5999234152b1ef6ed.html">subversion</a></li><li class="navelem"><a class="el" href="dir_334478eea8dba5ae935f94af9469978f.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">svn_mergeinfo.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>mergeinfo handling and processing  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;apr_pools.h&gt;</code><br/>
<code>#include &lt;apr_tables.h&gt;</code><br/>
<code>#include &lt;apr_hash.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="svn__types_8h_source.html">svn_types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="svn__string_8h_source.html">svn_string.h</a>&quot;</code><br/>
</div>
<p><a href="svn__mergeinfo_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad46a80dbdd6128bcf03ce27aa6cccf1f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#ad46a80dbdd6128bcf03ce27aa6cccf1f">SVN_MERGEINFO_NONINHERITABLE_STR</a>&#160;&#160;&#160;&quot;*&quot;</td></tr>
<tr class="memdesc:ad46a80dbdd6128bcf03ce27aa6cccf1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overview of the <code>SVN_PROP_MERGEINFO</code> property.  <a href="#ad46a80dbdd6128bcf03ce27aa6cccf1f">More...</a><br/></td></tr>
<tr class="separator:ad46a80dbdd6128bcf03ce27aa6cccf1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab8e0fcb708d6e142d54b751c377ae30e"><td class="memItemLeft" align="right" valign="top">typedef apr_array_header_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a></td></tr>
<tr class="memdesc:ab8e0fcb708d6e142d54b751c377ae30e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminology for data structures that contain mergeinfo.  <a href="#ab8e0fcb708d6e142d54b751c377ae30e">More...</a><br/></td></tr>
<tr class="separator:ab8e0fcb708d6e142d54b751c377ae30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340ffb05cc24befa2b9e7d838c8b2b0e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a340ffb05cc24befa2b9e7d838c8b2b0e"></a>
typedef apr_hash_t *&#160;</td><td class="memItemRight" valign="bottom"><b>svn_mergeinfo_t</b></td></tr>
<tr class="separator:a340ffb05cc24befa2b9e7d838c8b2b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45980e323aebefdb319fb015a9e4b5e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45980e323aebefdb319fb015a9e4b5e8"></a>
typedef apr_hash_t *&#160;</td><td class="memItemRight" valign="bottom"><b>svn_mergeinfo_catalog_t</b></td></tr>
<tr class="separator:a45980e323aebefdb319fb015a9e4b5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0519ea4415b98c27c0553a11054227de"><td class="memItemLeft" align="right" valign="top">typedef enum <br class="typebreak"/>
<a class="el" href="svn__mergeinfo_8h.html#acd81e9d0f5bcc4eec4df7b8a140f435c">svn_mergeinfo_inheritance_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#a0519ea4415b98c27c0553a11054227de">svn_mergeinfo_inheritance_t</a></td></tr>
<tr class="memdesc:a0519ea4415b98c27c0553a11054227de"><td class="mdescLeft">&#160;</td><td class="mdescRight">The three ways to request mergeinfo affecting a given path.  <a href="#a0519ea4415b98c27c0553a11054227de">More...</a><br/></td></tr>
<tr class="separator:a0519ea4415b98c27c0553a11054227de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:acd81e9d0f5bcc4eec4df7b8a140f435c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#acd81e9d0f5bcc4eec4df7b8a140f435c">svn_mergeinfo_inheritance_t</a> { <br/>
&#160;&#160;<a class="el" href="svn__mergeinfo_8h.html#acd81e9d0f5bcc4eec4df7b8a140f435ca104caea58683f50ffb88947511affe62">svn_mergeinfo_explicit</a>, 
<br/>
&#160;&#160;<a class="el" href="svn__mergeinfo_8h.html#acd81e9d0f5bcc4eec4df7b8a140f435ca8ff16f9a275e6c06dad0b2d8a5d47a73">svn_mergeinfo_inherited</a>, 
<br/>
&#160;&#160;<a class="el" href="svn__mergeinfo_8h.html#acd81e9d0f5bcc4eec4df7b8a140f435cad027e914f050dbdc7163f90a519a22a9">svn_mergeinfo_nearest_ancestor</a>
<br/>
 }</td></tr>
<tr class="memdesc:acd81e9d0f5bcc4eec4df7b8a140f435c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The three ways to request mergeinfo affecting a given path.  <a href="svn__mergeinfo_8h.html#acd81e9d0f5bcc4eec4df7b8a140f435c">More...</a><br/></td></tr>
<tr class="separator:acd81e9d0f5bcc4eec4df7b8a140f435c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a238379edb4832a622e786df5451eb047"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#a238379edb4832a622e786df5451eb047">svn_mergeinfo_parse</a> (svn_mergeinfo_t *mergeinfo, const char *input, apr_pool_t *pool)</td></tr>
<tr class="memdesc:a238379edb4832a622e786df5451eb047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the mergeinfo from <em>input</em> into <em>*mergeinfo</em>.  <a href="#a238379edb4832a622e786df5451eb047">More...</a><br/></td></tr>
<tr class="separator:a238379edb4832a622e786df5451eb047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12952c2a647ad2e4e235e51fe8b184b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#a12952c2a647ad2e4e235e51fe8b184b4">svn_mergeinfo_diff2</a> (svn_mergeinfo_t *deleted, svn_mergeinfo_t *added, svn_mergeinfo_t mergefrom, svn_mergeinfo_t mergeto, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> consider_inheritance, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:a12952c2a647ad2e4e235e51fe8b184b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the delta between two mergeinfos, <em>mergefrom</em> and <em>mergeto</em> (either or both of which may be <code>NULL</code> meaning an empty mergeinfo).  <a href="#a12952c2a647ad2e4e235e51fe8b184b4">More...</a><br/></td></tr>
<tr class="separator:a12952c2a647ad2e4e235e51fe8b184b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99924a6f5f1ffa833fd3ab72e8661778"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#a99924a6f5f1ffa833fd3ab72e8661778">svn_mergeinfo_diff</a> (svn_mergeinfo_t *deleted, svn_mergeinfo_t *added, svn_mergeinfo_t mergefrom, svn_mergeinfo_t mergeto, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> consider_inheritance, apr_pool_t *pool)</td></tr>
<tr class="memdesc:a99924a6f5f1ffa833fd3ab72e8661778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="svn__mergeinfo_8h.html#a12952c2a647ad2e4e235e51fe8b184b4" title="Calculate the delta between two mergeinfos, mergefrom and mergeto (either or both of which may be NUL...">svn_mergeinfo_diff2()</a>, but users only one pool.  <a href="#a99924a6f5f1ffa833fd3ab72e8661778">More...</a><br/></td></tr>
<tr class="separator:a99924a6f5f1ffa833fd3ab72e8661778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e79672e601900f0c12812ed2608fbc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#a4e79672e601900f0c12812ed2608fbc9">svn_mergeinfo_merge2</a> (svn_mergeinfo_t mergeinfo, svn_mergeinfo_t changes, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:a4e79672e601900f0c12812ed2608fbc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge a shallow copy of one mergeinfo, <em>changes</em>, into another mergeinfo <em>mergeinfo</em>.  <a href="#a4e79672e601900f0c12812ed2608fbc9">More...</a><br/></td></tr>
<tr class="separator:a4e79672e601900f0c12812ed2608fbc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bab0a2e1d9cd707dd752644144b13bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#a0bab0a2e1d9cd707dd752644144b13bc">svn_mergeinfo_merge</a> (svn_mergeinfo_t mergeinfo, svn_mergeinfo_t changes, apr_pool_t *pool)</td></tr>
<tr class="memdesc:a0bab0a2e1d9cd707dd752644144b13bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like svn_mergeinfo_merge2, but uses only one pool.  <a href="#a0bab0a2e1d9cd707dd752644144b13bc">More...</a><br/></td></tr>
<tr class="separator:a0bab0a2e1d9cd707dd752644144b13bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca8987194d80d57773c0014863d734b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#a3ca8987194d80d57773c0014863d734b">svn_mergeinfo_catalog_merge</a> (svn_mergeinfo_catalog_t mergeinfo_catalog, svn_mergeinfo_catalog_t changes_catalog, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:a3ca8987194d80d57773c0014863d734b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine one mergeinfo catalog, <em>changes_catalog</em>, into another mergeinfo catalog <em>mergeinfo_catalog</em>.  <a href="#a3ca8987194d80d57773c0014863d734b">More...</a><br/></td></tr>
<tr class="separator:a3ca8987194d80d57773c0014863d734b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5293e26d8af012fb839ca96ee6cbfc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#af5293e26d8af012fb839ca96ee6cbfc8">svn_mergeinfo_remove</a> (svn_mergeinfo_t *mergeinfo, svn_mergeinfo_t eraser, svn_mergeinfo_t whiteboard, apr_pool_t *pool)</td></tr>
<tr class="memdesc:af5293e26d8af012fb839ca96ee6cbfc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like svn_mergeinfo_remove2, but always considers inheritance.  <a href="#af5293e26d8af012fb839ca96ee6cbfc8">More...</a><br/></td></tr>
<tr class="separator:af5293e26d8af012fb839ca96ee6cbfc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2e8565251b0506deaf4fe69e622072"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#afe2e8565251b0506deaf4fe69e622072">svn_mergeinfo_remove2</a> (svn_mergeinfo_t *mergeinfo, svn_mergeinfo_t eraser, svn_mergeinfo_t whiteboard, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> consider_inheritance, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:afe2e8565251b0506deaf4fe69e622072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes <em>eraser</em> (the subtrahend) from <em>whiteboard</em> (the minuend), and places the resulting difference in <em>*mergeinfo</em>.  <a href="#afe2e8565251b0506deaf4fe69e622072">More...</a><br/></td></tr>
<tr class="separator:afe2e8565251b0506deaf4fe69e622072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7982476b74d520bbc57f27379a5cca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#abd7982476b74d520bbc57f27379a5cca">svn_rangelist_diff</a> (<a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> **deleted, <a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> **added, const <a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> *from, const <a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> *to, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> consider_inheritance, apr_pool_t *pool)</td></tr>
<tr class="memdesc:abd7982476b74d520bbc57f27379a5cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the delta between two rangelists consisting of <code><a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions. ">svn_merge_range_t</a></code> * elements (sorted in ascending order), <em>from</em> and <em>to</em>, and place the result in <em>*deleted</em> and <em>*added</em> (neither output argument will ever be <code>NULL</code>).  <a href="#abd7982476b74d520bbc57f27379a5cca">More...</a><br/></td></tr>
<tr class="separator:abd7982476b74d520bbc57f27379a5cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad49d1cdcee6cf77d2c724e3bc8d1db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#a4ad49d1cdcee6cf77d2c724e3bc8d1db">svn_rangelist_merge2</a> (<a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> *rangelist, const <a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> *changes, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:a4ad49d1cdcee6cf77d2c724e3bc8d1db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge two rangelists consisting of <code><a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions. ">svn_merge_range_t</a></code> * elements, <em>rangelist</em> and <em>changes</em>, placing the results in <em>rangelist</em>.  <a href="#a4ad49d1cdcee6cf77d2c724e3bc8d1db">More...</a><br/></td></tr>
<tr class="separator:a4ad49d1cdcee6cf77d2c724e3bc8d1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbcd0926060c1a20d05f5747f7c86017"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#abbcd0926060c1a20d05f5747f7c86017">svn_rangelist_merge</a> (<a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> **rangelist, const <a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> *changes, apr_pool_t *pool)</td></tr>
<tr class="memdesc:abbcd0926060c1a20d05f5747f7c86017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="svn__mergeinfo_8h.html#a4ad49d1cdcee6cf77d2c724e3bc8d1db" title="Merge two rangelists consisting of svn_merge_range_t * elements, rangelist and changes, placing the results in rangelist. ">svn_rangelist_merge2()</a>, but with <em>rangelist</em> as an input/output argument.  <a href="#abbcd0926060c1a20d05f5747f7c86017">More...</a><br/></td></tr>
<tr class="separator:abbcd0926060c1a20d05f5747f7c86017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c123e29a0a04289ac59cc69a75b29c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#a7c123e29a0a04289ac59cc69a75b29c9">svn_rangelist_remove</a> (<a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> **output, const <a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> *eraser, const <a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> *whiteboard, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> consider_inheritance, apr_pool_t *pool)</td></tr>
<tr class="memdesc:a7c123e29a0a04289ac59cc69a75b29c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes <em>eraser</em> (the subtrahend) from <em>whiteboard</em> (the minuend), and places the resulting difference in <em>output</em>.  <a href="#a7c123e29a0a04289ac59cc69a75b29c9">More...</a><br/></td></tr>
<tr class="separator:a7c123e29a0a04289ac59cc69a75b29c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c5c6a53ea94792a9575d1d36b819a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#ab9c5c6a53ea94792a9575d1d36b819a3">svn_mergeinfo_intersect2</a> (svn_mergeinfo_t *mergeinfo, svn_mergeinfo_t mergeinfo1, svn_mergeinfo_t mergeinfo2, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> consider_inheritance, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:ab9c5c6a53ea94792a9575d1d36b819a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the intersection of two mergeinfos, <em>mergeinfo1</em> and <em>mergeinfo2</em>, and place the result in <em>*mergeinfo</em>, which is (deeply) allocated in <em>result_pool</em>.  <a href="#ab9c5c6a53ea94792a9575d1d36b819a3">More...</a><br/></td></tr>
<tr class="separator:ab9c5c6a53ea94792a9575d1d36b819a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1287fa5e9e5a902ebd8ea30cac1ec5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#afc1287fa5e9e5a902ebd8ea30cac1ec5">svn_mergeinfo_intersect</a> (svn_mergeinfo_t *mergeinfo, svn_mergeinfo_t mergeinfo1, svn_mergeinfo_t mergeinfo2, apr_pool_t *pool)</td></tr>
<tr class="memdesc:afc1287fa5e9e5a902ebd8ea30cac1ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like svn_mergeinfo_intersect2, but always considers inheritance.  <a href="#afc1287fa5e9e5a902ebd8ea30cac1ec5">More...</a><br/></td></tr>
<tr class="separator:afc1287fa5e9e5a902ebd8ea30cac1ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136e89015e53e33cdccb339750fc6c7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#a136e89015e53e33cdccb339750fc6c7d">svn_rangelist_intersect</a> (<a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> **rangelist, const <a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> *rangelist1, const <a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> *rangelist2, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> consider_inheritance, apr_pool_t *pool)</td></tr>
<tr class="memdesc:a136e89015e53e33cdccb339750fc6c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the intersection of two rangelists consisting of <code><a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions. ">svn_merge_range_t</a></code> * elements, <em>rangelist1</em> and <em>rangelist2</em>, and place the result in <em>*rangelist</em> (which is never <code>NULL</code>).  <a href="#a136e89015e53e33cdccb339750fc6c7d">More...</a><br/></td></tr>
<tr class="separator:a136e89015e53e33cdccb339750fc6c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a969feab45958f8fdcfacfb960945e151"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#a969feab45958f8fdcfacfb960945e151">svn_rangelist_reverse</a> (<a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> *rangelist, apr_pool_t *pool)</td></tr>
<tr class="memdesc:a969feab45958f8fdcfacfb960945e151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse <em>rangelist</em>, and the <code>start</code> and <code>end</code> fields of each range in <em>rangelist</em>, in place.  <a href="#a969feab45958f8fdcfacfb960945e151">More...</a><br/></td></tr>
<tr class="separator:a969feab45958f8fdcfacfb960945e151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef49dea3dda0dada94e003ede4d6c2d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#aef49dea3dda0dada94e003ede4d6c2d2">svn_rangelist_to_string</a> (<a class="el" href="structsvn__string__t.html">svn_string_t</a> **output, const <a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> *rangelist, apr_pool_t *pool)</td></tr>
<tr class="memdesc:aef49dea3dda0dada94e003ede4d6c2d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take an array of <a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions. ">svn_merge_range_t</a> *'s in <em>rangelist</em>, and convert it back to a text format rangelist in <em>output</em>.  <a href="#aef49dea3dda0dada94e003ede4d6c2d2">More...</a><br/></td></tr>
<tr class="separator:aef49dea3dda0dada94e003ede4d6c2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1041c38c9fa793c39e88d1e40e2c90cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#a1041c38c9fa793c39e88d1e40e2c90cb">svn_rangelist_inheritable2</a> (<a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> **inheritable_rangelist, const <a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> *rangelist, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> start, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> end, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> inheritable, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:a1041c38c9fa793c39e88d1e40e2c90cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a deep copy of <code><a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions. ">svn_merge_range_t</a></code> *'s in <em>rangelist</em> excluding all non-inheritable <code><a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions. ">svn_merge_range_t</a></code> if <em>inheritable</em> is TRUE or excluding all inheritable <code><a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions. ">svn_merge_range_t</a></code> otherwise.  <a href="#a1041c38c9fa793c39e88d1e40e2c90cb">More...</a><br/></td></tr>
<tr class="separator:a1041c38c9fa793c39e88d1e40e2c90cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7baad11b2af45a50dd9be617d714aa28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#a7baad11b2af45a50dd9be617d714aa28">svn_rangelist_inheritable</a> (<a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> **inheritable_rangelist, const <a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> *rangelist, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> start, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> end, apr_pool_t *pool)</td></tr>
<tr class="memdesc:a7baad11b2af45a50dd9be617d714aa28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like svn_rangelist_inheritable2, but always finds inheritable ranges.  <a href="#a7baad11b2af45a50dd9be617d714aa28">More...</a><br/></td></tr>
<tr class="separator:a7baad11b2af45a50dd9be617d714aa28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba301bd63dd00dbfe45f614b09abff8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#a4ba301bd63dd00dbfe45f614b09abff8">svn_mergeinfo_inheritable2</a> (svn_mergeinfo_t *inheritable_mergeinfo, svn_mergeinfo_t mergeinfo, const char *path, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> start, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> end, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> inheritable, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:a4ba301bd63dd00dbfe45f614b09abff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a deep copy of <em>mergeinfo</em>, excluding all non-inheritable <code><a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions. ">svn_merge_range_t</a></code> if <em>inheritable</em> is TRUE or excluding all inheritable <code><a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions. ">svn_merge_range_t</a></code> otherwise.  <a href="#a4ba301bd63dd00dbfe45f614b09abff8">More...</a><br/></td></tr>
<tr class="separator:a4ba301bd63dd00dbfe45f614b09abff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe89ba236af678f4c2a1562e34d937f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#afe89ba236af678f4c2a1562e34d937f6">svn_mergeinfo_inheritable</a> (svn_mergeinfo_t *inheritable_mergeinfo, svn_mergeinfo_t mergeinfo, const char *path, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> start, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> end, apr_pool_t *pool)</td></tr>
<tr class="memdesc:afe89ba236af678f4c2a1562e34d937f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like svn_mergeinfo_inheritable2, but always finds inheritable mergeinfo.  <a href="#afe89ba236af678f4c2a1562e34d937f6">More...</a><br/></td></tr>
<tr class="separator:afe89ba236af678f4c2a1562e34d937f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be44bfd77bb7b3b4bbcc516e82655ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#a4be44bfd77bb7b3b4bbcc516e82655ac">svn_mergeinfo_to_string</a> (<a class="el" href="structsvn__string__t.html">svn_string_t</a> **output, svn_mergeinfo_t mergeinput, apr_pool_t *pool)</td></tr>
<tr class="memdesc:a4be44bfd77bb7b3b4bbcc516e82655ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a mergeinfo in <em>mergeinput</em>, and convert it to unparsed mergeinfo.  <a href="#a4be44bfd77bb7b3b4bbcc516e82655ac">More...</a><br/></td></tr>
<tr class="separator:a4be44bfd77bb7b3b4bbcc516e82655ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e1605436e43a23f5055649f4a831f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#aa3e1605436e43a23f5055649f4a831f4">svn_mergeinfo_sort</a> (svn_mergeinfo_t mergeinfo, apr_pool_t *pool)</td></tr>
<tr class="memdesc:aa3e1605436e43a23f5055649f4a831f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a hash of mergeinfo in <em>mergeinfo</em>, and sort the rangelists associated with each key (in place).  <a href="#aa3e1605436e43a23f5055649f4a831f4">More...</a><br/></td></tr>
<tr class="separator:aa3e1605436e43a23f5055649f4a831f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf96ca398215933518d77cbb6aacab83"><td class="memItemLeft" align="right" valign="top">svn_mergeinfo_catalog_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#abf96ca398215933518d77cbb6aacab83">svn_mergeinfo_catalog_dup</a> (svn_mergeinfo_catalog_t mergeinfo_catalog, apr_pool_t *pool)</td></tr>
<tr class="memdesc:abf96ca398215933518d77cbb6aacab83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a deep copy of <em>mergeinfo_catalog</em>, allocated in <em>pool</em>.  <a href="#abf96ca398215933518d77cbb6aacab83">More...</a><br/></td></tr>
<tr class="separator:abf96ca398215933518d77cbb6aacab83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c3bd21f6e96a0d1d29a18ce0769842"><td class="memItemLeft" align="right" valign="top">svn_mergeinfo_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#a97c3bd21f6e96a0d1d29a18ce0769842">svn_mergeinfo_dup</a> (svn_mergeinfo_t mergeinfo, apr_pool_t *pool)</td></tr>
<tr class="memdesc:a97c3bd21f6e96a0d1d29a18ce0769842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a deep copy of <em>mergeinfo</em>, allocated in <em>pool</em>.  <a href="#a97c3bd21f6e96a0d1d29a18ce0769842">More...</a><br/></td></tr>
<tr class="separator:a97c3bd21f6e96a0d1d29a18ce0769842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f1189668b2a2fa61affe4471c0192f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#a69f1189668b2a2fa61affe4471c0192f">svn_rangelist_dup</a> (const <a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> *rangelist, apr_pool_t *pool)</td></tr>
<tr class="memdesc:a69f1189668b2a2fa61affe4471c0192f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a deep copy of <em>rangelist</em>, allocated in <em>pool</em>.  <a href="#a69f1189668b2a2fa61affe4471c0192f">More...</a><br/></td></tr>
<tr class="separator:a69f1189668b2a2fa61affe4471c0192f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4060ce759919b37939a9d231e7922f55"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#a4060ce759919b37939a9d231e7922f55">svn_inheritance_to_word</a> (<a class="el" href="svn__mergeinfo_8h.html#acd81e9d0f5bcc4eec4df7b8a140f435c">svn_mergeinfo_inheritance_t</a> inherit)</td></tr>
<tr class="memdesc:a4060ce759919b37939a9d231e7922f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a constant string expressing <em>inherit</em> as an English word, i.e., "explicit" (default), "inherited", or "nearest_ancestor".  <a href="#a4060ce759919b37939a9d231e7922f55">More...</a><br/></td></tr>
<tr class="separator:a4060ce759919b37939a9d231e7922f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd9e433323caa7bd14d34c0d2a07afe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="svn__mergeinfo_8h.html#acd81e9d0f5bcc4eec4df7b8a140f435c">svn_mergeinfo_inheritance_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#a7cd9e433323caa7bd14d34c0d2a07afe">svn_inheritance_from_word</a> (const char *word)</td></tr>
<tr class="memdesc:a7cd9e433323caa7bd14d34c0d2a07afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the appropriate <code>svn_mergeinfo_inheritance_t</code> for <em>word</em>.  <a href="#a7cd9e433323caa7bd14d34c0d2a07afe">More...</a><br/></td></tr>
<tr class="separator:a7cd9e433323caa7bd14d34c0d2a07afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>mergeinfo handling and processing </p>

<p>Definition in file <a class="el" href="svn__mergeinfo_8h_source.html">svn_mergeinfo.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ad46a80dbdd6128bcf03ce27aa6cccf1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SVN_MERGEINFO_NONINHERITABLE_STR&#160;&#160;&#160;&quot;*&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overview of the <code>SVN_PROP_MERGEINFO</code> property. </p>
<p>Merge history is stored in the <code>SVN_PROP_MERGEINFO</code> property of files and directories. The <code>SVN_PROP_MERGEINFO</code> property on a path stores the complete list of changes merged to that path, either directly or via the path's parent, grand-parent, etc.. A path may have empty mergeinfo which means that nothing has been merged to that path or all previous merges to the path were reversed. Note that a path may have no mergeinfo, this is not the same as empty mergeinfo.</p>
<p>Every path in a tree may have <code>SVN_PROP_MERGEINFO</code> set, but if the <code>SVN_PROP_MERGEINFO</code> for a path is equivalent to the <code>SVN_PROP_MERGEINFO</code> for its parent, then the <code>SVN_PROP_MERGEINFO</code> on the path will 'elide' (be removed) from the path as a post step to any merge. If a path's parent does not have any <code>SVN_PROP_MERGEINFO</code> set, the path's mergeinfo can elide to its nearest grand-parent, great-grand-parent, etc. that has equivalent <code>SVN_PROP_MERGEINFO</code> set on it.</p>
<p>If a path has no <code>SVN_PROP_MERGEINFO</code> of its own, it inherits mergeinfo from its nearest parent that has <code>SVN_PROP_MERGEINFO</code> set. The exception to this is <code>SVN_PROP_MERGEINFO</code> with non-inheritable revision ranges. These non-inheritable ranges apply only to the path which they are set on.</p>
<p>Due to Subversion's allowance for mixed revision working copies, both elision and inheritance within the working copy presume the path between a path and its nearest parent with mergeinfo is at the same working revision. If this is not the case then neither inheritance nor elision can occur.</p>
<p>The value of the <code>SVN_PROP_MERGEINFO</code> property is either an empty string (representing empty mergeinfo) or a non-empty string consisting of a path, a colon, and comma separated revision list, containing one or more revision or revision ranges. Revision range start and end points are separated by "-". Revisions and revision ranges may have the optional <code>SVN_MERGEINFO_NONINHERITABLE_STR</code> suffix to signify a non-inheritable revision/revision range.</p>
<p><code>SVN_PROP_MERGEINFO</code> Value Grammar:</p>
<p>Token Definition </p>
<hr/>
<p> revisionrange REVISION1 "-" REVISION2 revisioneelement (revisionrange | REVISION)"*"? rangelist revisioneelement (COMMA revisioneelement)* revisionline PATHNAME COLON rangelist top "" | (revisionline (NEWLINE revisionline))*</p>
<p>The PATHNAME is the source of a merge and the rangelist the revision(s) merged to the path <code>SVN_PROP_MERGEINFO</code> is set on directly or indirectly via inheritance. PATHNAME must always exist at the specified rangelist and thus a single merge may result in multiple revisionlines if the source was renamed.</p>
<p>Rangelists must be sorted from lowest to highest revision and cannot contain overlapping revisionlistelements. REVISION1 must be less than REVISION2. Consecutive single revisions that can be represented by a revisionrange are allowed however (e.g. '5,6,7,8,9-12' or '5-12' are both acceptable). </p>

<p>Definition at line <a class="el" href="svn__mergeinfo_8h_source.html#l00107">107</a> of file <a class="el" href="svn__mergeinfo_8h_source.html">svn_mergeinfo.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a0519ea4415b98c27c0553a11054227de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="svn__mergeinfo_8h.html#acd81e9d0f5bcc4eec4df7b8a140f435c">svn_mergeinfo_inheritance_t</a>  <a class="el" href="svn__mergeinfo_8h.html#acd81e9d0f5bcc4eec4df7b8a140f435c">svn_mergeinfo_inheritance_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The three ways to request mergeinfo affecting a given path. </p>
<dl class="section since"><dt>Since</dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="ab8e0fcb708d6e142d54b751c377ae30e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef apr_array_header_t <a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Terminology for data structures that contain mergeinfo. </p>
<p>Subversion commonly uses several data structures to represent mergeinfo in RAM:</p>
<p>(a) Strings (<code><a class="el" href="structsvn__string__t.html" title="A simple counted string. ">svn_string_t</a></code> *) containing "unparsed mergeinfo".</p>
<p>(b) <code>svn_rangelist_t</code>, called a "rangelist". An array of non- overlapping merge ranges (<code><a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions. ">svn_merge_range_t</a></code> *), sorted as said by <code><a class="el" href="svn__sorts_8h.html#a58a32c4f0a5c14672865be8768b1113a" title="Compare two svn_merge_range_t *&#39;s, *a and *b, returning an integer greater than, equal to...">svn_sort_compare_ranges()</a></code>. An empty range list is represented by an empty array. Unless specifically noted otherwise, all APIs require rangelists that describe only forward ranges, i.e. the range's start revision is less than its end revision.</p>
<p>(c) <code>svn_mergeinfo_t</code>, called "mergeinfo". A hash mapping merge source paths (<code>const</code> char *, starting with slashes) to non-empty rangelist arrays. A <code>NULL</code> hash is used to represent no mergeinfo and an empty hash is used to represent empty mergeinfo.</p>
<p>(d) <code>svn_mergeinfo_catalog_t</code>, called a "mergeinfo catalog". A hash mapping paths (<code>const</code> char *) to <code>svn_mergeinfo_t</code>.</p>
<p>Both <code>svn_mergeinfo_t</code> and <code>svn_mergeinfo_catalog_t</code> are just typedefs for <code>apr_hash_t</code> *; there is no static type-checking, and you still use standard <code>apr_hash_t</code> functions to interact with them.</p>
<p>Note that while the keys of mergeinfos are always absolute from the repository root, the keys of a catalog may be relative to something else, such as an RA session root. </p>

<p>Definition at line <a class="el" href="svn__mergeinfo_8h_source.html#l00142">142</a> of file <a class="el" href="svn__mergeinfo_8h_source.html">svn_mergeinfo.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="acd81e9d0f5bcc4eec4df7b8a140f435c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="svn__mergeinfo_8h.html#acd81e9d0f5bcc4eec4df7b8a140f435c">svn_mergeinfo_inheritance_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The three ways to request mergeinfo affecting a given path. </p>
<dl class="section since"><dt>Since</dt><dd>New in 1.5. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="acd81e9d0f5bcc4eec4df7b8a140f435ca104caea58683f50ffb88947511affe62"></a>svn_mergeinfo_explicit</em>&nbsp;</td><td class="fielddoc">
<p>Explicit mergeinfo only. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="acd81e9d0f5bcc4eec4df7b8a140f435ca8ff16f9a275e6c06dad0b2d8a5d47a73"></a>svn_mergeinfo_inherited</em>&nbsp;</td><td class="fielddoc">
<p>Explicit mergeinfo, or if that doesn't exist, the inherited mergeinfo from a target's nearest (path-wise, not history-wise) ancestor. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="acd81e9d0f5bcc4eec4df7b8a140f435cad027e914f050dbdc7163f90a519a22a9"></a>svn_mergeinfo_nearest_ancestor</em>&nbsp;</td><td class="fielddoc">
<p>Mergeinfo inherited from a target's nearest (path-wise, not history-wise) ancestor, regardless of whether target has explicit mergeinfo. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="svn__mergeinfo_8h_source.html#l00571">571</a> of file <a class="el" href="svn__mergeinfo_8h_source.html">svn_mergeinfo.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a7cd9e433323caa7bd14d34c0d2a07afe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__mergeinfo_8h.html#acd81e9d0f5bcc4eec4df7b8a140f435c">svn_mergeinfo_inheritance_t</a> svn_inheritance_from_word </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>word</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the appropriate <code>svn_mergeinfo_inheritance_t</code> for <em>word</em>. </p>
<p><em>word</em> is as returned from <a class="el" href="svn__mergeinfo_8h.html#a4060ce759919b37939a9d231e7922f55" title="Return a constant string expressing inherit as an English word, i.e., &quot;explicit&quot; (default), &quot;inherited&quot;, or &quot;nearest_ancestor&quot;. ">svn_inheritance_to_word()</a>. Defaults to <code>svn_mergeinfo_explicit</code>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="a4060ce759919b37939a9d231e7922f55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* svn_inheritance_to_word </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#acd81e9d0f5bcc4eec4df7b8a140f435c">svn_mergeinfo_inheritance_t</a>&#160;</td>
          <td class="paramname"><em>inherit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a constant string expressing <em>inherit</em> as an English word, i.e., "explicit" (default), "inherited", or "nearest_ancestor". </p>
<p>The string is not localized, as it may be used for client&lt;-&gt;server communications.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="abf96ca398215933518d77cbb6aacab83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">svn_mergeinfo_catalog_t svn_mergeinfo_catalog_dup </td>
          <td>(</td>
          <td class="paramtype">svn_mergeinfo_catalog_t&#160;</td>
          <td class="paramname"><em>mergeinfo_catalog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a deep copy of <em>mergeinfo_catalog</em>, allocated in <em>pool</em>. </p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ca8987194d80d57773c0014863d734b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_mergeinfo_catalog_merge </td>
          <td>(</td>
          <td class="paramtype">svn_mergeinfo_catalog_t&#160;</td>
          <td class="paramname"><em>mergeinfo_catalog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">svn_mergeinfo_catalog_t&#160;</td>
          <td class="paramname"><em>changes_catalog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combine one mergeinfo catalog, <em>changes_catalog</em>, into another mergeinfo catalog <em>mergeinfo_catalog</em>. </p>
<p>If both catalogs have mergeinfo for the same key, use <a class="el" href="svn__mergeinfo_8h.html#a0bab0a2e1d9cd707dd752644144b13bc" title="Like svn_mergeinfo_merge2, but uses only one pool. ">svn_mergeinfo_merge()</a> to combine the mergeinfos.</p>
<p>Additions to <em>mergeinfo_catalog</em> are deep copies allocated in <em>result_pool</em>. Temporary allocations are made in <em>scratch_pool</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="a99924a6f5f1ffa833fd3ab72e8661778"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_mergeinfo_diff </td>
          <td>(</td>
          <td class="paramtype">svn_mergeinfo_t *&#160;</td>
          <td class="paramname"><em>deleted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">svn_mergeinfo_t *&#160;</td>
          <td class="paramname"><em>added</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">svn_mergeinfo_t&#160;</td>
          <td class="paramname"><em>mergefrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">svn_mergeinfo_t&#160;</td>
          <td class="paramname"><em>mergeto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>consider_inheritance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="svn__mergeinfo_8h.html#a12952c2a647ad2e4e235e51fe8b184b4" title="Calculate the delta between two mergeinfos, mergefrom and mergeto (either or both of which may be NUL...">svn_mergeinfo_diff2()</a>, but users only one pool. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000240">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.7 API. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="a12952c2a647ad2e4e235e51fe8b184b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_mergeinfo_diff2 </td>
          <td>(</td>
          <td class="paramtype">svn_mergeinfo_t *&#160;</td>
          <td class="paramname"><em>deleted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">svn_mergeinfo_t *&#160;</td>
          <td class="paramname"><em>added</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">svn_mergeinfo_t&#160;</td>
          <td class="paramname"><em>mergefrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">svn_mergeinfo_t&#160;</td>
          <td class="paramname"><em>mergeto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>consider_inheritance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the delta between two mergeinfos, <em>mergefrom</em> and <em>mergeto</em> (either or both of which may be <code>NULL</code> meaning an empty mergeinfo). </p>
<p>Place the result in <em>*deleted</em> and <em>*added</em> (neither output argument may be <code>NULL</code>), both allocated in <em>result_pool</em>. The resulting <em>*deleted</em> and <em>*added</em> will not be null.</p>
<p><em>consider_inheritance</em> determines how the rangelists in the two hashes are compared for equality. If <em>consider_inheritance</em> is FALSE, then the start and end revisions of the <code><a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions. ">svn_merge_range_t</a>'s</code> being compared are the only factors considered when determining equality.</p>
<p>e.g. '/trunk: 1,3-4*,5' == '/trunk: 1,3-5'</p>
<p>If <em>consider_inheritance</em> is TRUE, then the inheritability of the <code><a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions. ">svn_merge_range_t</a>'s</code> is also considered and must be the same for two otherwise identical ranges to be judged equal.</p>
<p>e.g. '/trunk: 1,3-4*,5' != '/trunk: 1,3-5' '/trunk: 1,3-4*,5' == '/trunk: 1,3-4*,5' '/trunk: 1,3-4,5' == '/trunk: 1,3-4,5'</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.8. </dd></dl>

</div>
</div>
<a class="anchor" id="a97c3bd21f6e96a0d1d29a18ce0769842"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">svn_mergeinfo_t svn_mergeinfo_dup </td>
          <td>(</td>
          <td class="paramtype">svn_mergeinfo_t&#160;</td>
          <td class="paramname"><em>mergeinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a deep copy of <em>mergeinfo</em>, allocated in <em>pool</em>. </p>
<dl class="section since"><dt>Since</dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="afe89ba236af678f4c2a1562e34d937f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_mergeinfo_inheritable </td>
          <td>(</td>
          <td class="paramtype">svn_mergeinfo_t *&#160;</td>
          <td class="paramname"><em>inheritable_mergeinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">svn_mergeinfo_t&#160;</td>
          <td class="paramname"><em>mergeinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like svn_mergeinfo_inheritable2, but always finds inheritable mergeinfo. </p>
<dl class="section since"><dt>Since</dt><dd>New in 1.5. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000246">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.6 API. </dd></dl>

</div>
</div>
<a class="anchor" id="a4ba301bd63dd00dbfe45f614b09abff8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_mergeinfo_inheritable2 </td>
          <td>(</td>
          <td class="paramtype">svn_mergeinfo_t *&#160;</td>
          <td class="paramname"><em>inheritable_mergeinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">svn_mergeinfo_t&#160;</td>
          <td class="paramname"><em>mergeinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>inheritable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a deep copy of <em>mergeinfo</em>, excluding all non-inheritable <code><a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions. ">svn_merge_range_t</a></code> if <em>inheritable</em> is TRUE or excluding all inheritable <code><a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions. ">svn_merge_range_t</a></code> otherwise. </p>
<p>If <em>start</em> and <em>end</em> are valid revisions and <em>start</em> is less than or equal to <em>end</em>, then exclude only the non-inheritable revisions that intersect inclusively with the range defined by <em>start</em> and <em>end</em>. If <em>path</em> is not NULL remove non-inheritable ranges only for <em>path</em>. If all ranges are removed for a given path then remove that path as well. If all paths are removed or <em>rangelist</em> is empty then set <em>*inheritable_rangelist</em> to an empty array. Allocate the copy in <em>result_pool</em>, use <em>scratch_pool</em> for temporary allocations.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="afc1287fa5e9e5a902ebd8ea30cac1ec5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_mergeinfo_intersect </td>
          <td>(</td>
          <td class="paramtype">svn_mergeinfo_t *&#160;</td>
          <td class="paramname"><em>mergeinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">svn_mergeinfo_t&#160;</td>
          <td class="paramname"><em>mergeinfo1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">svn_mergeinfo_t&#160;</td>
          <td class="paramname"><em>mergeinfo2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like svn_mergeinfo_intersect2, but always considers inheritance. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000244">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.6 API. </dd></dl>

</div>
</div>
<a class="anchor" id="ab9c5c6a53ea94792a9575d1d36b819a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_mergeinfo_intersect2 </td>
          <td>(</td>
          <td class="paramtype">svn_mergeinfo_t *&#160;</td>
          <td class="paramname"><em>mergeinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">svn_mergeinfo_t&#160;</td>
          <td class="paramname"><em>mergeinfo1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">svn_mergeinfo_t&#160;</td>
          <td class="paramname"><em>mergeinfo2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>consider_inheritance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the intersection of two mergeinfos, <em>mergeinfo1</em> and <em>mergeinfo2</em>, and place the result in <em>*mergeinfo</em>, which is (deeply) allocated in <em>result_pool</em>. </p>
<p>Temporary allocations will be performed in <em>scratch_pool</em>.</p>
<p><em>consider_inheritance</em> determines how to account for the inheritability of the two mergeinfo's ranges when calculating the range equivalence, </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="svn__mergeinfo_8h.html#a136e89015e53e33cdccb339750fc6c7d" title="Find the intersection of two rangelists consisting of svn_merge_range_t * elements, rangelist1 and rangelist2, and place the result in *rangelist (which is never NULL). ">svn_rangelist_intersect()</a>.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="a0bab0a2e1d9cd707dd752644144b13bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_mergeinfo_merge </td>
          <td>(</td>
          <td class="paramtype">svn_mergeinfo_t&#160;</td>
          <td class="paramname"><em>mergeinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">svn_mergeinfo_t&#160;</td>
          <td class="paramname"><em>changes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like svn_mergeinfo_merge2, but uses only one pool. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000241">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.5 API. </dd></dl>

</div>
</div>
<a class="anchor" id="a4e79672e601900f0c12812ed2608fbc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_mergeinfo_merge2 </td>
          <td>(</td>
          <td class="paramtype">svn_mergeinfo_t&#160;</td>
          <td class="paramname"><em>mergeinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">svn_mergeinfo_t&#160;</td>
          <td class="paramname"><em>changes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge a shallow copy of one mergeinfo, <em>changes</em>, into another mergeinfo <em>mergeinfo</em>. </p>
<p>Rangelists for merge source paths common to <em>changes</em> and <em>mergeinfo</em> may result in new rangelists; these are allocated in <em>result_pool</em>. Temporary allocations are made in <em>scratch_pool</em>.</p>
<p>When intersecting rangelists for a path are merged, the inheritability of the resulting <a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions. ">svn_merge_range_t</a> depends on the inheritability of the operands. If two non-inheritable ranges are merged the result is always non-inheritable, in all other cases the resulting range is inheritable.</p>
<p>e.g. '/A: 1,3-4' merged with '/A: 1,3,4*,5' &ndash;&gt; '/A: 1,3-5' '/A: 1,3-4*' merged with '/A: 1,3,4*,5' &ndash;&gt; '/A: 1,3,4*,5'</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.8. </dd></dl>

</div>
</div>
<a class="anchor" id="a238379edb4832a622e786df5451eb047"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_mergeinfo_parse </td>
          <td>(</td>
          <td class="paramtype">svn_mergeinfo_t *&#160;</td>
          <td class="paramname"><em>mergeinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the mergeinfo from <em>input</em> into <em>*mergeinfo</em>. </p>
<p>If no mergeinfo is available, return an empty mergeinfo (never <code>NULL</code>). Perform temporary allocations in <em>pool</em>.</p>
<p>If <em>input</em> is not a grammatically correct <code>SVN_PROP_MERGEINFO</code> property, contains overlapping revision ranges of differing inheritability, or revision ranges with a start revision greater than or equal to its end revision, or contains paths mapped to empty revision ranges, then return <code>SVN_ERR_MERGEINFO_PARSE_ERROR</code>. Unordered revision ranges are allowed, but will be sorted when placed into <em>*mergeinfo</em>. Overlapping revision ranges of the same inheritability are also allowed, but will be combined into a single range when placed into <em>*mergeinfo</em>.</p>
<p><em>input</em> may contain relative merge source paths, but these are converted to absolute paths in <em>*mergeinfo</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="af5293e26d8af012fb839ca96ee6cbfc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_mergeinfo_remove </td>
          <td>(</td>
          <td class="paramtype">svn_mergeinfo_t *&#160;</td>
          <td class="paramname"><em>mergeinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">svn_mergeinfo_t&#160;</td>
          <td class="paramname"><em>eraser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">svn_mergeinfo_t&#160;</td>
          <td class="paramname"><em>whiteboard</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like svn_mergeinfo_remove2, but always considers inheritance. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000242">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.6 API. </dd></dl>

</div>
</div>
<a class="anchor" id="afe2e8565251b0506deaf4fe69e622072"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_mergeinfo_remove2 </td>
          <td>(</td>
          <td class="paramtype">svn_mergeinfo_t *&#160;</td>
          <td class="paramname"><em>mergeinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">svn_mergeinfo_t&#160;</td>
          <td class="paramname"><em>eraser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">svn_mergeinfo_t&#160;</td>
          <td class="paramname"><em>whiteboard</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>consider_inheritance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes <em>eraser</em> (the subtrahend) from <em>whiteboard</em> (the minuend), and places the resulting difference in <em>*mergeinfo</em>. </p>
<p>Allocates <em>*mergeinfo</em> in <em>result_pool</em>. Temporary allocations will be performed in <em>scratch_pool</em>.</p>
<p><em>consider_inheritance</em> determines how to account for the inheritability of the two mergeinfo's ranges when calculating the range equivalence, as described for <a class="el" href="svn__mergeinfo_8h.html#a99924a6f5f1ffa833fd3ab72e8661778" title="Similar to svn_mergeinfo_diff2(), but users only one pool. ">svn_mergeinfo_diff()</a>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="aa3e1605436e43a23f5055649f4a831f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_mergeinfo_sort </td>
          <td>(</td>
          <td class="paramtype">svn_mergeinfo_t&#160;</td>
          <td class="paramname"><em>mergeinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a hash of mergeinfo in <em>mergeinfo</em>, and sort the rangelists associated with each key (in place). </p>
<p>TODO(miapi): mergeinfos should <em>always</em> be sorted. This should be a private function.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.5 </dd></dl>

</div>
</div>
<a class="anchor" id="a4be44bfd77bb7b3b4bbcc516e82655ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_mergeinfo_to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__string__t.html">svn_string_t</a> **&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">svn_mergeinfo_t&#160;</td>
          <td class="paramname"><em>mergeinput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a mergeinfo in <em>mergeinput</em>, and convert it to unparsed mergeinfo. </p>
<p>Set <em>*output</em> to the result, allocated in <em>pool</em>. If <em>input</em> contains no elements, set <em>*output</em> to the empty string.</p>
<p><em>mergeinput</em> may contain relative merge source paths, but these are converted to absolute paths in <em>*output</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="abd7982476b74d520bbc57f27379a5cca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_rangelist_diff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> **&#160;</td>
          <td class="paramname"><em>deleted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> **&#160;</td>
          <td class="paramname"><em>added</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>consider_inheritance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the delta between two rangelists consisting of <code><a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions. ">svn_merge_range_t</a></code> * elements (sorted in ascending order), <em>from</em> and <em>to</em>, and place the result in <em>*deleted</em> and <em>*added</em> (neither output argument will ever be <code>NULL</code>). </p>
<p><em>consider_inheritance</em> determines how to account for the inheritability of the two rangelist's ranges when calculating the diff, as described for <a class="el" href="svn__mergeinfo_8h.html#a99924a6f5f1ffa833fd3ab72e8661778" title="Similar to svn_mergeinfo_diff2(), but users only one pool. ">svn_mergeinfo_diff()</a>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="a69f1189668b2a2fa61affe4471c0192f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a>* svn_rangelist_dup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> *&#160;</td>
          <td class="paramname"><em>rangelist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a deep copy of <em>rangelist</em>, allocated in <em>pool</em>. </p>
<dl class="section since"><dt>Since</dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="a7baad11b2af45a50dd9be617d714aa28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_rangelist_inheritable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> **&#160;</td>
          <td class="paramname"><em>inheritable_rangelist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> *&#160;</td>
          <td class="paramname"><em>rangelist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like svn_rangelist_inheritable2, but always finds inheritable ranges. </p>
<dl class="section since"><dt>Since</dt><dd>New in 1.5. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000245">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.6 API. </dd></dl>

</div>
</div>
<a class="anchor" id="a1041c38c9fa793c39e88d1e40e2c90cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_rangelist_inheritable2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> **&#160;</td>
          <td class="paramname"><em>inheritable_rangelist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> *&#160;</td>
          <td class="paramname"><em>rangelist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>inheritable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a deep copy of <code><a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions. ">svn_merge_range_t</a></code> *'s in <em>rangelist</em> excluding all non-inheritable <code><a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions. ">svn_merge_range_t</a></code> if <em>inheritable</em> is TRUE or excluding all inheritable <code><a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions. ">svn_merge_range_t</a></code> otherwise. </p>
<p>If <em>start</em> and <em>end</em> are valid revisions and <em>start</em> is less than or equal to <em>end</em>, then exclude only the non-inheritable revision ranges that intersect inclusively with the range defined by <em>start</em> and <em>end</em>. If <em>rangelist</em> contains no elements, return an empty array. Allocate the copy in <em>result_pool</em>, use <em>scratch_pool</em> for temporary allocations.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="a136e89015e53e33cdccb339750fc6c7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_rangelist_intersect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> **&#160;</td>
          <td class="paramname"><em>rangelist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> *&#160;</td>
          <td class="paramname"><em>rangelist1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> *&#160;</td>
          <td class="paramname"><em>rangelist2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>consider_inheritance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the intersection of two rangelists consisting of <code><a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions. ">svn_merge_range_t</a></code> * elements, <em>rangelist1</em> and <em>rangelist2</em>, and place the result in <em>*rangelist</em> (which is never <code>NULL</code>). </p>
<p><em>consider_inheritance</em> determines how to account for the inheritability of the two rangelist's ranges when calculating the intersection, </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="svn__mergeinfo_8h.html#a99924a6f5f1ffa833fd3ab72e8661778" title="Similar to svn_mergeinfo_diff2(), but users only one pool. ">svn_mergeinfo_diff()</a>. If <em>consider_inheritance</em> is <a class="el" href="svn__types_8h.html#aa93f0eb578d23995850d61f7d61c55c1" title="uhh... ">FALSE</a> then ranges with different inheritance can intersect, but the resulting <em>*rangelist</em> is non-inheritable only if the corresponding ranges from both <em>rangelist1</em> and <em>rangelist2</em> are non-inheritable. If <em>consider_inheritance</em> is <a class="el" href="svn__types_8h.html#aa8cecfc5c5c054d2875c03e77b7be15d" title="uhh... ">TRUE</a>, then ranges with different inheritance can never intersect.</dd></dl>
<p>Note: <em>rangelist1</em> and <em>rangelist2</em> must be sorted as said by <code><a class="el" href="svn__sorts_8h.html#a58a32c4f0a5c14672865be8768b1113a" title="Compare two svn_merge_range_t *&#39;s, *a and *b, returning an integer greater than, equal to...">svn_sort_compare_ranges()</a></code>. <em>*rangelist</em> is guaranteed to be in sorted order. </p>
<dl class="section since"><dt>Since</dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="abbcd0926060c1a20d05f5747f7c86017"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_rangelist_merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> **&#160;</td>
          <td class="paramname"><em>rangelist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> *&#160;</td>
          <td class="paramname"><em>changes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <a class="el" href="svn__mergeinfo_8h.html#a4ad49d1cdcee6cf77d2c724e3bc8d1db" title="Merge two rangelists consisting of svn_merge_range_t * elements, rangelist and changes, placing the results in rangelist. ">svn_rangelist_merge2()</a>, but with <em>rangelist</em> as an input/output argument. </p>
<p>This function always allocates a new rangelist in <em>pool</em> and returns its result in <em>*rangelist</em>. It does not modify <em>*rangelist</em> in place. If not used carefully, this function can use up a lot of memory if called in a loop.</p>
<p>It performs an extra adjacent range compaction round to make sure non collapsed input ranges are compacted in the result.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.5. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000243">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.7 API. </dd></dl>

</div>
</div>
<a class="anchor" id="a4ad49d1cdcee6cf77d2c724e3bc8d1db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_rangelist_merge2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> *&#160;</td>
          <td class="paramname"><em>rangelist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> *&#160;</td>
          <td class="paramname"><em>changes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge two rangelists consisting of <code><a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions. ">svn_merge_range_t</a></code> * elements, <em>rangelist</em> and <em>changes</em>, placing the results in <em>rangelist</em>. </p>
<p>New elements added to <em>rangelist</em> are allocated in <em>result_pool</em>. Either rangelist may be empty.</p>
<p>When intersecting rangelists are merged, the inheritability of the resulting <a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions. ">svn_merge_range_t</a> depends on the inheritability of the operands: see <a class="el" href="svn__mergeinfo_8h.html#a0bab0a2e1d9cd707dd752644144b13bc" title="Like svn_mergeinfo_merge2, but uses only one pool. ">svn_mergeinfo_merge()</a>.</p>
<p>Note: <em>rangelist</em> and <em>changes</em> must be sorted as said by <code><a class="el" href="svn__sorts_8h.html#a58a32c4f0a5c14672865be8768b1113a" title="Compare two svn_merge_range_t *&#39;s, *a and *b, returning an integer greater than, equal to...">svn_sort_compare_ranges()</a></code>. <em>rangelist</em> is guaranteed to remain in sorted order and be compacted to the minimal number of ranges needed to represent the merged result.</p>
<p>If the original rangelist contains non-collapsed adjacent ranges, the final result is not guaranteed to be compacted either.</p>
<p>Use <em>scratch_pool</em> for temporary allocations.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.8. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c123e29a0a04289ac59cc69a75b29c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_rangelist_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> **&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> *&#160;</td>
          <td class="paramname"><em>eraser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> *&#160;</td>
          <td class="paramname"><em>whiteboard</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>consider_inheritance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes <em>eraser</em> (the subtrahend) from <em>whiteboard</em> (the minuend), and places the resulting difference in <em>output</em>. </p>
<p>Note: <em>eraser</em> and <em>whiteboard</em> must be sorted as said by <code><a class="el" href="svn__sorts_8h.html#a58a32c4f0a5c14672865be8768b1113a" title="Compare two svn_merge_range_t *&#39;s, *a and *b, returning an integer greater than, equal to...">svn_sort_compare_ranges()</a></code>. <em>output</em> is guaranteed to be in sorted order.</p>
<p><em>consider_inheritance</em> determines how to account for the <code><a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions. ">svn_merge_range_t</a></code> inheritable field when comparing <em>whiteboard's</em> and <em>*eraser's</em> rangelists for equality. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="svn__mergeinfo_8h.html#a99924a6f5f1ffa833fd3ab72e8661778" title="Similar to svn_mergeinfo_diff2(), but users only one pool. ">svn_mergeinfo_diff()</a>.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="a969feab45958f8fdcfacfb960945e151"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_rangelist_reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> *&#160;</td>
          <td class="paramname"><em>rangelist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse <em>rangelist</em>, and the <code>start</code> and <code>end</code> fields of each range in <em>rangelist</em>, in place. </p>
<p>TODO(miapi): Is this really a valid function? Rangelists that aren't sorted, or rangelists containing reverse ranges, are generally not valid in mergeinfo code. Can we rewrite the two places where this is used?</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="aef49dea3dda0dada94e003ede4d6c2d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_rangelist_to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__string__t.html">svn_string_t</a> **&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="svn__mergeinfo_8h.html#ab8e0fcb708d6e142d54b751c377ae30e">svn_rangelist_t</a> *&#160;</td>
          <td class="paramname"><em>rangelist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take an array of <a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions. ">svn_merge_range_t</a> *'s in <em>rangelist</em>, and convert it back to a text format rangelist in <em>output</em>. </p>
<p>If <em>rangelist</em> contains no elements, sets <em>output</em> to the empty string.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.5. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Aug 19 2015 09:37:23 for Subversion by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
