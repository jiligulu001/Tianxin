<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Subversion: svn_dirent_uri.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Subversion
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_c37f7789c49aa9e5999234152b1ef6ed.html">subversion</a></li><li class="navelem"><a class="el" href="dir_334478eea8dba5ae935f94af9469978f.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">svn_dirent_uri.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A library to manipulate URIs, relative paths and directory entries.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;apr.h&gt;</code><br/>
<code>#include &lt;apr_pools.h&gt;</code><br/>
<code>#include &lt;apr_tables.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="svn__types_8h_source.html">svn_types.h</a>&quot;</code><br/>
</div>
<p><a href="svn__dirent__uri_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a675354133cf6e25d3e1cbe6a0f7069e9"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#a675354133cf6e25d3e1cbe6a0f7069e9">svn_dirent_internal_style</a> (const char *dirent, apr_pool_t *result_pool)</td></tr>
<tr class="memdesc:a675354133cf6e25d3e1cbe6a0f7069e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <em>dirent</em> from the local style to the canonical internal style.  <a href="#a675354133cf6e25d3e1cbe6a0f7069e9">More...</a><br/></td></tr>
<tr class="separator:a675354133cf6e25d3e1cbe6a0f7069e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace26b3b96a2cb6e56fed9a7a288d2b20"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#ace26b3b96a2cb6e56fed9a7a288d2b20">svn_dirent_local_style</a> (const char *dirent, apr_pool_t *result_pool)</td></tr>
<tr class="memdesc:ace26b3b96a2cb6e56fed9a7a288d2b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <em>dirent</em> from the internal style to the local style.  <a href="#ace26b3b96a2cb6e56fed9a7a288d2b20">More...</a><br/></td></tr>
<tr class="separator:ace26b3b96a2cb6e56fed9a7a288d2b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5853024ba08f8671c6fec0146b10d721"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#a5853024ba08f8671c6fec0146b10d721">svn_relpath__internal_style</a> (const char *relpath, apr_pool_t *result_pool)</td></tr>
<tr class="memdesc:a5853024ba08f8671c6fec0146b10d721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <em>relpath</em> from the local style to the canonical internal style.  <a href="#a5853024ba08f8671c6fec0146b10d721">More...</a><br/></td></tr>
<tr class="separator:a5853024ba08f8671c6fec0146b10d721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ad2bf82642cff7d65c8310868be834"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#aa0ad2bf82642cff7d65c8310868be834">svn_dirent_join</a> (const char *base, const char *component, apr_pool_t *result_pool)</td></tr>
<tr class="memdesc:aa0ad2bf82642cff7d65c8310868be834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a base dirent (<em>base</em>) with a component (<em>component</em>).  <a href="#aa0ad2bf82642cff7d65c8310868be834">More...</a><br/></td></tr>
<tr class="separator:aa0ad2bf82642cff7d65c8310868be834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc91f8e99a171e7ec4becffdc023901"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#a9cc91f8e99a171e7ec4becffdc023901">svn_dirent_join_many</a> (apr_pool_t *result_pool, const char *base,...)</td></tr>
<tr class="memdesc:a9cc91f8e99a171e7ec4becffdc023901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join multiple components onto a <em>base</em> dirent.  <a href="#a9cc91f8e99a171e7ec4becffdc023901">More...</a><br/></td></tr>
<tr class="separator:a9cc91f8e99a171e7ec4becffdc023901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea93c789655a35d683bf3b2e29d626c"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#a8ea93c789655a35d683bf3b2e29d626c">svn_relpath_join</a> (const char *base, const char *component, apr_pool_t *result_pool)</td></tr>
<tr class="memdesc:a8ea93c789655a35d683bf3b2e29d626c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a base relpath (<em>base</em>) with a component (<em>component</em>).  <a href="#a8ea93c789655a35d683bf3b2e29d626c">More...</a><br/></td></tr>
<tr class="separator:a8ea93c789655a35d683bf3b2e29d626c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1989277bd046113f5a4a04eea47969"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#abd1989277bd046113f5a4a04eea47969">svn_dirent_basename</a> (const char *dirent, apr_pool_t *result_pool)</td></tr>
<tr class="memdesc:abd1989277bd046113f5a4a04eea47969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name of the specified canonicalized <em>dirent</em> as it is known within its parent directory.  <a href="#abd1989277bd046113f5a4a04eea47969">More...</a><br/></td></tr>
<tr class="separator:abd1989277bd046113f5a4a04eea47969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6642420c9f437098834a4f7151aa3332"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#a6642420c9f437098834a4f7151aa3332">svn_dirent_dirname</a> (const char *dirent, apr_pool_t *result_pool)</td></tr>
<tr class="memdesc:a6642420c9f437098834a4f7151aa3332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dirname of the specified canonicalized <em>dirent</em>, defined as the dirent with its basename removed.  <a href="#a6642420c9f437098834a4f7151aa3332">More...</a><br/></td></tr>
<tr class="separator:a6642420c9f437098834a4f7151aa3332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa953a9310560da25358de9ef3621545c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#aa953a9310560da25358de9ef3621545c">svn_dirent_split</a> (const char **dirpath, const char **base_name, const char *dirent, apr_pool_t *result_pool)</td></tr>
<tr class="memdesc:aa953a9310560da25358de9ef3621545c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide the canonicalized <em>dirent</em> into <em>*dirpath</em> and <em>*base_name</em>.  <a href="#aa953a9310560da25358de9ef3621545c">More...</a><br/></td></tr>
<tr class="separator:aa953a9310560da25358de9ef3621545c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae785b4fb4290096d50a2dc9323a97aa4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#ae785b4fb4290096d50a2dc9323a97aa4">svn_relpath_split</a> (const char **dirpath, const char **base_name, const char *relpath, apr_pool_t *result_pool)</td></tr>
<tr class="memdesc:ae785b4fb4290096d50a2dc9323a97aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide the canonicalized <em>relpath</em> into <em>*dirpath</em> and <em>*base_name</em>.  <a href="#ae785b4fb4290096d50a2dc9323a97aa4">More...</a><br/></td></tr>
<tr class="separator:ae785b4fb4290096d50a2dc9323a97aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87096512213d2540a40f62c66f52f4c5"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#a87096512213d2540a40f62c66f52f4c5">svn_relpath_basename</a> (const char *relpath, apr_pool_t *result_pool)</td></tr>
<tr class="memdesc:a87096512213d2540a40f62c66f52f4c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the basename of the specified canonicalized <em>relpath</em>.  <a href="#a87096512213d2540a40f62c66f52f4c5">More...</a><br/></td></tr>
<tr class="separator:a87096512213d2540a40f62c66f52f4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66fa16ca5787b158939e9e8e9f171cc"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#ab66fa16ca5787b158939e9e8e9f171cc">svn_relpath_dirname</a> (const char *relpath, apr_pool_t *result_pool)</td></tr>
<tr class="memdesc:ab66fa16ca5787b158939e9e8e9f171cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dirname of the specified canonicalized <em>relpath</em>, defined as the relpath with its basename removed.  <a href="#ab66fa16ca5787b158939e9e8e9f171cc">More...</a><br/></td></tr>
<tr class="separator:ab66fa16ca5787b158939e9e8e9f171cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1738f95947423b71ec6b304cbfaf5417"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#a1738f95947423b71ec6b304cbfaf5417">svn_uri_split</a> (const char **dirpath, const char **base_name, const char *uri, apr_pool_t *result_pool)</td></tr>
<tr class="memdesc:a1738f95947423b71ec6b304cbfaf5417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide the canonicalized <em>uri</em> into a uri <em>*dirpath</em> and a (URI-decoded) relpath <em>*base_name</em>.  <a href="#a1738f95947423b71ec6b304cbfaf5417">More...</a><br/></td></tr>
<tr class="separator:a1738f95947423b71ec6b304cbfaf5417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff6a95bb7cb4b01f509a3a20068203b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#aaff6a95bb7cb4b01f509a3a20068203b">svn_uri_basename</a> (const char *uri, apr_pool_t *result_pool)</td></tr>
<tr class="memdesc:aaff6a95bb7cb4b01f509a3a20068203b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the (URI-decoded) basename of the specified canonicalized <em>uri</em>.  <a href="#aaff6a95bb7cb4b01f509a3a20068203b">More...</a><br/></td></tr>
<tr class="separator:aaff6a95bb7cb4b01f509a3a20068203b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6afeca29c5c55e1dafb6640d89505533"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#a6afeca29c5c55e1dafb6640d89505533">svn_uri_dirname</a> (const char *uri, apr_pool_t *result_pool)</td></tr>
<tr class="memdesc:a6afeca29c5c55e1dafb6640d89505533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dirname of the specified canonicalized <em>uri</em>, defined as the uri with its basename removed.  <a href="#a6afeca29c5c55e1dafb6640d89505533">More...</a><br/></td></tr>
<tr class="separator:a6afeca29c5c55e1dafb6640d89505533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc765f2a1baead8e8489e02726b50f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#aafc765f2a1baead8e8489e02726b50f0">svn_dirent_is_absolute</a> (const char *dirent)</td></tr>
<tr class="memdesc:aafc765f2a1baead8e8489e02726b50f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return TRUE if <em>dirent</em> is considered absolute on the platform at hand.  <a href="#aafc765f2a1baead8e8489e02726b50f0">More...</a><br/></td></tr>
<tr class="separator:aafc765f2a1baead8e8489e02726b50f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28eb607dfb4fe7137b2e633f9e0604f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#ab28eb607dfb4fe7137b2e633f9e0604f">svn_dirent_is_root</a> (const char *dirent, apr_size_t len)</td></tr>
<tr class="memdesc:ab28eb607dfb4fe7137b2e633f9e0604f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return TRUE if <em>dirent</em> is considered a root directory on the platform at hand.  <a href="#ab28eb607dfb4fe7137b2e633f9e0604f">More...</a><br/></td></tr>
<tr class="separator:ab28eb607dfb4fe7137b2e633f9e0604f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad425a70a4400dd8e62c727a53a436439"><td class="memItemLeft" align="right" valign="top"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#ad425a70a4400dd8e62c727a53a436439">svn_uri_is_root</a> (const char *uri, apr_size_t len)</td></tr>
<tr class="memdesc:ad425a70a4400dd8e62c727a53a436439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return TRUE if <em>uri</em> is a root URL (e.g., "http://server").  <a href="#ad425a70a4400dd8e62c727a53a436439">More...</a><br/></td></tr>
<tr class="separator:ad425a70a4400dd8e62c727a53a436439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43bc9669a9cd5c241aacd3e120134154"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#a43bc9669a9cd5c241aacd3e120134154">svn_dirent_canonicalize</a> (const char *dirent, apr_pool_t *result_pool)</td></tr>
<tr class="memdesc:a43bc9669a9cd5c241aacd3e120134154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new dirent like <em>dirent</em>, but transformed such that some types of dirent specification redundancies are removed.  <a href="#a43bc9669a9cd5c241aacd3e120134154">More...</a><br/></td></tr>
<tr class="separator:a43bc9669a9cd5c241aacd3e120134154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd34d4c169df9722f03dd6e499a07ea"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#a6fd34d4c169df9722f03dd6e499a07ea">svn_relpath_canonicalize</a> (const char *relpath, apr_pool_t *result_pool)</td></tr>
<tr class="memdesc:a6fd34d4c169df9722f03dd6e499a07ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new relpath like <em>relpath</em>, but transformed such that some types of relpath specification redundancies are removed.  <a href="#a6fd34d4c169df9722f03dd6e499a07ea">More...</a><br/></td></tr>
<tr class="separator:a6fd34d4c169df9722f03dd6e499a07ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624e026e7bdd426d063435b87db2b103"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#a624e026e7bdd426d063435b87db2b103">svn_uri_canonicalize</a> (const char *uri, apr_pool_t *result_pool)</td></tr>
<tr class="memdesc:a624e026e7bdd426d063435b87db2b103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new uri like <em>uri</em>, but transformed such that some types of uri specification redundancies are removed.  <a href="#a624e026e7bdd426d063435b87db2b103">More...</a><br/></td></tr>
<tr class="separator:a624e026e7bdd426d063435b87db2b103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a401b8232b2fe7173cb62f2fbdf06c56e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#a401b8232b2fe7173cb62f2fbdf06c56e">svn_dirent_is_canonical</a> (const char *dirent, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:a401b8232b2fe7173cb62f2fbdf06c56e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>TRUE</code> iff <em>dirent</em> is canonical.  <a href="#a401b8232b2fe7173cb62f2fbdf06c56e">More...</a><br/></td></tr>
<tr class="separator:a401b8232b2fe7173cb62f2fbdf06c56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac552be30e9f2c8a500d1685be8898f2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#ac552be30e9f2c8a500d1685be8898f2f">svn_relpath_is_canonical</a> (const char *relpath)</td></tr>
<tr class="memdesc:ac552be30e9f2c8a500d1685be8898f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>TRUE</code> iff <em>relpath</em> is canonical.  <a href="#ac552be30e9f2c8a500d1685be8898f2f">More...</a><br/></td></tr>
<tr class="separator:ac552be30e9f2c8a500d1685be8898f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82bfff97a7826720fdb864edd96d8012"><td class="memItemLeft" align="right" valign="top"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#a82bfff97a7826720fdb864edd96d8012">svn_uri_is_canonical</a> (const char *uri, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:a82bfff97a7826720fdb864edd96d8012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>TRUE</code> iff <em>uri</em> is canonical.  <a href="#a82bfff97a7826720fdb864edd96d8012">More...</a><br/></td></tr>
<tr class="separator:a82bfff97a7826720fdb864edd96d8012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53391740b3d8664cb3865f210821b659"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#a53391740b3d8664cb3865f210821b659">svn_dirent_get_longest_ancestor</a> (const char *dirent1, const char *dirent2, apr_pool_t *result_pool)</td></tr>
<tr class="memdesc:a53391740b3d8664cb3865f210821b659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the longest common dirent shared by two canonicalized dirents, <em>dirent1</em> and <em>dirent2</em>.  <a href="#a53391740b3d8664cb3865f210821b659">More...</a><br/></td></tr>
<tr class="separator:a53391740b3d8664cb3865f210821b659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8480880f4d8de50c24baf434f076b83"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#ae8480880f4d8de50c24baf434f076b83">svn_relpath_get_longest_ancestor</a> (const char *relpath1, const char *relpath2, apr_pool_t *result_pool)</td></tr>
<tr class="memdesc:ae8480880f4d8de50c24baf434f076b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the longest common path shared by two relative paths, <em>relpath1</em> and <em>relpath2</em>.  <a href="#ae8480880f4d8de50c24baf434f076b83">More...</a><br/></td></tr>
<tr class="separator:ae8480880f4d8de50c24baf434f076b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223335146fbf57d59114466bf686132d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#a223335146fbf57d59114466bf686132d">svn_uri_get_longest_ancestor</a> (const char *uri1, const char *uri2, apr_pool_t *result_pool)</td></tr>
<tr class="memdesc:a223335146fbf57d59114466bf686132d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the longest common path shared by two canonicalized uris, <em>uri1</em> and <em>uri2</em>.  <a href="#a223335146fbf57d59114466bf686132d">More...</a><br/></td></tr>
<tr class="separator:a223335146fbf57d59114466bf686132d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c00a9fd200c14f8768a01e9ffbecf1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#af2c00a9fd200c14f8768a01e9ffbecf1">svn_dirent_get_absolute</a> (const char **pabsolute, const char *relative, apr_pool_t *result_pool)</td></tr>
<tr class="memdesc:af2c00a9fd200c14f8768a01e9ffbecf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <em>relative</em> canonicalized dirent to an absolute dirent and return the results in <em>*pabsolute</em>.  <a href="#af2c00a9fd200c14f8768a01e9ffbecf1">More...</a><br/></td></tr>
<tr class="separator:af2c00a9fd200c14f8768a01e9ffbecf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12399fefc5245c9b729d0a2f4fbe981"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#af12399fefc5245c9b729d0a2f4fbe981">svn_dirent_is_child</a> (const char *parent_dirent, const char *child_dirent, apr_pool_t *result_pool)</td></tr>
<tr class="memdesc:af12399fefc5245c9b729d0a2f4fbe981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="svn__dirent__uri_8h.html#a43120221527224b1e161e70f6608f746" title="Return the relative path part of child_dirent that is below parent_dirent, or just &quot;&quot; if parent_diren...">svn_dirent_skip_ancestor()</a>, except that if <em>child_dirent</em> is the same as <em>parent_dirent</em>, it is not considered a child, so the result is <code>NULL</code>; an empty string is never returned.  <a href="#af12399fefc5245c9b729d0a2f4fbe981">More...</a><br/></td></tr>
<tr class="separator:af12399fefc5245c9b729d0a2f4fbe981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b2f9504ab294d22f8067ea0046151a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#a65b2f9504ab294d22f8067ea0046151a">svn_dirent_is_ancestor</a> (const char *parent_dirent, const char *child_dirent)</td></tr>
<tr class="memdesc:a65b2f9504ab294d22f8067ea0046151a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return TRUE if <em>parent_dirent</em> is an ancestor of <em>child_dirent</em> or the dirents are equal, and FALSE otherwise.  <a href="#a65b2f9504ab294d22f8067ea0046151a">More...</a><br/></td></tr>
<tr class="separator:a65b2f9504ab294d22f8067ea0046151a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6879e5f019e4dfe3125c8aca48051b2b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6879e5f019e4dfe3125c8aca48051b2b"></a>
<a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#a6879e5f019e4dfe3125c8aca48051b2b">svn_uri__is_ancestor</a> (const char *parent_uri, const char *child_uri)</td></tr>
<tr class="memdesc:a6879e5f019e4dfe3125c8aca48051b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return TRUE if <em>parent_uri</em> is an ancestor of <em>child_uri</em> or the uris are equal, and FALSE otherwise. <br/></td></tr>
<tr class="separator:a6879e5f019e4dfe3125c8aca48051b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43120221527224b1e161e70f6608f746"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#a43120221527224b1e161e70f6608f746">svn_dirent_skip_ancestor</a> (const char *parent_dirent, const char *child_dirent)</td></tr>
<tr class="memdesc:a43120221527224b1e161e70f6608f746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the relative path part of <em>child_dirent</em> that is below <em>parent_dirent</em>, or just "" if <em>parent_dirent</em> is equal to <em>child_dirent</em>.  <a href="#a43120221527224b1e161e70f6608f746">More...</a><br/></td></tr>
<tr class="separator:a43120221527224b1e161e70f6608f746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f246ac90c84c2d2ad68f9a473d2b46"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#a38f246ac90c84c2d2ad68f9a473d2b46">svn_relpath_skip_ancestor</a> (const char *parent_relpath, const char *child_relpath)</td></tr>
<tr class="memdesc:a38f246ac90c84c2d2ad68f9a473d2b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the relative path part of <em>child_relpath</em> that is below <em>parent_relpath</em>, or just "" if <em>parent_relpath</em> is equal to <em>child_relpath</em>.  <a href="#a38f246ac90c84c2d2ad68f9a473d2b46">More...</a><br/></td></tr>
<tr class="separator:a38f246ac90c84c2d2ad68f9a473d2b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f060989ec00f710dce15f9668c5d6db"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#a2f060989ec00f710dce15f9668c5d6db">svn_uri_skip_ancestor</a> (const char *parent_uri, const char *child_uri, apr_pool_t *result_pool)</td></tr>
<tr class="memdesc:a2f060989ec00f710dce15f9668c5d6db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the URI-decoded relative path of <em>child_uri</em> that is below <em>parent_uri</em>, or just "" if <em>parent_uri</em> is equal to <em>child_uri</em>.  <a href="#a2f060989ec00f710dce15f9668c5d6db">More...</a><br/></td></tr>
<tr class="separator:a2f060989ec00f710dce15f9668c5d6db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f44342f4caf7ad7abd74ab1a0c9c213"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#a8f44342f4caf7ad7abd74ab1a0c9c213">svn_dirent_condense_targets</a> (const char **pcommon, apr_array_header_t **pcondensed_targets, const apr_array_header_t *targets, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> remove_redundancies, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:a8f44342f4caf7ad7abd74ab1a0c9c213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the common prefix of the canonicalized dirents in <em>targets</em> (an array of <code>const char *</code>'s), and remove redundant dirents if <em>remove_redundancies</em> is TRUE.  <a href="#a8f44342f4caf7ad7abd74ab1a0c9c213">More...</a><br/></td></tr>
<tr class="separator:a8f44342f4caf7ad7abd74ab1a0c9c213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b41445fe57a14f5866d6c040536f931"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#a1b41445fe57a14f5866d6c040536f931">svn_uri_condense_targets</a> (const char **pcommon, apr_array_header_t **pcondensed_targets, const apr_array_header_t *targets, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> remove_redundancies, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:a1b41445fe57a14f5866d6c040536f931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the common prefix of the canonicalized uris in <em>targets</em> (an array of <code>const char *</code>'s), and remove redundant uris if <em>remove_redundancies</em> is TRUE.  <a href="#a1b41445fe57a14f5866d6c040536f931">More...</a><br/></td></tr>
<tr class="separator:a1b41445fe57a14f5866d6c040536f931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1848eecb74dfd34721bd04e025128d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#a6c1848eecb74dfd34721bd04e025128d">svn_dirent_is_under_root</a> (<a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *under_root, const char **result_path, const char *base_path, const char *path, apr_pool_t *result_pool)</td></tr>
<tr class="memdesc:a6c1848eecb74dfd34721bd04e025128d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join <em>path</em> onto <em>base_path</em>, checking that <em>path</em> does not attempt to traverse above <em>base_path</em>.  <a href="#a6c1848eecb74dfd34721bd04e025128d">More...</a><br/></td></tr>
<tr class="separator:a6c1848eecb74dfd34721bd04e025128d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5054bb84b11206bcf99dbdb6b06480d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#a5054bb84b11206bcf99dbdb6b06480d0">svn_uri_get_dirent_from_file_url</a> (const char **dirent, const char *url, apr_pool_t *result_pool)</td></tr>
<tr class="memdesc:a5054bb84b11206bcf99dbdb6b06480d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*dirent</em> to the path corresponding to the <a href="file://">file://</a> URL <em>url</em>, using the platform-specific <a href="file://">file://</a> rules.  <a href="#a5054bb84b11206bcf99dbdb6b06480d0">More...</a><br/></td></tr>
<tr class="separator:a5054bb84b11206bcf99dbdb6b06480d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb12ae63411fb60bd9505fd2c2ed7b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__dirent__uri_8h.html#a2cb12ae63411fb60bd9505fd2c2ed7b7">svn_uri_get_file_url_from_dirent</a> (const char **url, const char *dirent, apr_pool_t *result_pool)</td></tr>
<tr class="memdesc:a2cb12ae63411fb60bd9505fd2c2ed7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*url</em> to a <a href="file://">file://</a> URL, corresponding to <em>dirent</em> using the platform specific dirent and <a href="file://">file://</a> rules.  <a href="#a2cb12ae63411fb60bd9505fd2c2ed7b7">More...</a><br/></td></tr>
<tr class="separator:a2cb12ae63411fb60bd9505fd2c2ed7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A library to manipulate URIs, relative paths and directory entries. </p>
<p>This library makes a clear distinction between several path formats:</p>
<ul>
<li>a dirent is a path on (local) disc or a UNC path (Windows) in either relative or absolute format. Examples: "/foo/bar", "X:/temp", "//server/share", "A:/" (Windows only), "" But not: "http://server"</li>
<li>a uri, for our purposes, is a percent-encoded, absolute path (URI) that starts with a schema definition. In practice, these tend to look like URLs, but never carry query strings. Examples: "http://server", "file:///path/to/repos", "svn+ssh://user@host:123/My%20Stuff/file.doc" But not: "file", "dir/file", "A:/dir", "/My%20Stuff/file.doc", ""</li>
<li>a relative path (relpath) is an unrooted path that can be joined to any other relative path, uri or dirent. A relative path is never rooted/prefixed by a '/'. Examples: "file", "dir/file", "dir/subdir/../file", "" But not: "/file", "http://server/file"</li>
</ul>
<p>This distinction is needed because on Windows we have to handle some dirents and URIs differently. Since it's not possible to determine from the path string if it's a dirent or a URI, it's up to the API user to make this choice. See also issue #2028.</p>
<p>All incoming and outgoing paths are non-NULL unless otherwise documented.</p>
<p>All of these functions expect paths passed into them to be in canonical form, except:</p>
<ul>
<li><code><a class="el" href="svn__dirent__uri_8h.html#a43bc9669a9cd5c241aacd3e120134154" title="Return a new dirent like dirent, but transformed such that some types of dirent specification redunda...">svn_dirent_canonicalize()</a></code> </li>
<li><code><a class="el" href="svn__dirent__uri_8h.html#a401b8232b2fe7173cb62f2fbdf06c56e" title="Return TRUE iff dirent is canonical. ">svn_dirent_is_canonical()</a></code> </li>
<li><code><a class="el" href="svn__dirent__uri_8h.html#a675354133cf6e25d3e1cbe6a0f7069e9" title="Convert dirent from the local style to the canonical internal style. ">svn_dirent_internal_style()</a></code> </li>
<li><code><a class="el" href="svn__dirent__uri_8h.html#a6fd34d4c169df9722f03dd6e499a07ea" title="Return a new relpath like relpath, but transformed such that some types of relpath specification redu...">svn_relpath_canonicalize()</a></code> </li>
<li><code><a class="el" href="svn__dirent__uri_8h.html#ac552be30e9f2c8a500d1685be8898f2f" title="Return TRUE iff relpath is canonical. ">svn_relpath_is_canonical()</a></code> </li>
<li><code><a class="el" href="svn__dirent__uri_8h.html#a5853024ba08f8671c6fec0146b10d721" title="Convert relpath from the local style to the canonical internal style. ">svn_relpath__internal_style()</a></code> </li>
<li><code><a class="el" href="svn__dirent__uri_8h.html#a624e026e7bdd426d063435b87db2b103" title="Return a new uri like uri, but transformed such that some types of uri specification redundancies are...">svn_uri_canonicalize()</a></code> </li>
<li><code><a class="el" href="svn__dirent__uri_8h.html#a82bfff97a7826720fdb864edd96d8012" title="Return TRUE iff uri is canonical. ">svn_uri_is_canonical()</a></code> </li>
</ul>
<p>The Subversion codebase also recognizes some other classes of path:</p>
<ul>
<li>A Subversion filesystem path (fspath) &ndash; otherwise known as a path within a repository &ndash; is a path relative to the root of the repository filesystem, that starts with a slash ("/"). The rules for a fspath are the same as for a relpath except for the leading '/'. A fspath never ends with '/' except when the whole path is just '/'. The fspath API is private (see private/svn_fspath.h).</li>
<li>A URL path (urlpath) is just the path part of a URL (the part that follows the schema, username, hostname, and port). These are also like relpaths, except that they have a leading slash (like fspaths) and are URI-encoded. The urlpath API is also private (see private/svn_fspath.h) Example: "/svn/repos/trunk/README", "/svn/repos/!svn/bc/45/file%20with%20spaces.txt"</li>
</ul>
<p>So, which path API is appropriate for your use-case?</p>
<ul>
<li>If your path refers to a local file, directory, symlink, etc. of the sort that you can examine and operate on with other software on your computer, it's a dirent.</li>
<li>If your path is a full URL &ndash; with a schema, hostname (maybe), and path portion &ndash; it's a uri.</li>
<li>If your path is relative, and is somewhat ambiguous unless it's joined to some other more explicit (possible absolute) base (such as a dirent or URL), it's a relpath.</li>
<li>If your path is the virtual path of a versioned object inside a Subversion repository, it could be one of two different types of paths. We'd prefer to use relpaths (relative to the root directory of the virtual repository filesystem) for that stuff, but some legacy code uses fspaths. You'll need to figure out if your code expects repository paths to have a leading '/' or not. If so, they are fspaths; otherwise they are relpaths.</li>
<li>If your path refers only to the path part of URL &ndash; as if someone hacked off the initial schema and hostname portion &ndash; it's a urlpath. To date, the ra_dav modules are the only ones within Subversion that make use of urlpaths, and this is because WebDAV makes heavy use of that form of path specification.</li>
</ul>
<p>When translating between local paths (dirents) and uris code should always go via the relative path format, perhaps by truncating a parent portion from a path with svn_*_skip_ancestor(), or by converting portions to basenames and then joining to existing paths.</p>
<p>SECURITY WARNING: If a path that is received from an untrusted source &ndash; such as from the network &ndash; is converted to a dirent it should be tested with <a class="el" href="svn__dirent__uri_8h.html#a6c1848eecb74dfd34721bd04e025128d" title="Join path onto base_path, checking that path does not attempt to traverse above base_path. ">svn_dirent_is_under_root()</a> before you can assume the path to be a safe local path.</p>
<p>MEMORY ALLOCATION: A function documented as allocating the result in a pool may instead return a static string such as "." or "". If the result is equal to an input, it will duplicate the input. </p>

<p>Definition in file <a class="el" href="svn__dirent__uri_8h_source.html">svn_dirent_uri.h</a>.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="abd1989277bd046113f5a4a04eea47969"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* svn_dirent_basename </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dirent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the name of the specified canonicalized <em>dirent</em> as it is known within its parent directory. </p>
<p>If the <em>dirent</em> is root, return "". The returned value will not have slashes in it.</p>
<p>Example: svn_dirent_basename("/foo/bar") -&gt; "bar"</p>
<p>If <em>result_pool</em> is NULL, return a pointer to the basename in <em>dirent</em>, otherwise allocate the result in <em>result_pool</em>.</p>
<dl class="section note"><dt>Note</dt><dd>If an empty string is passed, then an empty string will be returned.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="a43bc9669a9cd5c241aacd3e120134154"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* svn_dirent_canonicalize </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dirent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new dirent like <em>dirent</em>, but transformed such that some types of dirent specification redundancies are removed. </p>
<p>This involves:</p>
<ul>
<li>collapsing redundant "/./" elements</li>
<li>removing multiple adjacent separator characters</li>
<li>removing trailing separator characters</li>
<li>converting the server name of a UNC path to lower case (on Windows)</li>
<li>converting a drive letter to upper case (on Windows)</li>
</ul>
<p>and possibly other semantically inoperative transformations.</p>
<p>Allocate the result in <em>result_pool</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a class="anchor" id="a8f44342f4caf7ad7abd74ab1a0c9c213"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_dirent_condense_targets </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>pcommon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_array_header_t **&#160;</td>
          <td class="paramname"><em>pcondensed_targets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const apr_array_header_t *&#160;</td>
          <td class="paramname"><em>targets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>remove_redundancies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the common prefix of the canonicalized dirents in <em>targets</em> (an array of <code>const char *</code>'s), and remove redundant dirents if <em>remove_redundancies</em> is TRUE. </p>
<ul>
<li>Set <em>*pcommon</em> to the absolute dirent of the dirent common to all of the targets. If the targets have no common prefix (e.g. "C:/file" and "D:/file" on Windows), set <em>*pcommon</em> to the empty string.</li>
<li>If <em>pcondensed_targets</em> is non-NULL, set <em>*pcondensed_targets</em> to an array of targets relative to <em>*pcommon</em>, and if <em>remove_redundancies</em> is TRUE, omit any dirents that are descendants of another dirent in <em>targets</em>. If *pcommon is empty, <em>*pcondensed_targets</em> will contain absolute dirents; redundancies can still be removed. If <em>pcondensed_targets</em> is NULL, leave it alone.</li>
</ul>
<p>Else if there is exactly one target, then</p>
<ul>
<li>Set <em>*pcommon</em> to that target, and</li>
<li>If <em>pcondensed_targets</em> is non-NULL, set <em>*pcondensed_targets</em> to an array containing zero elements. Else if <em>pcondensed_targets</em> is NULL, leave it alone.</li>
</ul>
<p>If there are no items in <em>targets</em>, set <em>*pcommon</em> and (if applicable) <em>*pcondensed_targets</em> to <code>NULL</code>.</p>
<p>Allocate the results in <em>result_pool</em>. Use <em>scratch_pool</em> for temporary allocations.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="a6642420c9f437098834a4f7151aa3332"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* svn_dirent_dirname </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dirent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the dirname of the specified canonicalized <em>dirent</em>, defined as the dirent with its basename removed. </p>
<p>If <em>dirent</em> is root ("/", "X:/", "//server/share/") or "", it is returned unchanged.</p>
<p>Allocate the result in <em>result_pool</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a class="anchor" id="af2c00a9fd200c14f8768a01e9ffbecf1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_dirent_get_absolute </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>pabsolute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>relative</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert <em>relative</em> canonicalized dirent to an absolute dirent and return the results in <em>*pabsolute</em>. </p>
<p>Raise SVN_ERR_BAD_FILENAME if the absolute dirent cannot be determined.</p>
<p>Allocate the result in <em>result_pool</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a class="anchor" id="a53391740b3d8664cb3865f210821b659"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* svn_dirent_get_longest_ancestor </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dirent1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dirent2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the longest common dirent shared by two canonicalized dirents, <em>dirent1</em> and <em>dirent2</em>. </p>
<p>If there's no common ancestor, return the empty path.</p>
<p>Allocate the result in <em>result_pool</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a class="anchor" id="a675354133cf6e25d3e1cbe6a0f7069e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* svn_dirent_internal_style </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dirent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert <em>dirent</em> from the local style to the canonical internal style. </p>
<p>"Local style" means native path separators and "." for the empty path.</p>
<p>Allocate the result in <em>result_pool</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a class="anchor" id="aafc765f2a1baead8e8489e02726b50f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> svn_dirent_is_absolute </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dirent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return TRUE if <em>dirent</em> is considered absolute on the platform at hand. </p>
<p>E.g. '/foo' on Posix platforms or 'X:/foo', '//server/share/foo' on Windows.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a class="anchor" id="a65b2f9504ab294d22f8067ea0046151a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> svn_dirent_is_ancestor </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>parent_dirent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>child_dirent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return TRUE if <em>parent_dirent</em> is an ancestor of <em>child_dirent</em> or the dirents are equal, and FALSE otherwise. </p>
<h3>TODO: Deprecate, as the semantics are trivially</h3>
<p>obtainable from *_skip_ancestor().</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a class="anchor" id="a401b8232b2fe7173cb62f2fbdf06c56e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> svn_dirent_is_canonical </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dirent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>TRUE</code> iff <em>dirent</em> is canonical. </p>
<p>Use <em>scratch_pool</em> for temporary allocations.</p>
<dl class="section note"><dt>Note</dt><dd>The test for canonicalization is currently defined as "looks exactly the same as @c svn_dirent_canonicalize() would make
it look".</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="svn__dirent__uri_8h.html#a43bc9669a9cd5c241aacd3e120134154" title="Return a new dirent like dirent, but transformed such that some types of dirent specification redunda...">svn_dirent_canonicalize()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a class="anchor" id="af12399fefc5245c9b729d0a2f4fbe981"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* svn_dirent_is_child </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>parent_dirent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>child_dirent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="svn__dirent__uri_8h.html#a43120221527224b1e161e70f6608f746" title="Return the relative path part of child_dirent that is below parent_dirent, or just &quot;&quot; if parent_diren...">svn_dirent_skip_ancestor()</a>, except that if <em>child_dirent</em> is the same as <em>parent_dirent</em>, it is not considered a child, so the result is <code>NULL</code>; an empty string is never returned. </p>
<p>If <em>result_pool</em> is NULL, return a pointer into <em>child_dirent</em>, otherwise allocate the result in <em>result_pool</em>.</p>
<h3>TODO: Deprecate, as the semantics are trivially</h3>
<p>obtainable from *_skip_ancestor().</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a class="anchor" id="ab28eb607dfb4fe7137b2e633f9e0604f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> svn_dirent_is_root </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dirent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return TRUE if <em>dirent</em> is considered a root directory on the platform at hand. </p>
<p>E.g.: On Posix: '/' On Windows: '/', 'X:/', '//server/share', 'X:'</p>
<p>Note that on Windows '/' and 'X:' are roots, but paths starting with this root are not absolute.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="a6c1848eecb74dfd34721bd04e025128d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_dirent_is_under_root </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *&#160;</td>
          <td class="paramname"><em>under_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>result_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>base_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join <em>path</em> onto <em>base_path</em>, checking that <em>path</em> does not attempt to traverse above <em>base_path</em>. </p>
<p>If <em>path</em> or any ".." component within it resolves to a path above <em>base_path</em>, or if <em>path</em> is an absolute path, then set <em>*under_root</em> to <code>FALSE</code>. Otherwise, set <em>*under_root</em> to <code>TRUE</code> and, if <em>result_path</em> is not <code>NULL</code>, set <em>*result_path</em> to the resulting path.</p>
<p><em>path</em> need not be canonical. <em>base_path</em> must be canonical and <em>*result_path</em> will be canonical.</p>
<p>Allocate the result in <em>result_pool</em>.</p>
<dl class="section note"><dt>Note</dt><dd>Use of this function is strongly encouraged. Do not roll your own. (<a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=2007-3846">http://cve.mitre.org/cgi-bin/cvename.cgi?name=2007-3846</a>)</dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="aa0ad2bf82642cff7d65c8310868be834"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* svn_dirent_join </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join a base dirent (<em>base</em>) with a component (<em>component</em>). </p>
<p>If either <em>base</em> or <em>component</em> is the empty string, then the other argument will be copied and returned. If both are the empty string then empty string is returned.</p>
<p>If the <em>component</em> is an absolute dirent, then it is copied and returned. The platform specific rules for joining paths are used to join the components.</p>
<p>This function is NOT appropriate for native (local) file dirents. Only for "internal" canonicalized dirents, since it uses '/' for the separator.</p>
<p>Allocate the result in <em>result_pool</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a class="anchor" id="a9cc91f8e99a171e7ec4becffdc023901"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* svn_dirent_join_many </td>
          <td>(</td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join multiple components onto a <em>base</em> dirent. </p>
<p>The components are terminated by a <code>NULL</code>.</p>
<p>If any component is the empty string, it will be ignored.</p>
<p>If any component is an absolute dirent, then it resets the base and further components will be appended to it.</p>
<p>See <a class="el" href="svn__dirent__uri_8h.html#aa0ad2bf82642cff7d65c8310868be834" title="Join a base dirent (base) with a component (component). ">svn_dirent_join()</a> for further notes about joining dirents.</p>
<p>Allocate the result in <em>result_pool</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a class="anchor" id="ace26b3b96a2cb6e56fed9a7a288d2b20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* svn_dirent_local_style </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dirent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert <em>dirent</em> from the internal style to the local style. </p>
<p>"Local style" means native path separators and "." for the empty path. If the input is not canonical, the output may not be canonical.</p>
<p>Allocate the result in <em>result_pool</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a class="anchor" id="a43120221527224b1e161e70f6608f746"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* svn_dirent_skip_ancestor </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>parent_dirent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>child_dirent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the relative path part of <em>child_dirent</em> that is below <em>parent_dirent</em>, or just "" if <em>parent_dirent</em> is equal to <em>child_dirent</em>. </p>
<p>If <em>child_dirent</em> is not below or equal to <em>parent_dirent</em>, return NULL.</p>
<p>If one of <em>parent_dirent</em> and <em>child_dirent</em> is absolute and the other relative, return NULL.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="aa953a9310560da25358de9ef3621545c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_dirent_split </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>dirpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>base_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dirent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divide the canonicalized <em>dirent</em> into <em>*dirpath</em> and <em>*base_name</em>. </p>
<p>If <em>dirpath</em> or <em>base_name</em> is NULL, then don't set that one.</p>
<p>Either <em>dirpath</em> or <em>base_name</em> may be <em>dirent's</em> own address, but they may not both be the same address, or the results are undefined.</p>
<p>If <em>dirent</em> has two or more components, the separator between <em>dirpath</em> and <em>base_name</em> is not included in either of the new names.</p>
<p>Examples:</p>
<ul>
<li><pre>"/foo/bar/baz"  ==&gt;  "/foo/bar" and "baz"</pre></li>
<li><pre>"/bar"          ==&gt;  "/"  and "bar"</pre></li>
<li><pre>"/"             ==&gt;  "/"  and ""</pre></li>
<li><pre>"bar"           ==&gt;  ""   and "bar"</pre></li>
<li><pre>""              ==&gt;  ""   and ""</pre> Windows: - <pre>"X:/"           ==&gt;  "X:/" and ""</pre></li>
<li><pre>"X:/foo"        ==&gt;  "X:/" and "foo"</pre></li>
<li><pre>"X:foo"         ==&gt;  "X:" and "foo"</pre> Posix: - <pre>"X:foo"         ==&gt;  ""   and "X:foo"</pre></li>
</ul>
<p>Allocate the results in <em>result_pool</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="a5853024ba08f8671c6fec0146b10d721"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* svn_relpath__internal_style </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>relpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert <em>relpath</em> from the local style to the canonical internal style. </p>
<p>"Local style" means native path separators and "." for the empty path.</p>
<p>Allocate the result in <em>result_pool</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="a87096512213d2540a40f62c66f52f4c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* svn_relpath_basename </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>relpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the basename of the specified canonicalized <em>relpath</em>. </p>
<p>The basename is defined as the last component of the relpath. If the <em>relpath</em> has only one component then that is returned. The returned value will have no slashes in it.</p>
<p>Example: svn_relpath_basename("/trunk/foo/bar") -&gt; "bar"</p>
<p>If <em>result_pool</em> is NULL, return a pointer to the basename in <em>relpath</em>, otherwise allocate the result in <em>result_pool</em>.</p>
<dl class="section note"><dt>Note</dt><dd>If an empty string is passed, then an empty string will be returned.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="a6fd34d4c169df9722f03dd6e499a07ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* svn_relpath_canonicalize </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>relpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new relpath like <em>relpath</em>, but transformed such that some types of relpath specification redundancies are removed. </p>
<p>This involves:</p>
<ul>
<li>collapsing redundant "/./" elements</li>
<li>removing multiple adjacent separator characters</li>
<li>removing trailing separator characters</li>
</ul>
<p>and possibly other semantically inoperative transformations.</p>
<p>Allocate the result in <em>result_pool</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="ab66fa16ca5787b158939e9e8e9f171cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* svn_relpath_dirname </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>relpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the dirname of the specified canonicalized <em>relpath</em>, defined as the relpath with its basename removed. </p>
<p>If <em>relpath</em> is empty, "" is returned.</p>
<p>Allocate the result in <em>result_pool</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="ae8480880f4d8de50c24baf434f076b83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* svn_relpath_get_longest_ancestor </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>relpath1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>relpath2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the longest common path shared by two relative paths, <em>relpath1</em> and <em>relpath2</em>. </p>
<p>If there's no common ancestor, return the empty path.</p>
<p>Allocate the result in <em>result_pool</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="ac552be30e9f2c8a500d1685be8898f2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> svn_relpath_is_canonical </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>relpath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>TRUE</code> iff <em>relpath</em> is canonical. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="svn__dirent__uri_8h.html#a6fd34d4c169df9722f03dd6e499a07ea" title="Return a new relpath like relpath, but transformed such that some types of relpath specification redu...">svn_relpath_canonicalize()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="a8ea93c789655a35d683bf3b2e29d626c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* svn_relpath_join </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join a base relpath (<em>base</em>) with a component (<em>component</em>). </p>
<p><em>component</em> need not be a single component.</p>
<p>If either <em>base</em> or <em>component</em> is the empty path, then the other argument will be copied and returned. If both are the empty path the empty path is returned.</p>
<p>Allocate the result in <em>result_pool</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="a38f246ac90c84c2d2ad68f9a473d2b46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* svn_relpath_skip_ancestor </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>parent_relpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>child_relpath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the relative path part of <em>child_relpath</em> that is below <em>parent_relpath</em>, or just "" if <em>parent_relpath</em> is equal to <em>child_relpath</em>. </p>
<p>If <em>child_relpath</em> is not below <em>parent_relpath</em>, return NULL.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="ae785b4fb4290096d50a2dc9323a97aa4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_relpath_split </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>dirpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>base_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>relpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divide the canonicalized <em>relpath</em> into <em>*dirpath</em> and <em>*base_name</em>. </p>
<p>If <em>dirpath</em> or <em>base_name</em> is NULL, then don't set that one.</p>
<p>Either <em>dirpath</em> or <em>base_name</em> may be <em>relpaths's</em> own address, but they may not both be the same address, or the results are undefined.</p>
<p>If <em>relpath</em> has two or more components, the separator between <em>dirpath</em> and <em>base_name</em> is not included in either of the new names.</p>
<p>examples:</p>
<ul>
<li><pre>"foo/bar/baz"  ==&gt;  "foo/bar" and "baz"</pre></li>
<li><pre>"bar"          ==&gt;  ""  and "bar"</pre></li>
<li><pre>""              ==&gt;  ""   and ""</pre></li>
</ul>
<p>Allocate the results in <em>result_pool</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="aaff6a95bb7cb4b01f509a3a20068203b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* svn_uri_basename </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the (URI-decoded) basename of the specified canonicalized <em>uri</em>. </p>
<p>The basename is defined as the last component of the uri. If the <em>uri</em> is root, return "". The returned value will have no slashes in it.</p>
<p>Example: svn_uri_basename("http://server/foo/bar") -&gt; "bar"</p>
<p>Allocate the result in <em>result_pool</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="a624e026e7bdd426d063435b87db2b103"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* svn_uri_canonicalize </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new uri like <em>uri</em>, but transformed such that some types of uri specification redundancies are removed. </p>
<p>This involves:</p>
<ul>
<li>collapsing redundant "/./" elements</li>
<li>removing multiple adjacent separator characters</li>
<li>removing trailing separator characters</li>
<li>normalizing the escaping of the path component by unescaping characters that don't need escaping and escaping characters that do need escaping but weren't</li>
<li>removing the port number if it is the default port number (80 for http, 443 for https, 3690 for svn)</li>
</ul>
<p>and possibly other semantically inoperative transformations.</p>
<p>Allocate the result in <em>result_pool</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="a1b41445fe57a14f5866d6c040536f931"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_uri_condense_targets </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>pcommon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_array_header_t **&#160;</td>
          <td class="paramname"><em>pcondensed_targets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const apr_array_header_t *&#160;</td>
          <td class="paramname"><em>targets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>remove_redundancies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the common prefix of the canonicalized uris in <em>targets</em> (an array of <code>const char *</code>'s), and remove redundant uris if <em>remove_redundancies</em> is TRUE. </p>
<ul>
<li>Set <em>*pcommon</em> to the common base uri of all of the targets. If the targets have no common prefix (e.g. "http://srv1/file" and "http://srv2/file"), set <em>*pcommon</em> to the empty string.</li>
<li>If <em>pcondensed_targets</em> is non-NULL, set <em>*pcondensed_targets</em> to an array of URI-decoded targets relative to <em>*pcommon</em>, and if <em>remove_redundancies</em> is TRUE, omit any uris that are descendants of another uri in <em>targets</em>. If *pcommon is empty, <em>*pcondensed_targets</em> will contain absolute uris; redundancies can still be removed. If <em>pcondensed_targets</em> is NULL, leave it alone.</li>
</ul>
<p>Else if there is exactly one target, then</p>
<ul>
<li>Set <em>*pcommon</em> to that target, and</li>
<li>If <em>pcondensed_targets</em> is non-NULL, set <em>*pcondensed_targets</em> to an array containing zero elements. Else if <em>pcondensed_targets</em> is NULL, leave it alone.</li>
</ul>
<p>If there are no items in <em>targets</em>, set <em>*pcommon</em> and (if applicable) <em>*pcondensed_targets</em> to <code>NULL</code>.</p>
<p>Allocate the results in <em>result_pool</em>. Use <em>scratch_pool</em> for temporary allocations.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="a6afeca29c5c55e1dafb6640d89505533"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* svn_uri_dirname </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the dirname of the specified canonicalized <em>uri</em>, defined as the uri with its basename removed. </p>
<p>If <em>uri</em> is root (e.g. "http://server"), it is returned unchanged.</p>
<p>Allocate the result in <em>result_pool</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="a5054bb84b11206bcf99dbdb6b06480d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_uri_get_dirent_from_file_url </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>dirent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>*dirent</em> to the path corresponding to the <a href="file://">file://</a> URL <em>url</em>, using the platform-specific <a href="file://">file://</a> rules. </p>
<p>Allocate the result in <em>result_pool</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="a2cb12ae63411fb60bd9505fd2c2ed7b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_uri_get_file_url_from_dirent </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dirent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>*url</em> to a <a href="file://">file://</a> URL, corresponding to <em>dirent</em> using the platform specific dirent and <a href="file://">file://</a> rules. </p>
<p>Allocate the result in <em>result_pool</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="a223335146fbf57d59114466bf686132d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* svn_uri_get_longest_ancestor </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>uri1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>uri2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the longest common path shared by two canonicalized uris, <em>uri1</em> and <em>uri2</em>. </p>
<p>If there's no common ancestor, return the empty path. In order for two URLs to have a common ancestor, they must (a) have the same protocol (since two URLs with the same path but different protocols may point at completely different resources), and (b) share a common ancestor in their path component, i.e. 'protocol://' is not a sufficient ancestor.</p>
<p>Allocate the result in <em>result_pool</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="a82bfff97a7826720fdb864edd96d8012"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> svn_uri_is_canonical </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>TRUE</code> iff <em>uri</em> is canonical. </p>
<p>Use <em>scratch_pool</em> for temporary allocations.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="svn__dirent__uri_8h.html#a624e026e7bdd426d063435b87db2b103" title="Return a new uri like uri, but transformed such that some types of uri specification redundancies are...">svn_uri_canonicalize()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="ad425a70a4400dd8e62c727a53a436439"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> svn_uri_is_root </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return TRUE if <em>uri</em> is a root URL (e.g., "http://server"). </p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7 </dd></dl>

</div>
</div>
<a class="anchor" id="a2f060989ec00f710dce15f9668c5d6db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* svn_uri_skip_ancestor </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>parent_uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>child_uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the URI-decoded relative path of <em>child_uri</em> that is below <em>parent_uri</em>, or just "" if <em>parent_uri</em> is equal to <em>child_uri</em>. </p>
<p>If <em>child_uri</em> is not below <em>parent_uri</em>, return NULL.</p>
<p>Allocate the result in <em>result_pool</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="a1738f95947423b71ec6b304cbfaf5417"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_uri_split </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>dirpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>base_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divide the canonicalized <em>uri</em> into a uri <em>*dirpath</em> and a (URI-decoded) relpath <em>*base_name</em>. </p>
<p>If <em>dirpath</em> or <em>base_name</em> is NULL, then don't set that one.</p>
<p>Either <em>dirpath</em> or <em>base_name</em> may be <em>uri's</em> own address, but they may not both be the same address, or the results are undefined.</p>
<p>If <em>uri</em> has two or more components, the separator between <em>dirpath</em> and <em>base_name</em> is not included in either of the new names.</p>
<p>Examples:</p>
<ul>
<li><pre>"http://server/foo/bar"  ==&gt;  "http://server/foo" and "bar"</pre></li>
</ul>
<p>Allocate the result in <em>result_pool</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Aug 19 2015 09:37:23 for Subversion by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
