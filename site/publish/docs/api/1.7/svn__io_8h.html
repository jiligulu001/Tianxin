<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Subversion: svn_io.h File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Subversion
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">svn_io.h File Reference</div>  </div>
</div>
<div class="contents">

<p>General file I/O for Subversion.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;apr.h&gt;</code><br/>
<code>#include &lt;apr_pools.h&gt;</code><br/>
<code>#include &lt;apr_time.h&gt;</code><br/>
<code>#include &lt;apr_hash.h&gt;</code><br/>
<code>#include &lt;apr_tables.h&gt;</code><br/>
<code>#include &lt;apr_file_io.h&gt;</code><br/>
<code>#include &lt;apr_file_info.h&gt;</code><br/>
<code>#include &lt;apr_thread_proc.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="svn__types_8h_source.html">svn_types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="svn__string_8h_source.html">svn_string.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="svn__checksum_8h_source.html">svn_checksum.h</a>&quot;</code><br/>
</div>
<p><a href="svn__io_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__io__dirent2__t.html">svn_io_dirent2_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of directory entry data elements as returned by svn_io_get_dirents.  <a href="structsvn__io__dirent2__t.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__io__dirent__t.html">svn_io_dirent_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the kind and special status of a directory entry.  <a href="structsvn__io__dirent__t.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="svn__io_8h.html#aa78fffc81af962281813070c753d7884">svn_io_file_del_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a1ed9ee9548db02f141509f4e08df0827">svn_io_file_del_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Used as an argument when creating temporary files to indicate when a file should be removed.  <a href="#a1ed9ee9548db02f141509f4e08df0827"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structsvn__io__dirent2__t.html">svn_io_dirent2_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a0900f4459a5ef43cb1634d3b89d829a4">svn_io_dirent2_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of directory entry data elements as returned by svn_io_get_dirents.  <a href="#a0900f4459a5ef43cb1634d3b89d829a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structsvn__io__dirent__t.html">svn_io_dirent_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#af9f5d05db9c9a8f513615e4ec2caf5b2">svn_io_dirent_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the kind and special status of a directory entry.  <a href="#af9f5d05db9c9a8f513615e4ec2caf5b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract stream of bytes--either incoming or outgoing or both.  <a href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga9a8939b5258b070a48aa1e0cd154909a">svn_read_fn_t</a> )(void *baton, char *buffer, apr_size_t *len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read handler function for a generic stream.  <a href="group__svn__io__byte__streams.html#ga9a8939b5258b070a48aa1e0cd154909a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga2c0bc2f0ebff96271f427013fece2a39">svn_stream_skip_fn_t</a> )(void *baton, apr_size_t len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip data handler function for a generic stream.  <a href="group__svn__io__byte__streams.html#ga2c0bc2f0ebff96271f427013fece2a39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gaa79398b116a9209eb3a79947a6066f54">svn_write_fn_t</a> )(void *baton, const char *data, apr_size_t *len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write handler function for a generic stream.  <a href="group__svn__io__byte__streams.html#gaa79398b116a9209eb3a79947a6066f54"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga576facc62f51e98c14cb440df1e58cd9">svn_close_fn_t</a> )(void *baton)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Close handler function for a generic stream.  <a href="group__svn__io__byte__streams.html#ga576facc62f51e98c14cb440df1e58cd9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__svn__io__byte__streams.html#gaca2f3b74a1215c13b5ae2ca3b99437b9">svn_stream_mark_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gaca2f3b74a1215c13b5ae2ca3b99437b9">svn_stream_mark_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque type which represents a mark on a stream.  <a href="group__svn__io__byte__streams.html#gaca2f3b74a1215c13b5ae2ca3b99437b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gaf811477b7cafa3c5c20cb3428976d0be">svn_stream_mark_fn_t</a> )(void *baton, <a class="el" href="group__svn__io__byte__streams.html#gaca2f3b74a1215c13b5ae2ca3b99437b9">svn_stream_mark_t</a> **mark, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark handler function for a generic stream.  <a href="group__svn__io__byte__streams.html#gaf811477b7cafa3c5c20cb3428976d0be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gaa5291159cc874084805155ccdfd68b4b">svn_stream_seek_fn_t</a> )(void *baton, const <a class="el" href="group__svn__io__byte__streams.html#gaca2f3b74a1215c13b5ae2ca3b99437b9">svn_stream_mark_t</a> *mark)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek handler function for a generic stream.  <a href="group__svn__io__byte__streams.html#gaa5291159cc874084805155ccdfd68b4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3dd33688b3e75430f4720f4d90c1506"></a><!-- doxytag: member="svn_io.h::svn_io_walk_func_t" ref="ae3dd33688b3e75430f4720f4d90c1506" args=")(void *baton, const char *path, const apr_finfo_t *finfo, apr_pool_t *pool)" -->
typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#ae3dd33688b3e75430f4720f4d90c1506">svn_io_walk_func_t</a> )(void *baton, const char *path, const apr_finfo_t *finfo, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function type for <a class="el" href="svn__io_8h.html#acac394a2c49dcfb02b8cda55c9281625" title="Similar to svn_io_dir_walk(), but only calls walk_func for files of type APR_DIR (directory) and APR_...">svn_io_dir_walk()</a> <br/></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#aa78fffc81af962281813070c753d7884">svn_io_file_del_t</a> { <br/>
&#160;&#160;<a class="el" href="svn__io_8h.html#aa78fffc81af962281813070c753d7884a70268318a6e388419ae0e85ab7f7599c">svn_io_file_del_none</a> =  0, 
<br/>
&#160;&#160;<a class="el" href="svn__io_8h.html#aa78fffc81af962281813070c753d7884a6256344ca6b43868daa12365d75834d2">svn_io_file_del_on_close</a>, 
<br/>
&#160;&#160;<a class="el" href="svn__io_8h.html#aa78fffc81af962281813070c753d7884a0f89c57067b563673ea1ec5605c908bd">svn_io_file_del_on_pool_cleanup</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Used as an argument when creating temporary files to indicate when a file should be removed.  <a href="svn__io_8h.html#aa78fffc81af962281813070c753d7884">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__io__dirent2__t.html">svn_io_dirent2_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a48ca8a48714c0353e1246e992def863b">svn_io_dirent2_create</a> (apr_pool_t *result_pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="structsvn__io__dirent2__t.html" title="A set of directory entry data elements as returned by svn_io_get_dirents.">svn_io_dirent2_t</a> structure.  <a href="#a48ca8a48714c0353e1246e992def863b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__io__dirent2__t.html">svn_io_dirent2_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a4373588a310c126338eee38f6fa8f67c">svn_io_dirent2_dup</a> (const <a class="el" href="structsvn__io__dirent2__t.html">svn_io_dirent2_t</a> *item, apr_pool_t *result_pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicates a <code><a class="el" href="structsvn__io__dirent2__t.html" title="A set of directory entry data elements as returned by svn_io_get_dirents.">svn_io_dirent2_t</a></code> structure into <em>result_pool</em>.  <a href="#a4373588a310c126338eee38f6fa8f67c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a31ee1827a2b62a2f4a122ef18e378b05">svn_io_check_path</a> (const char *path, <a class="el" href="svn__types_8h.html#ac3ca125707a8ca1289c73236b5ce7f9a">svn_node_kind_t</a> *kind, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the <em>kind</em> of <em>path</em>.  <a href="#a31ee1827a2b62a2f4a122ef18e378b05"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a0f8fdad8dc4fe854ef5b9971f8ab043e">svn_io_check_special_path</a> (const char *path, <a class="el" href="svn__types_8h.html#ac3ca125707a8ca1289c73236b5ce7f9a">svn_node_kind_t</a> *kind, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *is_special, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="svn__io_8h.html#a31ee1827a2b62a2f4a122ef18e378b05" title="Determine the kind of path.">svn_io_check_path()</a>, but also set *is_special to <code>TRUE</code> if the path is not a normal file.  <a href="#a0f8fdad8dc4fe854ef5b9971f8ab043e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a47336875b45ac006d69aef58db4fb5bb">svn_io_check_resolved_path</a> (const char *path, <a class="el" href="svn__types_8h.html#ac3ca125707a8ca1289c73236b5ce7f9a">svn_node_kind_t</a> *kind, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="svn__io_8h.html#a31ee1827a2b62a2f4a122ef18e378b05" title="Determine the kind of path.">svn_io_check_path()</a>, but resolve symlinks.  <a href="#a47336875b45ac006d69aef58db4fb5bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a280a68283cb7852fe1f4c5835f0b8fdf">svn_io_open_uniquely_named</a> (apr_file_t **file, const char **unique_name, const char *dirpath, const char *filename, const char *suffix, <a class="el" href="svn__io_8h.html#aa78fffc81af962281813070c753d7884">svn_io_file_del_t</a> delete_when, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a new file (for reading and writing) with a unique name based on utf-8 encoded <em>filename</em>, in the directory <em>dirpath</em>.  <a href="#a280a68283cb7852fe1f4c5835f0b8fdf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#ad1a7a7299bfe130c25becdd56ff0e870">svn_io_open_unique_file3</a> (apr_file_t **file, const char **temp_path, const char *dirpath, <a class="el" href="svn__io_8h.html#aa78fffc81af962281813070c753d7884">svn_io_file_del_t</a> delete_when, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a writable file, with an arbitrary and unique name, in the directory <em>dirpath</em>.  <a href="#ad1a7a7299bfe130c25becdd56ff0e870"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a58df63b2898a8a2a7df988b2d633eb1a">svn_io_open_unique_file2</a> (apr_file_t **f, const char **unique_name_p, const char *path, const char *suffix, <a class="el" href="svn__io_8h.html#aa78fffc81af962281813070c753d7884">svn_io_file_del_t</a> delete_when, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="svn__io_8h.html#a280a68283cb7852fe1f4c5835f0b8fdf" title="Open a new file (for reading and writing) with a unique name based on utf-8 encoded filename...">svn_io_open_uniquely_named()</a>, but takes a joined dirpath and filename, and a single pool.  <a href="#a58df63b2898a8a2a7df988b2d633eb1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a2384857ad348105316edf6d1036d599f">svn_io_open_unique_file</a> (apr_file_t **f, const char **unique_name_p, const char *path, const char *suffix, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> delete_on_close, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Like svn_io_open_unique_file2, but can't delete on pool cleanup.  <a href="#a2384857ad348105316edf6d1036d599f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#ad11db24f003c6f280e39d3c9675280dc">svn_io_create_unique_link</a> (const char **unique_name_p, const char *path, const char *dest, const char *suffix, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="svn__io_8h.html#a2384857ad348105316edf6d1036d599f" title="Like svn_io_open_unique_file2, but can&#39;t delete on pool cleanup.">svn_io_open_unique_file()</a>, except that instead of creating a file, a symlink is generated that references the path <em>dest</em>.  <a href="#ad11db24f003c6f280e39d3c9675280dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a94e184ae6677e8b0b4cae0ec145b7b67">svn_io_read_link</a> (<a class="el" href="structsvn__string__t.html">svn_string_t</a> **dest, const char *path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*dest</em> to the path that the symlink at <em>path</em> references.  <a href="#a94e184ae6677e8b0b4cae0ec145b7b67"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afbb4b86585411439008e934ede6f8b39"></a><!-- doxytag: member="svn_io.h::svn_io_temp_dir" ref="afbb4b86585411439008e934ede6f8b39" args="(const char **dir, apr_pool_t *pool)" -->
<a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#afbb4b86585411439008e934ede6f8b39">svn_io_temp_dir</a> (const char **dir, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*dir</em> to a directory path (allocated in <em>pool</em>) deemed usable for the creation of temporary files and subdirectories. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#ab4a3b25a089372c59aca6783a3a31595">svn_io_copy_file</a> (const char *src, const char *dst, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> copy_perms, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy <em>src</em> to <em>dst</em> atomically, in a "byte-for-byte" manner.  <a href="#ab4a3b25a089372c59aca6783a3a31595"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a1c80cac675b5711e2c2c3e4aa6b4fbb1">svn_io_copy_perms</a> (const char *src, const char *dst, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy permission flags from <em>src</em> onto the file at <em>dst</em>.  <a href="#a1c80cac675b5711e2c2c3e4aa6b4fbb1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a539dc0c726940a466a3bc2358d6b85d8">svn_io_copy_link</a> (const char *src, const char *dst, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy symbolic link <em>src</em> to <em>dst</em> atomically.  <a href="#a539dc0c726940a466a3bc2358d6b85d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#afcaeff1ea5e9ae65c8188678a1e042bf">svn_io_copy_dir_recursively</a> (const char *src, const char *dst_parent, const char *dst_basename, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> copy_perms, <a class="el" href="svn__types_8h.html#addaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a> cancel_func, void *cancel_baton, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively copy directory <em>src</em> into <em>dst_parent</em>, as a new entry named <em>dst_basename</em>.  <a href="#afcaeff1ea5e9ae65c8188678a1e042bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a0ef4d0c5c6a86ab48f515b4a31efad70">svn_io_make_dir_recursively</a> (const char *path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create directory <em>path</em> on the file system, creating intermediate directories as required, like <code>mkdir -p</code>.  <a href="#a0ef4d0c5c6a86ab48f515b4a31efad70"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#acea0b7ecaacd02da03a5cfaebe27067a">svn_io_dir_empty</a> (<a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *is_empty_p, const char *path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*is_empty_p</em> to <code>TRUE</code> if directory <em>path</em> is empty, else to <code>FALSE</code> if it is not empty.  <a href="#acea0b7ecaacd02da03a5cfaebe27067a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a967781b8e5991f3c72f125a333661d1b">svn_io_append_file</a> (const char *src, const char *dst, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Append <em>src</em> to <em>dst</em>.  <a href="#a967781b8e5991f3c72f125a333661d1b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a185f4ee690965e622aa1748339847ae5">svn_io_set_file_read_only</a> (const char *path, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> ignore_enoent, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a file as read-only as the operating system allows.  <a href="#a185f4ee690965e622aa1748339847ae5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#ac407a16bc12b63d2e57a3e2375490ad5">svn_io_set_file_read_write</a> (const char *path, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> ignore_enoent, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a file as writable as the operating system allows.  <a href="#ac407a16bc12b63d2e57a3e2375490ad5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a02cd461341834d955e258a70def4f56f">svn_io_set_file_read_write_carefully</a> (const char *path, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> enable_write, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> ignore_enoent, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to svn_io_set_file_read_* functions.  <a href="#a02cd461341834d955e258a70def4f56f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a358a735a173b43509cf4060b73930cf5">svn_io_set_file_executable</a> (const char *path, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> executable, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> ignore_enoent, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>path's</em> "executability" (but do nothing if it is a symlink).  <a href="#a358a735a173b43509cf4060b73930cf5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a2cb981f75792c99480f93b83ae9265d2">svn_io_is_file_executable</a> (<a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *executable, const char *path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a file is executable by the current user.  <a href="#a2cb981f75792c99480f93b83ae9265d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#ab3f73a4554d78dbbc3d9e0f29943380e">svn_io_read_length_line</a> (apr_file_t *file, char *buf, apr_size_t *limit, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a line from <em>file</em> into <em>buf</em>, but not exceeding <em>*limit</em> bytes.  <a href="#ab3f73a4554d78dbbc3d9e0f29943380e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#ae9ed0a769c24087316ebcc868fb559a0">svn_io_file_affected_time</a> (apr_time_t *apr_time, const char *path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*apr_time</em> to the time of last modification of the contents of the file <em>path</em>.  <a href="#ae9ed0a769c24087316ebcc868fb559a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a474cc5427ee6e900ff8c96559e368fe6">svn_io_set_file_affected_time</a> (apr_time_t apr_time, const char *path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the timestamp of file <em>path</em> to <em>apr_time</em>.  <a href="#a474cc5427ee6e900ff8c96559e368fe6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a07a20fcb725f0941e6c53410ad5c12e4">svn_io_sleep_for_timestamps</a> (const char *path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleep to ensure that any files modified after we exit have a different timestamp than the one we recorded.  <a href="#a07a20fcb725f0941e6c53410ad5c12e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a759d9be046832ba2e1f8d5408a7023d1">svn_io_filesizes_different_p</a> (<a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *different_p, const char *file1, const char *file2, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*different_p</em> to non-zero if <em>file1</em> and <em>file2</em> have different sizes, else set to zero.  <a href="#a759d9be046832ba2e1f8d5408a7023d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#aa9bee2a2151cc7c57e9a01003dc6d2b6">svn_io_file_checksum2</a> (<a class="el" href="structsvn__checksum__t.html">svn_checksum_t</a> **checksum, const char *file, <a class="el" href="svn__checksum_8h.html#a7a6c373d03d7e6ec6b832a039f5e0aa1">svn_checksum_kind_t</a> kind, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return in <em>*checksum</em> the checksum of type <em>kind</em> of <em>file</em> Use <em>pool</em> for temporary allocations and to allocate <em>*checksum</em>.  <a href="#aa9bee2a2151cc7c57e9a01003dc6d2b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#ad7384374afef049adcc8485de4083186">svn_io_file_checksum</a> (unsigned char digest[], const char *file, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the md5 checksum of <em>file</em> into <em>digest</em>.  <a href="#ad7384374afef049adcc8485de4083186"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#ac3ddb92f73a78796c75a0790bc9cf727">svn_io_files_contents_same_p</a> (<a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *same, const char *file1, const char *file2, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*same</em> to TRUE if <em>file1</em> and <em>file2</em> have the same contents, else set it to FALSE.  <a href="#ac3ddb92f73a78796c75a0790bc9cf727"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a36cd10dc8fb91f40c0df79edf8fc3a18">svn_io_file_create</a> (const char *file, const char *contents, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create file at utf8-encoded <em>file</em> with contents <em>contents</em>.  <a href="#a36cd10dc8fb91f40c0df79edf8fc3a18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a98ada015dbb0b5d467375edba000dd4b">svn_io_file_lock</a> (const char *lock_file, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> exclusive, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock file at <em>lock_file</em>.  <a href="#a98ada015dbb0b5d467375edba000dd4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a256b06e01a023d03c47e8a29f8a0344a">svn_io_file_lock2</a> (const char *lock_file, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> exclusive, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> nonblocking, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock file at <em>lock_file</em>.  <a href="#a256b06e01a023d03c47e8a29f8a0344a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a1738477996c854ac51fbd77cccaddfb5">svn_io_file_flush_to_disk</a> (apr_file_t *file, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush any unwritten data from <em>file</em> to disk.  <a href="#a1738477996c854ac51fbd77cccaddfb5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#ae6c6d960b1f742e2c00f8d7dd6ea1c5d">svn_io_dir_file_copy</a> (const char *src_path, const char *dest_path, const char *file, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the file whose basename (or relative path) is <em>file</em> within directory <em>src_path</em> to the same basename (or relative path) within directory <em>dest_path</em>.  <a href="#ae6c6d960b1f742e2c00f8d7dd6ea1c5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gadc3e897290c9479c6b903876d18dc87c">svn_stream_create</a> (void *baton, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a generic stream.  <a href="group__svn__io__byte__streams.html#gadc3e897290c9479c6b903876d18dc87c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0ff601f7fb4a7c8c92770edd7376b052"></a><!-- doxytag: member="svn_io.h::svn_stream_set_baton" ref="ga0ff601f7fb4a7c8c92770edd7376b052" args="(svn_stream_t *stream, void *baton)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga0ff601f7fb4a7c8c92770edd7376b052">svn_stream_set_baton</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, void *baton)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>stream's</em> baton to <em>baton</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae9ebdcf950b897d9c0cb89c331262aed"></a><!-- doxytag: member="svn_io.h::svn_stream_set_read" ref="gae9ebdcf950b897d9c0cb89c331262aed" args="(svn_stream_t *stream, svn_read_fn_t read_fn)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gae9ebdcf950b897d9c0cb89c331262aed">svn_stream_set_read</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, <a class="el" href="group__svn__io__byte__streams.html#ga9a8939b5258b070a48aa1e0cd154909a">svn_read_fn_t</a> read_fn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>stream's</em> read function to <em>read_fn</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gaf834f41616e68fa7d0214814a56b81d4">svn_stream_set_skip</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, <a class="el" href="group__svn__io__byte__streams.html#ga2c0bc2f0ebff96271f427013fece2a39">svn_stream_skip_fn_t</a> skip_fn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>stream's</em> skip function to <em>skip_fn</em>.  <a href="group__svn__io__byte__streams.html#gaf834f41616e68fa7d0214814a56b81d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaea19e182974e64a77d3f949a25f496a1"></a><!-- doxytag: member="svn_io.h::svn_stream_set_write" ref="gaea19e182974e64a77d3f949a25f496a1" args="(svn_stream_t *stream, svn_write_fn_t write_fn)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gaea19e182974e64a77d3f949a25f496a1">svn_stream_set_write</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, <a class="el" href="group__svn__io__byte__streams.html#gaa79398b116a9209eb3a79947a6066f54">svn_write_fn_t</a> write_fn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>stream's</em> write function to <em>write_fn</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga090c93a72964b78a00de75fa10fc5078"></a><!-- doxytag: member="svn_io.h::svn_stream_set_close" ref="ga090c93a72964b78a00de75fa10fc5078" args="(svn_stream_t *stream, svn_close_fn_t close_fn)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga090c93a72964b78a00de75fa10fc5078">svn_stream_set_close</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, <a class="el" href="group__svn__io__byte__streams.html#ga576facc62f51e98c14cb440df1e58cd9">svn_close_fn_t</a> close_fn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>stream's</em> close function to <em>close_fn</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gacdce9efd65576fafecb4df5fd2960d13">svn_stream_set_mark</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, <a class="el" href="group__svn__io__byte__streams.html#gaf811477b7cafa3c5c20cb3428976d0be">svn_stream_mark_fn_t</a> mark_fn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>stream's</em> mark function to <em>mark_fn</em>.  <a href="group__svn__io__byte__streams.html#gacdce9efd65576fafecb4df5fd2960d13"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga96e94eff159f85a3c8c6b7936e5c908d">svn_stream_set_seek</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, <a class="el" href="group__svn__io__byte__streams.html#gaa5291159cc874084805155ccdfd68b4b">svn_stream_seek_fn_t</a> seek_fn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>stream's</em> seek function to <em>seek_fn</em>.  <a href="group__svn__io__byte__streams.html#ga96e94eff159f85a3c8c6b7936e5c908d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga9f0acad4da18e90c1dc5250643af7049">svn_stream_empty</a> (apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a stream that is empty for reading and infinite for writing.  <a href="group__svn__io__byte__streams.html#ga9f0acad4da18e90c1dc5250643af7049"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga61c69116290c1f5e5fedd91ed7bed5ca">svn_stream_disown</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a stream allocated in <em>pool</em> which forwards all requests to <em>stream</em>.  <a href="group__svn__io__byte__streams.html#ga61c69116290c1f5e5fedd91ed7bed5ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga4d03d151fe2d8fb4068dab914823d059">svn_stream_open_readonly</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **stream, const char *path, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a stream to read the file at <em>path</em>.  <a href="group__svn__io__byte__streams.html#ga4d03d151fe2d8fb4068dab914823d059"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gace8995769bb736796262450ef90f033e">svn_stream_open_writable</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **stream, const char *path, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a stream to write a file at <em>path</em>.  <a href="group__svn__io__byte__streams.html#gace8995769bb736796262450ef90f033e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga821ab7add7a0216c86b1a7f94456fae9">svn_stream_open_unique</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **stream, const char **temp_path, const char *dirpath, <a class="el" href="svn__io_8h.html#aa78fffc81af962281813070c753d7884">svn_io_file_del_t</a> delete_when, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a writable stream to a file in the directory <em>dirpath</em>.  <a href="group__svn__io__byte__streams.html#ga821ab7add7a0216c86b1a7f94456fae9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gadf2971328919edf3fed5ef8353a90525">svn_stream_from_aprfile2</a> (apr_file_t *file, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> disown, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a stream from an APR file.  <a href="group__svn__io__byte__streams.html#gadf2971328919edf3fed5ef8353a90525"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gad12a2e4cbc23bcf8ee3f650966b8c43b">svn_stream_from_aprfile</a> (apr_file_t *file, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="group__svn__io__byte__streams.html#gadf2971328919edf3fed5ef8353a90525" title="Create a stream from an APR file.">svn_stream_from_aprfile2()</a>, except that the file will always be disowned.  <a href="group__svn__io__byte__streams.html#gad12a2e4cbc23bcf8ee3f650966b8c43b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga2e8d5c7ca3a74393f3350540149e8e3d">svn_stream_for_stdin</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **in, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*in</em> to a generic stream connected to stdin, allocated in <em>pool</em>.  <a href="group__svn__io__byte__streams.html#ga2e8d5c7ca3a74393f3350540149e8e3d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gaa76703167b5bc9cc53a1f66e64c5f77a">svn_stream_for_stderr</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **err, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*err</em> to a generic stream connected to stderr, allocated in <em>pool</em>.  <a href="group__svn__io__byte__streams.html#gaa76703167b5bc9cc53a1f66e64c5f77a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga64eca282d3b75b431a6f8ae5a6637fbb">svn_stream_for_stdout</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **out, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*out</em> to a generic stream connected to stdout, allocated in <em>pool</em>.  <a href="group__svn__io__byte__streams.html#ga64eca282d3b75b431a6f8ae5a6637fbb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gabe260b52fa278bc63ba75ea695e54303">svn_stream_from_stringbuf</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *str, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a generic stream connected to stringbuf <em>str</em>.  <a href="group__svn__io__byte__streams.html#gabe260b52fa278bc63ba75ea695e54303"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga8e85f7340b0f3471fb79c1bc501e4fea">svn_stream_from_string</a> (const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *str, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a generic read-only stream connected to string <em>str</em>.  <a href="group__svn__io__byte__streams.html#ga8e85f7340b0f3471fb79c1bc501e4fea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga10756ab562fd20d32fb880c859607b4c">svn_stream_compressed</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a stream that decompresses all data read and compresses all data written.  <a href="group__svn__io__byte__streams.html#ga10756ab562fd20d32fb880c859607b4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga823456ae87bbacf8b7022e8ea4c0d356">svn_stream_checksummed2</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, <a class="el" href="structsvn__checksum__t.html">svn_checksum_t</a> **read_checksum, <a class="el" href="structsvn__checksum__t.html">svn_checksum_t</a> **write_checksum, <a class="el" href="svn__checksum_8h.html#a7a6c373d03d7e6ec6b832a039f5e0aa1">svn_checksum_kind_t</a> checksum_kind, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> read_all, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a stream that calculates checksums for all data read and written.  <a href="group__svn__io__byte__streams.html#ga823456ae87bbacf8b7022e8ea4c0d356"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gadda74c8a8bf6d4dc64488979aa197afc">svn_stream_checksummed</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, const unsigned char **read_digest, const unsigned char **write_digest, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> read_all, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="group__svn__io__byte__streams.html#ga823456ae87bbacf8b7022e8ea4c0d356" title="Return a stream that calculates checksums for all data read and written.">svn_stream_checksummed2()</a>, but always returning the MD5 checksum in <em>read_digest</em> and <em>write_digest</em>.  <a href="group__svn__io__byte__streams.html#gadda74c8a8bf6d4dc64488979aa197afc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga241e8929f8f7631a629142bd749b25fc">svn_stream_read</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, char *buffer, apr_size_t *len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from a generic stream.  <a href="group__svn__io__byte__streams.html#ga241e8929f8f7631a629142bd749b25fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga139e177f2f8600c47f01319f12dc5d4a">svn_stream_skip</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, apr_size_t len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip <em>len</em> bytes from a generic <em>stream</em>.  <a href="group__svn__io__byte__streams.html#ga139e177f2f8600c47f01319f12dc5d4a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga0094764a89afdedecac79df9ad1ebccb">svn_stream_write</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, const char *data, apr_size_t *len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to a generic stream.  <a href="group__svn__io__byte__streams.html#ga0094764a89afdedecac79df9ad1ebccb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga7d9cdab4d5d8707d59a1b1d3dab95bb4">svn_stream_close</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a generic stream.  <a href="group__svn__io__byte__streams.html#ga7d9cdab4d5d8707d59a1b1d3dab95bb4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gac7574ccd5c0f60779bdaef7f5b44febd">svn_stream_reset</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset a generic stream back to its origin.  <a href="group__svn__io__byte__streams.html#gac7574ccd5c0f60779bdaef7f5b44febd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gab5dc6f7105e2332ebda600b2d2300eb7">svn_stream_supports_mark</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>TRUE</code> if the generic <em>stream</em> supports <a class="el" href="group__svn__io__byte__streams.html#ga47c17fbf09effd084d6b426d18175942" title="Set a mark at the current position of a generic stream, which can later be sought back to using svn_s...">svn_stream_mark()</a>.  <a href="group__svn__io__byte__streams.html#gab5dc6f7105e2332ebda600b2d2300eb7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga47c17fbf09effd084d6b426d18175942">svn_stream_mark</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, <a class="el" href="group__svn__io__byte__streams.html#gaca2f3b74a1215c13b5ae2ca3b99437b9">svn_stream_mark_t</a> **mark, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a <em>mark</em> at the current position of a generic <em>stream</em>, which can later be sought back to using <a class="el" href="group__svn__io__byte__streams.html#ga1cb32df4e14164a911490bae5e58e99e" title="Seek to a mark in a generic stream.">svn_stream_seek()</a>.  <a href="group__svn__io__byte__streams.html#ga47c17fbf09effd084d6b426d18175942"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga1cb32df4e14164a911490bae5e58e99e">svn_stream_seek</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, const <a class="el" href="group__svn__io__byte__streams.html#gaca2f3b74a1215c13b5ae2ca3b99437b9">svn_stream_mark_t</a> *mark)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek to a <em>mark</em> in a generic <em>stream</em>.  <a href="group__svn__io__byte__streams.html#ga1cb32df4e14164a911490bae5e58e99e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga77fdb810198d9c7832610882fd57546b">svn_stream_tee</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *out1, <a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *out2, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable stream which, when written to, writes to both of the underlying streams.  <a href="group__svn__io__byte__streams.html#ga77fdb810198d9c7832610882fd57546b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8665c4828daad13a35fd7e670552d888"></a><!-- doxytag: member="svn_io.h::svn_stream_printf" ref="ga8665c4828daad13a35fd7e670552d888" args="(svn_stream_t *stream, apr_pool_t *pool, const char *fmt,...)" -->
<a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga8665c4828daad13a35fd7e670552d888">svn_stream_printf</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, apr_pool_t *pool, const char *fmt,...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to <em>stream</em> using a printf-style <em>fmt</em> specifier, passed through apr_psprintf() using memory from <em>pool</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gacfb10864df6c3a6fd6e5fc08ae8ef7e8">svn_stream_printf_from_utf8</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, const char *encoding, apr_pool_t *pool, const char *fmt,...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to <em>stream</em> using a printf-style <em>fmt</em> specifier, passed through apr_psprintf() using memory from <em>pool</em>.  <a href="group__svn__io__byte__streams.html#gacfb10864df6c3a6fd6e5fc08ae8ef7e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gaccbf1cdff3857cad09096f8f01f37260">svn_stream_readline</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, <a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> **stringbuf, const char *eol, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *eof, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate <em>*stringbuf</em> in <em>pool</em>, and read into it one line (terminated by <em>eol</em>) from <em>stream</em>.  <a href="group__svn__io__byte__streams.html#gaccbf1cdff3857cad09096f8f01f37260"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga674a71b48f810dd21ad2db6fd611930d">svn_stream_copy3</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *from, <a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *to, <a class="el" href="svn__types_8h.html#addaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a> cancel_func, void *cancel_baton, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the contents of the readable stream <em>from</em> and write them to the writable stream <em>to</em> calling <em>cancel_func</em> before copying each chunk.  <a href="group__svn__io__byte__streams.html#ga674a71b48f810dd21ad2db6fd611930d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga1960de4b4eb0cf1a69a5ba5e11aaa6be">svn_stream_copy2</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *from, <a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *to, <a class="el" href="svn__types_8h.html#addaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a> cancel_func, void *cancel_baton, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="group__svn__io__byte__streams.html#ga674a71b48f810dd21ad2db6fd611930d" title="Read the contents of the readable stream from and write them to the writable stream to calling cancel...">svn_stream_copy3()</a> but the streams are not closed.  <a href="group__svn__io__byte__streams.html#ga1960de4b4eb0cf1a69a5ba5e11aaa6be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga444db383401ed714a240ff6ca5ca76b3">svn_stream_copy</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *from, <a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *to, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="group__svn__io__byte__streams.html#ga674a71b48f810dd21ad2db6fd611930d" title="Read the contents of the readable stream from and write them to the writable stream to calling cancel...">svn_stream_copy3()</a>, but without the cancellation function or stream closing.  <a href="group__svn__io__byte__streams.html#ga444db383401ed714a240ff6ca5ca76b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga4a84c869ab835792b5e441b5eb426fd6">svn_stream_contents_same2</a> (<a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *same, <a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream1, <a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream2, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*same</em> to TRUE if <em>stream1</em> and <em>stream2</em> have the same contents, else set it to FALSE.  <a href="group__svn__io__byte__streams.html#ga4a84c869ab835792b5e441b5eb426fd6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga14b9375f4e0300888b853650e15a987a">svn_stream_contents_same</a> (<a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *same, <a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream1, <a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream2, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="group__svn__io__byte__streams.html#ga4a84c869ab835792b5e441b5eb426fd6" title="Set *same to TRUE if stream1 and stream2 have the same contents, else set it to FALSE.">svn_stream_contents_same2()</a>, but the streams will not be closed.  <a href="group__svn__io__byte__streams.html#ga14b9375f4e0300888b853650e15a987a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga91b87b96c3f9a302d390263bd0d451a2">svn_string_from_stream</a> (<a class="el" href="structsvn__string__t.html">svn_string_t</a> **result, <a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the contents of <em>stream</em> into memory, returning the data in <em>result</em>.  <a href="group__svn__io__byte__streams.html#ga91b87b96c3f9a302d390263bd0d451a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a9135b41547d59296fc54c8316278a0d6">svn_stringbuf_from_file2</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> **result, const char *filename, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*result</em> to a string containing the contents of <em>filename</em>, which is either "-" (indicating that stdin should be read) or the utf8-encoded path of a real file.  <a href="#a9135b41547d59296fc54c8316278a0d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a2ffefcabf44f9e9fb2f71d409fcf782e">svn_stringbuf_from_file</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> **result, const char *filename, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="svn__io_8h.html#a9135b41547d59296fc54c8316278a0d6" title="Set *result to a string containing the contents of filename, which is either &quot;-&quot; (indicating that std...">svn_stringbuf_from_file2()</a>, except that if <em>filename</em> is "-", return the error <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660a4152fa8f6143f7bcd6f2f7d656096c8b" title="&quot;Trying to use an unsupported feature&quot;">SVN_ERR_UNSUPPORTED_FEATURE</a> and don't touch <em>*result</em>.  <a href="#a2ffefcabf44f9e9fb2f71d409fcf782e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a59b7be5b78cc045ed972b226e06ab509">svn_stringbuf_from_aprfile</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> **result, apr_file_t *file, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <em>*result</em> to a string containing the contents of the already opened <em>file</em>.  <a href="#a59b7be5b78cc045ed972b226e06ab509"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a528121fa3625ec79bea870b5e53d98c6">svn_io_remove_file2</a> (const char *path, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> ignore_enoent, apr_pool_t *scratch_pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove file <em>path</em>, a utf8-encoded path.  <a href="#a528121fa3625ec79bea870b5e53d98c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#abce28e789f76b15917b28b157d54dcfb">svn_io_remove_file</a> (const char *path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="svn__io_8h.html#a528121fa3625ec79bea870b5e53d98c6" title="Remove file path, a utf8-encoded path.">svn_io_remove_file2()</a>, except with <em>ignore_enoent</em> set to FALSE.  <a href="#abce28e789f76b15917b28b157d54dcfb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a9a26dab3678b7ee9c8ebdb8e1d60aedc">svn_io_remove_dir2</a> (const char *path, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> ignore_enoent, <a class="el" href="svn__types_8h.html#addaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a> cancel_func, void *cancel_baton, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively remove directory <em>path</em>.  <a href="#a9a26dab3678b7ee9c8ebdb8e1d60aedc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#ad7a26505bf041286d02793eb2a17be04">svn_io_remove_dir</a> (const char *path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="svn__io_8h.html#a9a26dab3678b7ee9c8ebdb8e1d60aedc" title="Recursively remove directory path.">svn_io_remove_dir2()</a>, but with <em>ignore_enoent</em> set to <code>FALSE</code> and <em>cancel_func</em> and <em>cancel_baton</em> set to <code>NULL</code>.  <a href="#ad7a26505bf041286d02793eb2a17be04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a0f79a74771d956231850979d58b9106e">svn_io_get_dir_filenames</a> (apr_hash_t **dirents, const char *path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read all of the disk entries in directory <em>path</em>, a utf8-encoded path.  <a href="#a0f79a74771d956231850979d58b9106e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a7cf56b512d7aa14d5330d8b30eec6189">svn_io_get_dirents3</a> (apr_hash_t **dirents, const char *path, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> only_check_type, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read all of the disk entries in directory <em>path</em>, a utf8-encoded path.  <a href="#a7cf56b512d7aa14d5330d8b30eec6189"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a1583e69324a3f820894422f57fa37d57">svn_io_get_dirents2</a> (apr_hash_t **dirents, const char *path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to svn_io_get_dirents3, but returns a mapping to <a class="el" href="structsvn__io__dirent__t.html" title="Represents the kind and special status of a directory entry.">svn_io_dirent_t</a> structures instead of <a class="el" href="structsvn__io__dirent2__t.html" title="A set of directory entry data elements as returned by svn_io_get_dirents.">svn_io_dirent2_t</a> and with only a single pool.  <a href="#a1583e69324a3f820894422f57fa37d57"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a4b09482c9762a2391435a6d1702d59af">svn_io_get_dirents</a> (apr_hash_t **dirents, const char *path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="svn__io_8h.html#a1583e69324a3f820894422f57fa37d57" title="Similar to svn_io_get_dirents3, but returns a mapping to svn_io_dirent_t structures instead of svn_io...">svn_io_get_dirents2()</a>, but <em>*dirents</em> is a hash table with <a class="el" href="svn__types_8h.html#aa3de517663a32716b59eabaf73c6b2bc" title="The various types of nodes in the Subversion filesystem.">svn_node_kind_t</a> values.  <a href="#a4b09482c9762a2391435a6d1702d59af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a5f173471fff3a277d315845056e61f94">svn_io_stat_dirent</a> (const <a class="el" href="structsvn__io__dirent2__t.html">svn_io_dirent2_t</a> **dirent_p, const char *path, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> ignore_enoent, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="structsvn__io__dirent2__t.html" title="A set of directory entry data elements as returned by svn_io_get_dirents.">svn_io_dirent2_t</a> instance for path.  <a href="#a5f173471fff3a277d315845056e61f94"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#ac47edc693b1106c9b4494017b469d206">svn_io_dir_walk2</a> (const char *dirname, apr_int32_t wanted, <a class="el" href="svn__io_8h.html#ae3dd33688b3e75430f4720f4d90c1506">svn_io_walk_func_t</a> walk_func, void *walk_baton, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively walk the directory rooted at <em>dirname</em>, a utf8-encoded path, invoking <em>walk_func</em> (with <em>walk_baton</em>) for each item in the tree.  <a href="#ac47edc693b1106c9b4494017b469d206"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#acac394a2c49dcfb02b8cda55c9281625">svn_io_dir_walk</a> (const char *dirname, apr_int32_t wanted, <a class="el" href="svn__io_8h.html#ae3dd33688b3e75430f4720f4d90c1506">svn_io_walk_func_t</a> walk_func, void *walk_baton, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="svn__io_8h.html#acac394a2c49dcfb02b8cda55c9281625" title="Similar to svn_io_dir_walk(), but only calls walk_func for files of type APR_DIR (directory) and APR_...">svn_io_dir_walk()</a>, but only calls <em>walk_func</em> for files of type APR_DIR (directory) and APR_REG (regular file).  <a href="#acac394a2c49dcfb02b8cda55c9281625"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#aa9e4a63f9f1c86d6ff712bcb6d51ddf4">svn_io_start_cmd2</a> (apr_proc_t *cmd_proc, const char *path, const char *cmd, const char *const *args, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> inherit, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> infile_pipe, apr_file_t *infile, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> outfile_pipe, apr_file_t *outfile, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> errfile_pipe, apr_file_t *errfile, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Start <em>cmd</em> with <em>args</em>, using utf8-encoded <em>path</em> as working directory.  <a href="#aa9e4a63f9f1c86d6ff712bcb6d51ddf4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a4ee2641c854734f78337aee204b79201">svn_io_start_cmd</a> (apr_proc_t *cmd_proc, const char *path, const char *cmd, const char *const *args, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> inherit, apr_file_t *infile, apr_file_t *outfile, apr_file_t *errfile, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="svn__io_8h.html#aa9e4a63f9f1c86d6ff712bcb6d51ddf4" title="Start cmd with args, using utf8-encoded path as working directory.">svn_io_start_cmd2()</a> but with <em>infile_pipe</em>, <em>outfile_pipe</em>, and <em>errfile_pipe</em> always FALSE.  <a href="#a4ee2641c854734f78337aee204b79201"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#acc0478196081ff559613daf3ac8a39c7">svn_io_wait_for_cmd</a> (apr_proc_t *cmd_proc, const char *cmd, int *exitcode, apr_exit_why_e *exitwhy, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the process <em>*cmd_proc</em> to complete and optionally retrieve its exit code.  <a href="#acc0478196081ff559613daf3ac8a39c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#ab59c1c8d67cf405ca36a5556858da82d">svn_io_run_cmd</a> (const char *path, const char *cmd, const char *const *args, int *exitcode, apr_exit_why_e *exitwhy, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> inherit, apr_file_t *infile, apr_file_t *outfile, apr_file_t *errfile, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a command to completion, by first calling <a class="el" href="svn__io_8h.html#a4ee2641c854734f78337aee204b79201" title="Similar to svn_io_start_cmd2() but with infile_pipe, outfile_pipe, and errfile_pipe always FALSE...">svn_io_start_cmd()</a> and then calling <a class="el" href="svn__io_8h.html#acc0478196081ff559613daf3ac8a39c7" title="Wait for the process *cmd_proc to complete and optionally retrieve its exit code.">svn_io_wait_for_cmd()</a>.  <a href="#ab59c1c8d67cf405ca36a5556858da82d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#acabda4f4f591bec06ece8e35829a79f4">svn_io_run_diff2</a> (const char *dir, const char *const *user_args, int num_user_args, const char *label1, const char *label2, const char *from, const char *to, int *exitcode, apr_file_t *outfile, apr_file_t *errfile, const char *diff_cmd, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the configured <code>diff</code> program, with <em>user_args</em> (an array of utf8-encoded <em>num_user_args</em> arguments) if they are specified (that is, if <em>user_args</em> is non-NULL), or "-u" if they are not.  <a href="#acabda4f4f591bec06ece8e35829a79f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a6c0266e00c285a0b90eef9faf0e31024">svn_io_run_diff</a> (const char *dir, const char *const *user_args, int num_user_args, const char *label1, const char *label2, const char *from, const char *to, int *exitcode, apr_file_t *outfile, apr_file_t *errfile, const char *diff_cmd, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="svn__io_8h.html#acabda4f4f591bec06ece8e35829a79f4" title="Invoke the configured diff program, with user_args (an array of utf8-encoded num_user_args arguments)...">svn_io_run_diff2()</a> but with <em>diff_cmd</em> encoded in internal encoding used by APR.  <a href="#a6c0266e00c285a0b90eef9faf0e31024"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a0ef4f589d31a5578526c3de2d0587cf7">svn_io_run_diff3_3</a> (int *exitcode, const char *dir, const char *mine, const char *older, const char *yours, const char *mine_label, const char *older_label, const char *yours_label, apr_file_t *merged, const char *diff3_cmd, const apr_array_header_t *user_args, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the configured <code>diff3</code> program, in utf8-encoded <em>dir</em> like this:  <a href="#a0ef4f589d31a5578526c3de2d0587cf7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a284650316c8ceefd30c4dae9aef49ec4">svn_io_run_diff3_2</a> (int *exitcode, const char *dir, const char *mine, const char *older, const char *yours, const char *mine_label, const char *older_label, const char *yours_label, apr_file_t *merged, const char *diff3_cmd, const apr_array_header_t *user_args, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="svn__io_8h.html#a0ef4f589d31a5578526c3de2d0587cf7" title="Invoke the configured diff3 program, in utf8-encoded dir like this:">svn_io_run_diff3_3()</a>, but with <em>diff3_cmd</em> encoded in internal encoding used by APR.  <a href="#a284650316c8ceefd30c4dae9aef49ec4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#ae800def15e3ffc5e1645b296c4e7a1ca">svn_io_run_diff3</a> (const char *dir, const char *mine, const char *older, const char *yours, const char *mine_label, const char *older_label, const char *yours_label, apr_file_t *merged, int *exitcode, const char *diff3_cmd, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="svn__io_8h.html#a284650316c8ceefd30c4dae9aef49ec4" title="Similar to svn_io_run_diff3_3(), but with diff3_cmd encoded in internal encoding used by APR...">svn_io_run_diff3_2()</a>, but with <em>user_args</em> set to <code>NULL</code>.  <a href="#ae800def15e3ffc5e1645b296c4e7a1ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#ac4625a082416ccaafdd77e35e14ec4d4">svn_io_parse_mimetypes_file</a> (apr_hash_t **type_map, const char *mimetypes_file, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse utf8-encoded <em>mimetypes_file</em> as a MIME types file (such as is provided with Apache HTTP Server), and set <em>*type_map</em> to a hash mapping <code>const char *</code> filename extensions to <code>const char *</code> MIME types.  <a href="#ac4625a082416ccaafdd77e35e14ec4d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#ac1989d5030f1445f2502258bf4901ab4">svn_io_detect_mimetype2</a> (const char **mimetype, const char *file, apr_hash_t *mimetype_map, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Examine utf8-encoded <em>file</em> to determine if it can be described by a known (as in, known by this function) Multipurpose Internet Mail Extension (MIME) type.  <a href="#ac1989d5030f1445f2502258bf4901ab4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#ae1a5fef60e9dde8f5537e637e21d025a">svn_io_detect_mimetype</a> (const char **mimetype, const char *file, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Like svn_io_detect_mimetype2, but with <em>mimetypes_map</em> set to <code>NULL</code>.  <a href="#ae1a5fef60e9dde8f5537e637e21d025a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a9dab9b761a5b9cae7c5610bcce781141">svn_io_is_binary_data</a> (const void *buf, apr_size_t len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Examine up to <em>len</em> bytes of data in <em>buf</em> to determine if the can be considered binary data, in which case return TRUE.  <a href="#a9dab9b761a5b9cae7c5610bcce781141"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#aaafb0039d02ec4d4393c433c9430aa48">svn_io_file_open</a> (apr_file_t **new_file, const char *fname, apr_int32_t flag, apr_fileperms_t perm, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for apr_file_open().  <a href="#aaafb0039d02ec4d4393c433c9430aa48"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#ac53b59ed0d20666286dcc001f1aed43c">svn_io_file_close</a> (apr_file_t *file, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for apr_file_close().  <a href="#ac53b59ed0d20666286dcc001f1aed43c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a13cf1ae46bf9a45d01db6cf59d787ecd">svn_io_file_getc</a> (char *ch, apr_file_t *file, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for apr_file_getc().  <a href="#a13cf1ae46bf9a45d01db6cf59d787ecd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a0e7664bd83efaa663977639c03da878d">svn_io_file_putc</a> (char ch, apr_file_t *file, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for apr_file_putc().  <a href="#a0e7664bd83efaa663977639c03da878d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#aa9b673694dfebc9fa7018f423b6459c3">svn_io_file_info_get</a> (apr_finfo_t *finfo, apr_int32_t wanted, apr_file_t *file, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for apr_file_info_get().  <a href="#aa9b673694dfebc9fa7018f423b6459c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a783e5b2a7198107666cba41642610919">svn_io_file_read</a> (apr_file_t *file, void *buf, apr_size_t *nbytes, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for apr_file_read().  <a href="#a783e5b2a7198107666cba41642610919"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a1230fed18c27d237e6b1747bf1daeb57">svn_io_file_read_full2</a> (apr_file_t *file, void *buf, apr_size_t nbytes, apr_size_t *bytes_read, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *hit_eof, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for apr_file_read_full().  <a href="#a1230fed18c27d237e6b1747bf1daeb57"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a58487bc76681879193a9a067dd37b483">svn_io_file_read_full</a> (apr_file_t *file, void *buf, apr_size_t nbytes, apr_size_t *bytes_read, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to svn_io_file_read_full2 with hit_eof being set to <code>NULL</code>.  <a href="#a58487bc76681879193a9a067dd37b483"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#ab296b86da8b825399792d38f68e0e914">svn_io_file_seek</a> (apr_file_t *file, apr_seek_where_t where, apr_off_t *offset, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for apr_file_seek().  <a href="#ab296b86da8b825399792d38f68e0e914"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a5a78c172c69437a05e32d3dff6f152d0">svn_io_file_write</a> (apr_file_t *file, const void *buf, apr_size_t *nbytes, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for apr_file_write().  <a href="#a5a78c172c69437a05e32d3dff6f152d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a6789d12c70d0a2fefb539830183ee773">svn_io_file_write_full</a> (apr_file_t *file, const void *buf, apr_size_t nbytes, apr_size_t *bytes_written, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for apr_file_write_full().  <a href="#a6789d12c70d0a2fefb539830183ee773"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#aabcfef527a38cb25dde9f1e1565bf578">svn_io_write_unique</a> (const char **tmp_path, const char *dirpath, const void *buf, apr_size_t nbytes, <a class="el" href="svn__io_8h.html#aa78fffc81af962281813070c753d7884">svn_io_file_del_t</a> delete_when, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a unique file in <em>dirpath</em>, and write <em>nbytes</em> from <em>buf</em> to the file before flushing it to disk and closing it.  <a href="#aabcfef527a38cb25dde9f1e1565bf578"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#aee7ca5e75c04cd6f947d87199a0313f5">svn_io_file_trunc</a> (apr_file_t *file, apr_off_t offset, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for apr_file_trunc().  <a href="#aee7ca5e75c04cd6f947d87199a0313f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a8b3c8bc2bdde3a1a28eb402432e410e0">svn_io_stat</a> (apr_finfo_t *finfo, const char *fname, apr_int32_t wanted, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for apr_stat().  <a href="#a8b3c8bc2bdde3a1a28eb402432e410e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a958d10520c3e99ddcbbf333eed40d86f">svn_io_file_rename</a> (const char *from_path, const char *to_path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename and/or move the node (not necessarily a regular file) at <em>from_path</em> to a new path <em>to_path</em> within the same filesystem.  <a href="#a958d10520c3e99ddcbbf333eed40d86f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a2e4247ed6ed8390f4f7d68a5dea3f0e6">svn_io_file_move</a> (const char *from_path, const char *to_path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Move the file from <em>from_path</em> to <em>to_path</em>, even across device boundaries.  <a href="#a2e4247ed6ed8390f4f7d68a5dea3f0e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a108e7a96396aab7cacbf1e1c3ed5221f">svn_io_dir_make</a> (const char *path, apr_fileperms_t perm, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for apr_dir_make().  <a href="#a108e7a96396aab7cacbf1e1c3ed5221f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a052b330df7626a534833e6329b33d753">svn_io_dir_make_hidden</a> (const char *path, apr_fileperms_t perm, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="svn__io_8h.html#a108e7a96396aab7cacbf1e1c3ed5221f" title="Wrapper for apr_dir_make().">svn_io_dir_make()</a>, but sets the hidden attribute on the directory on systems that support it.  <a href="#a052b330df7626a534833e6329b33d753"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a51baaf892b96c9893bbae4fa5e747495">svn_io_dir_make_sgid</a> (const char *path, apr_fileperms_t perm, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="svn__io_8h.html#a108e7a96396aab7cacbf1e1c3ed5221f" title="Wrapper for apr_dir_make().">svn_io_dir_make()</a>, but attempts to set the sgid on the directory on systems that support it.  <a href="#a51baaf892b96c9893bbae4fa5e747495"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a946da2aa39f21a0f6099d2984620b2ff">svn_io_dir_open</a> (apr_dir_t **new_dir, const char *dirname, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for apr_dir_open().  <a href="#a946da2aa39f21a0f6099d2984620b2ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#ad06c1a3586d8ca151683f163edbc238d">svn_io_dir_close</a> (apr_dir_t *thedir)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for apr_dir_close().  <a href="#ad06c1a3586d8ca151683f163edbc238d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a09827e5b0404fd70abc39a2193aecb26">svn_io_dir_remove_nonrecursive</a> (const char *dirname, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for apr_dir_remove().  <a href="#a09827e5b0404fd70abc39a2193aecb26"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a83669c6c77f141089dcc20ef80453d4a">svn_io_dir_read</a> (apr_finfo_t *finfo, apr_int32_t wanted, apr_dir_t *thedir, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for apr_dir_read().  <a href="#a83669c6c77f141089dcc20ef80453d4a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#acbcb8bfd6df6bbf9c35361b0f17f0ea7">svn_io_file_name_get</a> (const char **filename, apr_file_t *file, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for apr_file_name_get().  <a href="#acbcb8bfd6df6bbf9c35361b0f17f0ea7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__format__files.html#ga80f0a4330380bafb4cd65e09151f411b">svn_io_read_version_file</a> (int *version, const char *path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*version</em> to the integer that starts the file at <em>path</em>.  <a href="group__svn__io__format__files.html#ga80f0a4330380bafb4cd65e09151f411b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__format__files.html#ga29aa0631f0facde88398ad50d9411aca">svn_io_write_version_file</a> (const char *path, int version, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create (or overwrite) the file at <em>path</em> with new contents, formatted as a non-negative integer <em>version</em> followed by a single newline.  <a href="group__svn__io__format__files.html#ga29aa0631f0facde88398ad50d9411aca"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>General file I/O for Subversion. </p>

<p>Definition in file <a class="el" href="svn__io_8h_source.html">svn_io.h</a>.</p>
</div><hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a0900f4459a5ef43cb1634d3b89d829a4"></a><!-- doxytag: member="svn_io.h::svn_io_dirent2_t" ref="a0900f4459a5ef43cb1634d3b89d829a4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structsvn__io__dirent2__t.html">svn_io_dirent2_t</a>  <a class="el" href="structsvn__io__dirent2__t.html">svn_io_dirent2_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A set of directory entry data elements as returned by svn_io_get_dirents. </p>
<p>Note that the first two fields are exactly identical to <a class="el" href="structsvn__io__dirent__t.html" title="Represents the kind and special status of a directory entry.">svn_io_dirent_t</a> to allow returning a <a class="el" href="structsvn__io__dirent2__t.html" title="A set of directory entry data elements as returned by svn_io_get_dirents.">svn_io_dirent2_t</a> as a <a class="el" href="structsvn__io__dirent__t.html" title="Represents the kind and special status of a directory entry.">svn_io_dirent_t</a>.</p>
<p>Use <a class="el" href="svn__io_8h.html#a48ca8a48714c0353e1246e992def863b" title="Creates a new svn_io_dirent2_t structure.">svn_io_dirent2_create()</a> to create new svn_dirent2_t instances or <a class="el" href="svn__io_8h.html#a4373588a310c126338eee38f6fa8f67c" title="Duplicates a svn_io_dirent2_t structure into result_pool.">svn_io_dirent2_dup()</a> to duplicate an existing instance.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="af9f5d05db9c9a8f513615e4ec2caf5b2"></a><!-- doxytag: member="svn_io.h::svn_io_dirent_t" ref="af9f5d05db9c9a8f513615e4ec2caf5b2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structsvn__io__dirent__t.html">svn_io_dirent_t</a>  <a class="el" href="structsvn__io__dirent__t.html">svn_io_dirent_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Represents the kind and special status of a directory entry. </p>
<p>Note that the first two fields are exactly identical to <a class="el" href="structsvn__io__dirent2__t.html" title="A set of directory entry data elements as returned by svn_io_get_dirents.">svn_io_dirent2_t</a> to allow returning a <a class="el" href="structsvn__io__dirent2__t.html" title="A set of directory entry data elements as returned by svn_io_get_dirents.">svn_io_dirent2_t</a> as a <a class="el" href="structsvn__io__dirent__t.html" title="Represents the kind and special status of a directory entry.">svn_io_dirent_t</a>.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.3. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ed9ee9548db02f141509f4e08df0827"></a><!-- doxytag: member="svn_io.h::svn_io_file_del_t" ref="a1ed9ee9548db02f141509f4e08df0827" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="svn__io_8h.html#aa78fffc81af962281813070c753d7884">svn_io_file_del_t</a>  <a class="el" href="svn__io_8h.html#aa78fffc81af962281813070c753d7884">svn_io_file_del_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used as an argument when creating temporary files to indicate when a file should be removed. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.4.</dd></dl>
<p>Not specifying any of these means no removal at all. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="aa78fffc81af962281813070c753d7884"></a><!-- doxytag: member="svn_io.h::svn_io_file_del_t" ref="aa78fffc81af962281813070c753d7884" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="svn__io_8h.html#aa78fffc81af962281813070c753d7884">svn_io_file_del_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used as an argument when creating temporary files to indicate when a file should be removed. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.4.</dd></dl>
<p>Not specifying any of these means no removal at all. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="aa78fffc81af962281813070c753d7884a70268318a6e388419ae0e85ab7f7599c"></a><!-- doxytag: member="svn_io_file_del_none" ref="aa78fffc81af962281813070c753d7884a70268318a6e388419ae0e85ab7f7599c" args="" -->svn_io_file_del_none</em>&nbsp;</td><td>
<p>No deletion ever. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa78fffc81af962281813070c753d7884a6256344ca6b43868daa12365d75834d2"></a><!-- doxytag: member="svn_io_file_del_on_close" ref="aa78fffc81af962281813070c753d7884a6256344ca6b43868daa12365d75834d2" args="" -->svn_io_file_del_on_close</em>&nbsp;</td><td>
<p>Remove when the file is closed. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa78fffc81af962281813070c753d7884a0f89c57067b563673ea1ec5605c908bd"></a><!-- doxytag: member="svn_io_file_del_on_pool_cleanup" ref="aa78fffc81af962281813070c753d7884a0f89c57067b563673ea1ec5605c908bd" args="" -->svn_io_file_del_on_pool_cleanup</em>&nbsp;</td><td>
<p>Remove when the associated pool is cleared. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="svn__io_8h_source.html#l00058">58</a> of file <a class="el" href="svn__io_8h_source.html">svn_io.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a967781b8e5991f3c72f125a333661d1b"></a><!-- doxytag: member="svn_io.h::svn_io_append_file" ref="a967781b8e5991f3c72f125a333661d1b" args="(const char *src, const char *dst, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_append_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append <em>src</em> to <em>dst</em>. </p>
<p><em>dst</em> will be appended to if it exists, else it will be created. Both <em>src</em> and <em>dst</em> are utf8-encoded. </p>

</div>
</div>
<a class="anchor" id="a31ee1827a2b62a2f4a122ef18e378b05"></a><!-- doxytag: member="svn_io.h::svn_io_check_path" ref="a31ee1827a2b62a2f4a122ef18e378b05" args="(const char *path, svn_node_kind_t *kind, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_check_path </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#ac3ca125707a8ca1289c73236b5ce7f9a">svn_node_kind_t</a> *&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine the <em>kind</em> of <em>path</em>. </p>
<p><em>path</em> should be UTF-8 encoded.</p>
<p>If <em>path</em> is a file, set <em>*kind</em> to <a class="el" href="svn__types_8h.html#ac3ca125707a8ca1289c73236b5ce7f9aaa95e604c61f68662a3baed477db64083" title="regular file">svn_node_file</a>.</p>
<p>If <em>path</em> is a directory, set <em>*kind</em> to <a class="el" href="svn__types_8h.html#ac3ca125707a8ca1289c73236b5ce7f9aaba05e448cccf503e25be6506d7bf9a5b" title="directory">svn_node_dir</a>.</p>
<p>If <em>path</em> does not exist, set <em>*kind</em> to <a class="el" href="svn__types_8h.html#ac3ca125707a8ca1289c73236b5ce7f9aae4066898ada99c4a3bc94e80aabe78b5" title="absent">svn_node_none</a>.</p>
<p>If <em>path</em> exists but is none of the above, set <em>*kind</em> to <a class="el" href="svn__types_8h.html#ac3ca125707a8ca1289c73236b5ce7f9aa8fa9327ee73e41216ad586867fea4b94" title="something&#39;s here, but we don&#39;t know what">svn_node_unknown</a>.</p>
<p>If <em>path</em> is not a valid pathname, set <em>*kind</em> to <a class="el" href="svn__types_8h.html#ac3ca125707a8ca1289c73236b5ce7f9aae4066898ada99c4a3bc94e80aabe78b5" title="absent">svn_node_none</a>. If unable to determine <em>path's</em> kind for any other reason, return an error, with <em>*kind's</em> value undefined.</p>
<p>Use <em>pool</em> for temporary allocations.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="svn__types_8h.html#aa3de517663a32716b59eabaf73c6b2bc" title="The various types of nodes in the Subversion filesystem.">svn_node_kind_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a47336875b45ac006d69aef58db4fb5bb"></a><!-- doxytag: member="svn_io.h::svn_io_check_resolved_path" ref="a47336875b45ac006d69aef58db4fb5bb" args="(const char *path, svn_node_kind_t *kind, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_check_resolved_path </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#ac3ca125707a8ca1289c73236b5ce7f9a">svn_node_kind_t</a> *&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like <a class="el" href="svn__io_8h.html#a31ee1827a2b62a2f4a122ef18e378b05" title="Determine the kind of path.">svn_io_check_path()</a>, but resolve symlinks. </p>
<p>This returns the same varieties of <em>kind</em> as <a class="el" href="svn__io_8h.html#a31ee1827a2b62a2f4a122ef18e378b05" title="Determine the kind of path.">svn_io_check_path()</a>. </p>

</div>
</div>
<a class="anchor" id="a0f8fdad8dc4fe854ef5b9971f8ab043e"></a><!-- doxytag: member="svn_io.h::svn_io_check_special_path" ref="a0f8fdad8dc4fe854ef5b9971f8ab043e" args="(const char *path, svn_node_kind_t *kind, svn_boolean_t *is_special, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_check_special_path </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#ac3ca125707a8ca1289c73236b5ce7f9a">svn_node_kind_t</a> *&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *&#160;</td>
          <td class="paramname"><em>is_special</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like <a class="el" href="svn__io_8h.html#a31ee1827a2b62a2f4a122ef18e378b05" title="Determine the kind of path.">svn_io_check_path()</a>, but also set *is_special to <code>TRUE</code> if the path is not a normal file. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.1. </dd></dl>

</div>
</div>
<a class="anchor" id="afcaeff1ea5e9ae65c8188678a1e042bf"></a><!-- doxytag: member="svn_io.h::svn_io_copy_dir_recursively" ref="afcaeff1ea5e9ae65c8188678a1e042bf" args="(const char *src, const char *dst_parent, const char *dst_basename, svn_boolean_t copy_perms, svn_cancel_func_t cancel_func, void *cancel_baton, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_copy_dir_recursively </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dst_parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dst_basename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>copy_perms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#addaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a>&#160;</td>
          <td class="paramname"><em>cancel_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cancel_baton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recursively copy directory <em>src</em> into <em>dst_parent</em>, as a new entry named <em>dst_basename</em>. </p>
<p>If <em>dst_basename</em> already exists in <em>dst_parent</em>, return error. <em>copy_perms</em> will be passed through to <a class="el" href="svn__io_8h.html#ab4a3b25a089372c59aca6783a3a31595" title="Copy src to dst atomically, in a &quot;byte-for-byte&quot; manner.">svn_io_copy_file()</a> when any files are copied. <em>src</em>, <em>dst_parent</em>, and <em>dst_basename</em> are all utf8-encoded.</p>
<p>If <em>cancel_func</em> is non-NULL, invoke it with <em>cancel_baton</em> at various points during the operation. If it returns any error (typically <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660a879a10e8184482c5fb71e48ab0bb28a9" title="&quot;The operation was interrupted&quot;">SVN_ERR_CANCELLED</a>), return that error immediately. </p>

</div>
</div>
<a class="anchor" id="ab4a3b25a089372c59aca6783a3a31595"></a><!-- doxytag: member="svn_io.h::svn_io_copy_file" ref="ab4a3b25a089372c59aca6783a3a31595" args="(const char *src, const char *dst, svn_boolean_t copy_perms, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_copy_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>copy_perms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy <em>src</em> to <em>dst</em> atomically, in a "byte-for-byte" manner. </p>
<p>Overwrite <em>dst</em> if it exists, else create it. Both <em>src</em> and <em>dst</em> are utf8-encoded filenames. If <em>copy_perms</em> is TRUE, set <em>dst's</em> permissions to match those of <em>src</em>. </p>

</div>
</div>
<a class="anchor" id="a539dc0c726940a466a3bc2358d6b85d8"></a><!-- doxytag: member="svn_io.h::svn_io_copy_link" ref="a539dc0c726940a466a3bc2358d6b85d8" args="(const char *src, const char *dst, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_copy_link </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy symbolic link <em>src</em> to <em>dst</em> atomically. </p>
<p>Overwrite <em>dst</em> if it exists, else create it. Both <em>src</em> and <em>dst</em> are utf8-encoded filenames. After copying, the <em>dst</em> link will point to the same thing <em>src</em> does.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.1. </dd></dl>

</div>
</div>
<a class="anchor" id="a1c80cac675b5711e2c2c3e4aa6b4fbb1"></a><!-- doxytag: member="svn_io.h::svn_io_copy_perms" ref="a1c80cac675b5711e2c2c3e4aa6b4fbb1" args="(const char *src, const char *dst, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_copy_perms </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy permission flags from <em>src</em> onto the file at <em>dst</em>. </p>
<p>Both filenames are utf8-encoded filenames.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a class="anchor" id="ad11db24f003c6f280e39d3c9675280dc"></a><!-- doxytag: member="svn_io.h::svn_io_create_unique_link" ref="ad11db24f003c6f280e39d3c9675280dc" args="(const char **unique_name_p, const char *path, const char *dest, const char *suffix, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_create_unique_link </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>unique_name_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>suffix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like <a class="el" href="svn__io_8h.html#a2384857ad348105316edf6d1036d599f" title="Like svn_io_open_unique_file2, but can&#39;t delete on pool cleanup.">svn_io_open_unique_file()</a>, except that instead of creating a file, a symlink is generated that references the path <em>dest</em>. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.1. </dd></dl>

</div>
</div>
<a class="anchor" id="ae1a5fef60e9dde8f5537e637e21d025a"></a><!-- doxytag: member="svn_io.h::svn_io_detect_mimetype" ref="ae1a5fef60e9dde8f5537e637e21d025a" args="(const char **mimetype, const char *file, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_detect_mimetype </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>mimetype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like svn_io_detect_mimetype2, but with <em>mimetypes_map</em> set to <code>NULL</code>. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000202">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.4 API </dd></dl>

</div>
</div>
<a class="anchor" id="ac1989d5030f1445f2502258bf4901ab4"></a><!-- doxytag: member="svn_io.h::svn_io_detect_mimetype2" ref="ac1989d5030f1445f2502258bf4901ab4" args="(const char **mimetype, const char *file, apr_hash_t *mimetype_map, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_detect_mimetype2 </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>mimetype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_hash_t *&#160;</td>
          <td class="paramname"><em>mimetype_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Examine utf8-encoded <em>file</em> to determine if it can be described by a known (as in, known by this function) Multipurpose Internet Mail Extension (MIME) type. </p>
<p>If so, set <em>*mimetype</em> to a character string describing the MIME type, else set it to <code>NULL</code>.</p>
<p>If not <code>NULL</code>, <em>mimetype_map</em> is a hash mapping <code>const char *</code> filename extensions to <code>const char *</code> MIME types, and is the first source consulted regarding <em>file's</em> MIME type.</p>
<p>Use <em>pool</em> for any necessary allocations.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="ad06c1a3586d8ca151683f163edbc238d"></a><!-- doxytag: member="svn_io.h::svn_io_dir_close" ref="ad06c1a3586d8ca151683f163edbc238d" args="(apr_dir_t *thedir)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_dir_close </td>
          <td>(</td>
          <td class="paramtype">apr_dir_t *&#160;</td>
          <td class="paramname"><em>thedir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrapper for apr_dir_close(). </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="acea0b7ecaacd02da03a5cfaebe27067a"></a><!-- doxytag: member="svn_io.h::svn_io_dir_empty" ref="acea0b7ecaacd02da03a5cfaebe27067a" args="(svn_boolean_t *is_empty_p, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_dir_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *&#160;</td>
          <td class="paramname"><em>is_empty_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set <em>*is_empty_p</em> to <code>TRUE</code> if directory <em>path</em> is empty, else to <code>FALSE</code> if it is not empty. </p>
<p><em>path</em> must be a directory, and is utf8-encoded. Use <em>pool</em> for temporary allocation. </p>

</div>
</div>
<a class="anchor" id="ae6c6d960b1f742e2c00f8d7dd6ea1c5d"></a><!-- doxytag: member="svn_io.h::svn_io_dir_file_copy" ref="ae6c6d960b1f742e2c00f8d7dd6ea1c5d" args="(const char *src_path, const char *dest_path, const char *file, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_dir_file_copy </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dest_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy the file whose basename (or relative path) is <em>file</em> within directory <em>src_path</em> to the same basename (or relative path) within directory <em>dest_path</em>. </p>
<p>Overwrite the destination file if it already exists. The destination directory (including any directory components in <em>name</em>) must already exist. Set the destination file's permissions to match those of the source. Use <em>pool</em> for memory allocations. </p>

</div>
</div>
<a class="anchor" id="a108e7a96396aab7cacbf1e1c3ed5221f"></a><!-- doxytag: member="svn_io.h::svn_io_dir_make" ref="a108e7a96396aab7cacbf1e1c3ed5221f" args="(const char *path, apr_fileperms_t perm, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_dir_make </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_fileperms_t&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrapper for apr_dir_make(). </p>
<p><em>path</em> is utf8-encoded. </p>

</div>
</div>
<a class="anchor" id="a052b330df7626a534833e6329b33d753"></a><!-- doxytag: member="svn_io.h::svn_io_dir_make_hidden" ref="a052b330df7626a534833e6329b33d753" args="(const char *path, apr_fileperms_t perm, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_dir_make_hidden </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_fileperms_t&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Same as <a class="el" href="svn__io_8h.html#a108e7a96396aab7cacbf1e1c3ed5221f" title="Wrapper for apr_dir_make().">svn_io_dir_make()</a>, but sets the hidden attribute on the directory on systems that support it. </p>

</div>
</div>
<a class="anchor" id="a51baaf892b96c9893bbae4fa5e747495"></a><!-- doxytag: member="svn_io.h::svn_io_dir_make_sgid" ref="a51baaf892b96c9893bbae4fa5e747495" args="(const char *path, apr_fileperms_t perm, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_dir_make_sgid </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_fileperms_t&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Same as <a class="el" href="svn__io_8h.html#a108e7a96396aab7cacbf1e1c3ed5221f" title="Wrapper for apr_dir_make().">svn_io_dir_make()</a>, but attempts to set the sgid on the directory on systems that support it. </p>
<p>Does not return an error if the attempt to set the sgid bit fails. On Unix filesystems, setting the sgid bit on a directory ensures that files and subdirectories created within inherit group ownership from the parent instead of from the primary gid.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.1. </dd></dl>

</div>
</div>
<a class="anchor" id="a946da2aa39f21a0f6099d2984620b2ff"></a><!-- doxytag: member="svn_io.h::svn_io_dir_open" ref="a946da2aa39f21a0f6099d2984620b2ff" args="(apr_dir_t **new_dir, const char *dirname, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_dir_open </td>
          <td>(</td>
          <td class="paramtype">apr_dir_t **&#160;</td>
          <td class="paramname"><em>new_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dirname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrapper for apr_dir_open(). </p>
<p><em>dirname</em> is utf8-encoded. </p>

</div>
</div>
<a class="anchor" id="a83669c6c77f141089dcc20ef80453d4a"></a><!-- doxytag: member="svn_io.h::svn_io_dir_read" ref="a83669c6c77f141089dcc20ef80453d4a" args="(apr_finfo_t *finfo, apr_int32_t wanted, apr_dir_t *thedir, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_dir_read </td>
          <td>(</td>
          <td class="paramtype">apr_finfo_t *&#160;</td>
          <td class="paramname"><em>finfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_int32_t&#160;</td>
          <td class="paramname"><em>wanted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_dir_t *&#160;</td>
          <td class="paramname"><em>thedir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrapper for apr_dir_read(). </p>
<p>Ensures that <em>finfo-&gt;name</em> is utf8-encoded, which means allocating <em>finfo-&gt;name</em> in <em>pool</em>, which may or may not be the same as <em>finfo's</em> pool. Use <em>pool</em> for error allocation as well. </p>

</div>
</div>
<a class="anchor" id="a09827e5b0404fd70abc39a2193aecb26"></a><!-- doxytag: member="svn_io.h::svn_io_dir_remove_nonrecursive" ref="a09827e5b0404fd70abc39a2193aecb26" args="(const char *dirname, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_dir_remove_nonrecursive </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dirname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrapper for apr_dir_remove(). </p>
<p><em>dirname</em> is utf8-encoded. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function has this name to avoid confusion with <a class="el" href="svn__io_8h.html#a9a26dab3678b7ee9c8ebdb8e1d60aedc" title="Recursively remove directory path.">svn_io_remove_dir2()</a>, which is recursive. </dd></dl>

</div>
</div>
<a class="anchor" id="acac394a2c49dcfb02b8cda55c9281625"></a><!-- doxytag: member="svn_io.h::svn_io_dir_walk" ref="acac394a2c49dcfb02b8cda55c9281625" args="(const char *dirname, apr_int32_t wanted, svn_io_walk_func_t walk_func, void *walk_baton, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_dir_walk </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dirname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_int32_t&#160;</td>
          <td class="paramname"><em>wanted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__io_8h.html#ae3dd33688b3e75430f4720f4d90c1506">svn_io_walk_func_t</a>&#160;</td>
          <td class="paramname"><em>walk_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>walk_baton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Similar to <a class="el" href="svn__io_8h.html#acac394a2c49dcfb02b8cda55c9281625" title="Similar to svn_io_dir_walk(), but only calls walk_func for files of type APR_DIR (directory) and APR_...">svn_io_dir_walk()</a>, but only calls <em>walk_func</em> for files of type APR_DIR (directory) and APR_REG (regular file). </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000197">Deprecated:</a></b></dt><dd>Provided for backwards compatibility with the 1.6 API. </dd></dl>

</div>
</div>
<a class="anchor" id="ac47edc693b1106c9b4494017b469d206"></a><!-- doxytag: member="svn_io.h::svn_io_dir_walk2" ref="ac47edc693b1106c9b4494017b469d206" args="(const char *dirname, apr_int32_t wanted, svn_io_walk_func_t walk_func, void *walk_baton, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_dir_walk2 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dirname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_int32_t&#160;</td>
          <td class="paramname"><em>wanted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__io_8h.html#ae3dd33688b3e75430f4720f4d90c1506">svn_io_walk_func_t</a>&#160;</td>
          <td class="paramname"><em>walk_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>walk_baton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recursively walk the directory rooted at <em>dirname</em>, a utf8-encoded path, invoking <em>walk_func</em> (with <em>walk_baton</em>) for each item in the tree. </p>
<p>For a given directory, invoke <em>walk_func</em> on the directory itself before invoking it on any children thereof.</p>
<p>Deliver to <em>walk_func</em> the information specified by <em>wanted</em>, which is a combination of <code>APR_FINFO_*</code> flags, plus the information specified by <code>APR_FINFO_TYPE</code> and <code>APR_FINFO_NAME</code>.</p>
<p>Use <em>pool</em> for all allocations.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function does not currently pass all file types to <em>walk_func</em> -- only APR_DIR, APR_REG, and APR_LNK. We reserve the right to pass additional file types through this interface in the future, though, so implementations of this callback should explicitly test FINFO-&gt;filetype. See the APR library's apr_filetype_e enum for the various filetypes and their meanings.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="a48ca8a48714c0353e1246e992def863b"></a><!-- doxytag: member="svn_io.h::svn_io_dirent2_create" ref="a48ca8a48714c0353e1246e992def863b" args="(apr_pool_t *result_pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__io__dirent2__t.html">svn_io_dirent2_t</a>* svn_io_dirent2_create </td>
          <td>(</td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new <a class="el" href="structsvn__io__dirent2__t.html" title="A set of directory entry data elements as returned by svn_io_get_dirents.">svn_io_dirent2_t</a> structure. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="a4373588a310c126338eee38f6fa8f67c"></a><!-- doxytag: member="svn_io.h::svn_io_dirent2_dup" ref="a4373588a310c126338eee38f6fa8f67c" args="(const svn_io_dirent2_t *item, apr_pool_t *result_pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__io__dirent2__t.html">svn_io_dirent2_t</a>* svn_io_dirent2_dup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsvn__io__dirent2__t.html">svn_io_dirent2_t</a> *&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Duplicates a <code><a class="el" href="structsvn__io__dirent2__t.html" title="A set of directory entry data elements as returned by svn_io_get_dirents.">svn_io_dirent2_t</a></code> structure into <em>result_pool</em>. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="ae9ed0a769c24087316ebcc868fb559a0"></a><!-- doxytag: member="svn_io.h::svn_io_file_affected_time" ref="ae9ed0a769c24087316ebcc868fb559a0" args="(apr_time_t *apr_time, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_affected_time </td>
          <td>(</td>
          <td class="paramtype">apr_time_t *&#160;</td>
          <td class="paramname"><em>apr_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set <em>*apr_time</em> to the time of last modification of the contents of the file <em>path</em>. </p>
<p><em>path</em> is utf8-encoded.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is the APR mtime which corresponds to the traditional mtime on Unix, and the last write time on Windows. </dd></dl>

</div>
</div>
<a class="anchor" id="ad7384374afef049adcc8485de4083186"></a><!-- doxytag: member="svn_io.h::svn_io_file_checksum" ref="ad7384374afef049adcc8485de4083186" args="(unsigned char digest[], const char *file, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_checksum </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>digest</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Put the md5 checksum of <em>file</em> into <em>digest</em>. </p>
<p><em>digest</em> points to <code>APR_MD5_DIGESTSIZE</code> bytes of storage. Use <em>pool</em> only for temporary allocations.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000184">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.5 API. </dd></dl>

</div>
</div>
<a class="anchor" id="aa9bee2a2151cc7c57e9a01003dc6d2b6"></a><!-- doxytag: member="svn_io.h::svn_io_file_checksum2" ref="aa9bee2a2151cc7c57e9a01003dc6d2b6" args="(svn_checksum_t **checksum, const char *file, svn_checksum_kind_t kind, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_checksum2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__checksum__t.html">svn_checksum_t</a> **&#160;</td>
          <td class="paramname"><em>checksum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__checksum_8h.html#a7a6c373d03d7e6ec6b832a039f5e0aa1">svn_checksum_kind_t</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return in <em>*checksum</em> the checksum of type <em>kind</em> of <em>file</em> Use <em>pool</em> for temporary allocations and to allocate <em>*checksum</em>. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a class="anchor" id="ac53b59ed0d20666286dcc001f1aed43c"></a><!-- doxytag: member="svn_io.h::svn_io_file_close" ref="ac53b59ed0d20666286dcc001f1aed43c" args="(apr_file_t *file, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_close </td>
          <td>(</td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrapper for apr_file_close(). </p>

</div>
</div>
<a class="anchor" id="a36cd10dc8fb91f40c0df79edf8fc3a18"></a><!-- doxytag: member="svn_io.h::svn_io_file_create" ref="a36cd10dc8fb91f40c0df79edf8fc3a18" args="(const char *file, const char *contents, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create file at utf8-encoded <em>file</em> with contents <em>contents</em>. </p>
<p><em>file</em> must not already exist. Use <em>pool</em> for memory allocations. </p>

</div>
</div>
<a class="anchor" id="a1738477996c854ac51fbd77cccaddfb5"></a><!-- doxytag: member="svn_io.h::svn_io_file_flush_to_disk" ref="a1738477996c854ac51fbd77cccaddfb5" args="(apr_file_t *file, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_flush_to_disk </td>
          <td>(</td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flush any unwritten data from <em>file</em> to disk. </p>
<p>Use <em>pool</em> for memory allocations.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.1. </dd></dl>

</div>
</div>
<a class="anchor" id="a13cf1ae46bf9a45d01db6cf59d787ecd"></a><!-- doxytag: member="svn_io.h::svn_io_file_getc" ref="a13cf1ae46bf9a45d01db6cf59d787ecd" args="(char *ch, apr_file_t *file, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_getc </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrapper for apr_file_getc(). </p>

</div>
</div>
<a class="anchor" id="aa9b673694dfebc9fa7018f423b6459c3"></a><!-- doxytag: member="svn_io.h::svn_io_file_info_get" ref="aa9b673694dfebc9fa7018f423b6459c3" args="(apr_finfo_t *finfo, apr_int32_t wanted, apr_file_t *file, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_info_get </td>
          <td>(</td>
          <td class="paramtype">apr_finfo_t *&#160;</td>
          <td class="paramname"><em>finfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_int32_t&#160;</td>
          <td class="paramname"><em>wanted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrapper for apr_file_info_get(). </p>

</div>
</div>
<a class="anchor" id="a98ada015dbb0b5d467375edba000dd4b"></a><!-- doxytag: member="svn_io.h::svn_io_file_lock" ref="a98ada015dbb0b5d467375edba000dd4b" args="(const char *lock_file, svn_boolean_t exclusive, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_lock </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lock_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>exclusive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lock file at <em>lock_file</em>. </p>
<p>If <em>exclusive</em> is TRUE, obtain exclusive lock, otherwise obtain shared lock. Lock will be automatically released when <em>pool</em> is cleared or destroyed. Use <em>pool</em> for memory allocations.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000185">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.0 API. </dd></dl>

</div>
</div>
<a class="anchor" id="a256b06e01a023d03c47e8a29f8a0344a"></a><!-- doxytag: member="svn_io.h::svn_io_file_lock2" ref="a256b06e01a023d03c47e8a29f8a0344a" args="(const char *lock_file, svn_boolean_t exclusive, svn_boolean_t nonblocking, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_lock2 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lock_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>exclusive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>nonblocking</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lock file at <em>lock_file</em>. </p>
<p>If <em>exclusive</em> is TRUE, obtain exclusive lock, otherwise obtain shared lock.</p>
<p>If <em>nonblocking</em> is TRUE, do not wait for the lock if it is not available: throw an error instead.</p>
<p>Lock will be automatically released when <em>pool</em> is cleared or destroyed. Use <em>pool</em> for memory allocations.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.1. </dd></dl>

</div>
</div>
<a class="anchor" id="a2e4247ed6ed8390f4f7d68a5dea3f0e6"></a><!-- doxytag: member="svn_io.h::svn_io_file_move" ref="a2e4247ed6ed8390f4f7d68a5dea3f0e6" args="(const char *from_path, const char *to_path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_move </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Move the file from <em>from_path</em> to <em>to_path</em>, even across device boundaries. </p>
<p>Overwrite <em>to_path</em> if it exists.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is different from svn_io_file_rename in that the latter fails in the 'across device boundaries' case.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.3. </dd></dl>

</div>
</div>
<a class="anchor" id="acbcb8bfd6df6bbf9c35361b0f17f0ea7"></a><!-- doxytag: member="svn_io.h::svn_io_file_name_get" ref="acbcb8bfd6df6bbf9c35361b0f17f0ea7" args="(const char **filename, apr_file_t *file, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_name_get </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrapper for apr_file_name_get(). </p>
<p><em>*filename</em> is utf8-encoded.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The file name may be NULL.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="aaafb0039d02ec4d4393c433c9430aa48"></a><!-- doxytag: member="svn_io.h::svn_io_file_open" ref="aaafb0039d02ec4d4393c433c9430aa48" args="(apr_file_t **new_file, const char *fname, apr_int32_t flag, apr_fileperms_t perm, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_open </td>
          <td>(</td>
          <td class="paramtype">apr_file_t **&#160;</td>
          <td class="paramname"><em>new_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_int32_t&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_fileperms_t&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrapper for apr_file_open(). </p>
<p><em>fname</em> is utf8-encoded. </p>

</div>
</div>
<a class="anchor" id="a0e7664bd83efaa663977639c03da878d"></a><!-- doxytag: member="svn_io.h::svn_io_file_putc" ref="a0e7664bd83efaa663977639c03da878d" args="(char ch, apr_file_t *file, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_putc </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrapper for apr_file_putc(). </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7 </dd></dl>

</div>
</div>
<a class="anchor" id="a783e5b2a7198107666cba41642610919"></a><!-- doxytag: member="svn_io.h::svn_io_file_read" ref="a783e5b2a7198107666cba41642610919" args="(apr_file_t *file, void *buf, apr_size_t *nbytes, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_read </td>
          <td>(</td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrapper for apr_file_read(). </p>

</div>
</div>
<a class="anchor" id="a58487bc76681879193a9a067dd37b483"></a><!-- doxytag: member="svn_io.h::svn_io_file_read_full" ref="a58487bc76681879193a9a067dd37b483" args="(apr_file_t *file, void *buf, apr_size_t nbytes, apr_size_t *bytes_read, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_read_full </td>
          <td>(</td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>bytes_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Similar to svn_io_file_read_full2 with hit_eof being set to <code>NULL</code>. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000203">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.6 API </dd></dl>

</div>
</div>
<a class="anchor" id="a1230fed18c27d237e6b1747bf1daeb57"></a><!-- doxytag: member="svn_io.h::svn_io_file_read_full2" ref="a1230fed18c27d237e6b1747bf1daeb57" args="(apr_file_t *file, void *buf, apr_size_t nbytes, apr_size_t *bytes_read, svn_boolean_t *hit_eof, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_read_full2 </td>
          <td>(</td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>bytes_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *&#160;</td>
          <td class="paramname"><em>hit_eof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrapper for apr_file_read_full(). </p>
<p>If <em>hit_eof</em> is not NULL, EOF will be indicated there and no <a class="el" href="structsvn__error__t.html" title="Subversion error object.">svn_error_t</a> error object will be created upon EOF.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7 </dd></dl>

</div>
</div>
<a class="anchor" id="a958d10520c3e99ddcbbf333eed40d86f"></a><!-- doxytag: member="svn_io.h::svn_io_file_rename" ref="a958d10520c3e99ddcbbf333eed40d86f" args="(const char *from_path, const char *to_path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_rename </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rename and/or move the node (not necessarily a regular file) at <em>from_path</em> to a new path <em>to_path</em> within the same filesystem. </p>
<p>In some cases, an existing node at <em>to_path</em> will be overwritten.</p>
<p>A wrapper for apr_file_rename(). <em>from_path</em> and <em>to_path</em> are utf8-encoded. </p>

</div>
</div>
<a class="anchor" id="ab296b86da8b825399792d38f68e0e914"></a><!-- doxytag: member="svn_io.h::svn_io_file_seek" ref="ab296b86da8b825399792d38f68e0e914" args="(apr_file_t *file, apr_seek_where_t where, apr_off_t *offset, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_seek </td>
          <td>(</td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_seek_where_t&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_off_t *&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrapper for apr_file_seek(). </p>

</div>
</div>
<a class="anchor" id="aee7ca5e75c04cd6f947d87199a0313f5"></a><!-- doxytag: member="svn_io.h::svn_io_file_trunc" ref="aee7ca5e75c04cd6f947d87199a0313f5" args="(apr_file_t *file, apr_off_t offset, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_trunc </td>
          <td>(</td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_off_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrapper for apr_file_trunc(). </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a class="anchor" id="a5a78c172c69437a05e32d3dff6f152d0"></a><!-- doxytag: member="svn_io.h::svn_io_file_write" ref="a5a78c172c69437a05e32d3dff6f152d0" args="(apr_file_t *file, const void *buf, apr_size_t *nbytes, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_write </td>
          <td>(</td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrapper for apr_file_write(). </p>

</div>
</div>
<a class="anchor" id="a6789d12c70d0a2fefb539830183ee773"></a><!-- doxytag: member="svn_io.h::svn_io_file_write_full" ref="a6789d12c70d0a2fefb539830183ee773" args="(apr_file_t *file, const void *buf, apr_size_t nbytes, apr_size_t *bytes_written, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_write_full </td>
          <td>(</td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>bytes_written</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrapper for apr_file_write_full(). </p>

</div>
</div>
<a class="anchor" id="ac3ddb92f73a78796c75a0790bc9cf727"></a><!-- doxytag: member="svn_io.h::svn_io_files_contents_same_p" ref="ac3ddb92f73a78796c75a0790bc9cf727" args="(svn_boolean_t *same, const char *file1, const char *file2, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_files_contents_same_p </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *&#160;</td>
          <td class="paramname"><em>same</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set <em>*same</em> to TRUE if <em>file1</em> and <em>file2</em> have the same contents, else set it to FALSE. </p>
<p>Use <em>pool</em> for temporary allocations. </p>

</div>
</div>
<a class="anchor" id="a759d9be046832ba2e1f8d5408a7023d1"></a><!-- doxytag: member="svn_io.h::svn_io_filesizes_different_p" ref="a759d9be046832ba2e1f8d5408a7023d1" args="(svn_boolean_t *different_p, const char *file1, const char *file2, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_filesizes_different_p </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *&#160;</td>
          <td class="paramname"><em>different_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set <em>*different_p</em> to non-zero if <em>file1</em> and <em>file2</em> have different sizes, else set to zero. </p>
<p>Both <em>file1</em> and <em>file2</em> are utf8-encoded.</p>
<p>Setting <em>*different_p</em> to zero does not mean the files definitely have the same size, it merely means that the sizes are not definitely different. That is, if the size of one or both files cannot be determined, then the sizes are not known to be different, so <em>*different_p</em> is set to 0. </p>

</div>
</div>
<a class="anchor" id="a0f79a74771d956231850979d58b9106e"></a><!-- doxytag: member="svn_io.h::svn_io_get_dir_filenames" ref="a0f79a74771d956231850979d58b9106e" args="(apr_hash_t **dirents, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_get_dir_filenames </td>
          <td>(</td>
          <td class="paramtype">apr_hash_t **&#160;</td>
          <td class="paramname"><em>dirents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read all of the disk entries in directory <em>path</em>, a utf8-encoded path. </p>
<p>Set <em>*dirents</em> to a hash mapping dirent names (<code>char *</code>) to undefined non-NULL values, allocated in <em>pool</em>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The `.' and `..' directories normally returned by apr_dir_read() are NOT returned in the hash.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.4. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000194">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.6 API. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b09482c9762a2391435a6d1702d59af"></a><!-- doxytag: member="svn_io.h::svn_io_get_dirents" ref="a4b09482c9762a2391435a6d1702d59af" args="(apr_hash_t **dirents, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_get_dirents </td>
          <td>(</td>
          <td class="paramtype">apr_hash_t **&#160;</td>
          <td class="paramname"><em>dirents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Similar to <a class="el" href="svn__io_8h.html#a1583e69324a3f820894422f57fa37d57" title="Similar to svn_io_get_dirents3, but returns a mapping to svn_io_dirent_t structures instead of svn_io...">svn_io_get_dirents2()</a>, but <em>*dirents</em> is a hash table with <a class="el" href="svn__types_8h.html#aa3de517663a32716b59eabaf73c6b2bc" title="The various types of nodes in the Subversion filesystem.">svn_node_kind_t</a> values. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000196">Deprecated:</a></b></dt><dd>Provided for backwards compatibility with the 1.2 API. </dd></dl>

</div>
</div>
<a class="anchor" id="a1583e69324a3f820894422f57fa37d57"></a><!-- doxytag: member="svn_io.h::svn_io_get_dirents2" ref="a1583e69324a3f820894422f57fa37d57" args="(apr_hash_t **dirents, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_get_dirents2 </td>
          <td>(</td>
          <td class="paramtype">apr_hash_t **&#160;</td>
          <td class="paramname"><em>dirents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Similar to svn_io_get_dirents3, but returns a mapping to <a class="el" href="structsvn__io__dirent__t.html" title="Represents the kind and special status of a directory entry.">svn_io_dirent_t</a> structures instead of <a class="el" href="structsvn__io__dirent2__t.html" title="A set of directory entry data elements as returned by svn_io_get_dirents.">svn_io_dirent2_t</a> and with only a single pool. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.3. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000195">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.6 API. </dd></dl>

</div>
</div>
<a class="anchor" id="a7cf56b512d7aa14d5330d8b30eec6189"></a><!-- doxytag: member="svn_io.h::svn_io_get_dirents3" ref="a7cf56b512d7aa14d5330d8b30eec6189" args="(apr_hash_t **dirents, const char *path, svn_boolean_t only_check_type, apr_pool_t *result_pool, apr_pool_t *scratch_pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_get_dirents3 </td>
          <td>(</td>
          <td class="paramtype">apr_hash_t **&#160;</td>
          <td class="paramname"><em>dirents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>only_check_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read all of the disk entries in directory <em>path</em>, a utf8-encoded path. </p>
<p>Set <em>*dirents</em> to a hash mapping dirent names (<code>char *</code>) to <a class="el" href="structsvn__io__dirent2__t.html" title="A set of directory entry data elements as returned by svn_io_get_dirents.">svn_io_dirent2_t</a> structures, allocated in <em>pool</em>.</p>
<p>If <em>only_check_type</em> is set to <code>TRUE</code>, only the kind and special fields of the <a class="el" href="structsvn__io__dirent2__t.html" title="A set of directory entry data elements as returned by svn_io_get_dirents.">svn_io_dirent2_t</a> are filled.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The `.' and `..' directories normally returned by apr_dir_read() are NOT returned in the hash.</dd>
<dd>
The kind field in the <em>dirents</em> is set according to the mapping as documented for <a class="el" href="svn__io_8h.html#a31ee1827a2b62a2f4a122ef18e378b05" title="Determine the kind of path.">svn_io_check_path()</a>.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="a9dab9b761a5b9cae7c5610bcce781141"></a><!-- doxytag: member="svn_io.h::svn_io_is_binary_data" ref="a9dab9b761a5b9cae7c5610bcce781141" args="(const void *buf, apr_size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> svn_io_is_binary_data </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Examine up to <em>len</em> bytes of data in <em>buf</em> to determine if the can be considered binary data, in which case return TRUE. </p>
<p>If the data can be considered plain-text data, return FALSE.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="a2cb981f75792c99480f93b83ae9265d2"></a><!-- doxytag: member="svn_io.h::svn_io_is_file_executable" ref="a2cb981f75792c99480f93b83ae9265d2" args="(svn_boolean_t *executable, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_is_file_executable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *&#160;</td>
          <td class="paramname"><em>executable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine whether a file is executable by the current user. </p>
<p>Set <em>*executable</em> to <code>TRUE</code> if the file <em>path</em> is executable by the current user, otherwise set it to <code>FALSE</code>.</p>
<p>On Windows and on platforms without userids, always returns <code>FALSE</code>. </p>

</div>
</div>
<a class="anchor" id="a0ef4d0c5c6a86ab48f515b4a31efad70"></a><!-- doxytag: member="svn_io.h::svn_io_make_dir_recursively" ref="a0ef4d0c5c6a86ab48f515b4a31efad70" args="(const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_make_dir_recursively </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create directory <em>path</em> on the file system, creating intermediate directories as required, like <code>mkdir -p</code>. </p>
<p>Report no error if <em>path</em> already exists. <em>path</em> is utf8-encoded.</p>
<p>This is essentially a wrapper for apr_dir_make_recursive(), passing <code>APR_OS_DEFAULT</code> as the permissions. </p>

</div>
</div>
<a class="anchor" id="a2384857ad348105316edf6d1036d599f"></a><!-- doxytag: member="svn_io.h::svn_io_open_unique_file" ref="a2384857ad348105316edf6d1036d599f" args="(apr_file_t **f, const char **unique_name_p, const char *path, const char *suffix, svn_boolean_t delete_on_close, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_open_unique_file </td>
          <td>(</td>
          <td class="paramtype">apr_file_t **&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>unique_name_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>suffix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>delete_on_close</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like svn_io_open_unique_file2, but can't delete on pool cleanup. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000182">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.3 API</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>In 1.4 the API was extended to require either <em>f</em> or <em>unique_name_p</em> (the other can be NULL). Before that, both were required. </dd></dl>

</div>
</div>
<a class="anchor" id="a58df63b2898a8a2a7df988b2d633eb1a"></a><!-- doxytag: member="svn_io.h::svn_io_open_unique_file2" ref="a58df63b2898a8a2a7df988b2d633eb1a" args="(apr_file_t **f, const char **unique_name_p, const char *path, const char *suffix, svn_io_file_del_t delete_when, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_open_unique_file2 </td>
          <td>(</td>
          <td class="paramtype">apr_file_t **&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>unique_name_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>suffix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__io_8h.html#aa78fffc81af962281813070c753d7884">svn_io_file_del_t</a>&#160;</td>
          <td class="paramname"><em>delete_when</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like <a class="el" href="svn__io_8h.html#a280a68283cb7852fe1f4c5835f0b8fdf" title="Open a new file (for reading and writing) with a unique name based on utf-8 encoded filename...">svn_io_open_uniquely_named()</a>, but takes a joined dirpath and filename, and a single pool. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.4</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000181">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.5 API </dd></dl>

</div>
</div>
<a class="anchor" id="ad1a7a7299bfe130c25becdd56ff0e870"></a><!-- doxytag: member="svn_io.h::svn_io_open_unique_file3" ref="ad1a7a7299bfe130c25becdd56ff0e870" args="(apr_file_t **file, const char **temp_path, const char *dirpath, svn_io_file_del_t delete_when, apr_pool_t *result_pool, apr_pool_t *scratch_pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_open_unique_file3 </td>
          <td>(</td>
          <td class="paramtype">apr_file_t **&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>temp_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dirpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__io_8h.html#aa78fffc81af962281813070c753d7884">svn_io_file_del_t</a>&#160;</td>
          <td class="paramname"><em>delete_when</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a writable file, with an arbitrary and unique name, in the directory <em>dirpath</em>. </p>
<p>Set <em>*temp_path</em> to its full path, and set <em>*file</em> to the file handle, both allocated from <em>result_pool</em>. Either <em>file</em> or <em>unique_name</em> may be <code>NULL</code>. If <em>file</em> is <code>NULL</code>, the file will be created but not open.</p>
<p>If <em>dirpath</em> is <code>NULL</code>, use the path returned from <a class="el" href="svn__io_8h.html#afbb4b86585411439008e934ede6f8b39" title="Set *dir to a directory path (allocated in pool) deemed usable for the creation of temporary files an...">svn_io_temp_dir()</a>. (Note that when using the system-provided temp directory, it may not be possible to atomically rename the resulting file due to cross-device issues.)</p>
<p>The file will be deleted according to <em>delete_when</em>. If <em>delete_when</em> is <code>svn_io_file_del_on_close</code> and <em>file</em> is <code>NULL</code>, the file will be deleted before this function returns.</p>
<p>When passing <code>svn_io_file_del_none</code> please don't forget to eventually remove the temporary file to avoid filling up the system temp directory. It is often appropriate to bind the lifetime of the temporary file to the lifetime of a pool by using <code>svn_io_file_del_on_pool_cleanup</code>.</p>
<p>Temporary allocations will be performed in <em>scratch_pool</em>.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.6 </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__svn__io__byte__streams.html#ga821ab7add7a0216c86b1a7f94456fae9" title="Create a writable stream to a file in the directory dirpath.">svn_stream_open_unique()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a280a68283cb7852fe1f4c5835f0b8fdf"></a><!-- doxytag: member="svn_io.h::svn_io_open_uniquely_named" ref="a280a68283cb7852fe1f4c5835f0b8fdf" args="(apr_file_t **file, const char **unique_name, const char *dirpath, const char *filename, const char *suffix, svn_io_file_del_t delete_when, apr_pool_t *result_pool, apr_pool_t *scratch_pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_open_uniquely_named </td>
          <td>(</td>
          <td class="paramtype">apr_file_t **&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>unique_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dirpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>suffix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__io_8h.html#aa78fffc81af962281813070c753d7884">svn_io_file_del_t</a>&#160;</td>
          <td class="paramname"><em>delete_when</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open a new file (for reading and writing) with a unique name based on utf-8 encoded <em>filename</em>, in the directory <em>dirpath</em>. </p>
<p>The file handle is returned in <em>*file</em>, and the name, which ends with <em>suffix</em>, is returned in <em>*unique_name</em>, also utf8-encoded. Either <em>file</em> or <em>unique_name</em> may be <code>NULL</code>. If <em>file</em> is <code>NULL</code>, the file will be created but not open.</p>
<p>If <em>delete_when</em> is <a class="el" href="svn__io_8h.html#aa78fffc81af962281813070c753d7884a6256344ca6b43868daa12365d75834d2" title="Remove when the file is closed.">svn_io_file_del_on_close</a>, then the <code>APR_DELONCLOSE</code> flag will be used when opening the file. The <code>APR_BUFFERED</code> flag will always be used.</p>
<p>The first attempt will just append <em>suffix</em>. If the result is not a unique name, then subsequent attempts will append a dot, followed by an iteration number ("2", then "3", and so on), followed by the suffix. For example, successive calls to</p>
<p>svn_io_open_uniquely_named(&amp;f, &amp;u, "tests/t1/A/D/G", "pi", ".tmp", ...)</p>
<p>will open</p>
<p>tests/t1/A/D/G/pi.tmp tests/t1/A/D/G/pi.2.tmp tests/t1/A/D/G/pi.3.tmp tests/t1/A/D/G/pi.4.tmp tests/t1/A/D/G/pi.5.tmp ...</p>
<p>Assuming <em>suffix</em> is non-empty, <em>*unique_name</em> will never be exactly the same as <em>filename</em>, even if <em>filename</em> does not exist.</p>
<p>If <em>dirpath</em> is NULL, then the directory returned by <a class="el" href="svn__io_8h.html#afbb4b86585411439008e934ede6f8b39" title="Set *dir to a directory path (allocated in pool) deemed usable for the creation of temporary files an...">svn_io_temp_dir()</a> will be used.</p>
<p>If <em>filename</em> is NULL, then "tempfile" will be used.</p>
<p>If <em>suffix</em> is NULL, then ".tmp" will be used.</p>
<p>Allocates <em>*file</em> and <em>*unique_name</em> in <em>result_pool</em>. All intermediate allocations will be performed in <em>scratch_pool</em>.</p>
<p>If no unique name can be found, <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660aedfce6b4da833af3b1c17b0c4ea57946" title="&quot;Ran out of unique names&quot;">SVN_ERR_IO_UNIQUE_NAMES_EXHAUSTED</a> is the error returned.</p>
<p>Claim of Historical Inevitability: this function was written because</p>
<ul>
<li>tmpnam() is not thread-safe.</li>
<li>tempname() tries standard system tmp areas first.</li>
</ul>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.6 </dd></dl>

</div>
</div>
<a class="anchor" id="ac4625a082416ccaafdd77e35e14ec4d4"></a><!-- doxytag: member="svn_io.h::svn_io_parse_mimetypes_file" ref="ac4625a082416ccaafdd77e35e14ec4d4" args="(apr_hash_t **type_map, const char *mimetypes_file, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_parse_mimetypes_file </td>
          <td>(</td>
          <td class="paramtype">apr_hash_t **&#160;</td>
          <td class="paramname"><em>type_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mimetypes_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parse utf8-encoded <em>mimetypes_file</em> as a MIME types file (such as is provided with Apache HTTP Server), and set <em>*type_map</em> to a hash mapping <code>const char *</code> filename extensions to <code>const char *</code> MIME types. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="ab3f73a4554d78dbbc3d9e0f29943380e"></a><!-- doxytag: member="svn_io.h::svn_io_read_length_line" ref="ab3f73a4554d78dbbc3d9e0f29943380e" args="(apr_file_t *file, char *buf, apr_size_t *limit, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_read_length_line </td>
          <td>(</td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a line from <em>file</em> into <em>buf</em>, but not exceeding <em>*limit</em> bytes. </p>
<p>Does not include newline, instead '\0' is put there. Length (as in strlen) is returned in <em>*limit</em>. <em>buf</em> should be pre-allocated. <em>file</em> should be already opened.</p>
<p>When the file is out of lines, <code>APR_EOF</code> will be returned. </p>

</div>
</div>
<a class="anchor" id="a94e184ae6677e8b0b4cae0ec145b7b67"></a><!-- doxytag: member="svn_io.h::svn_io_read_link" ref="a94e184ae6677e8b0b4cae0ec145b7b67" args="(svn_string_t **dest, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_read_link </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__string__t.html">svn_string_t</a> **&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set <em>*dest</em> to the path that the symlink at <em>path</em> references. </p>
<p>Allocate the string from <em>pool</em>.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.1. </dd></dl>

</div>
</div>
<a class="anchor" id="ad7a26505bf041286d02793eb2a17be04"></a><!-- doxytag: member="svn_io.h::svn_io_remove_dir" ref="ad7a26505bf041286d02793eb2a17be04" args="(const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_remove_dir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Similar to <a class="el" href="svn__io_8h.html#a9a26dab3678b7ee9c8ebdb8e1d60aedc" title="Recursively remove directory path.">svn_io_remove_dir2()</a>, but with <em>ignore_enoent</em> set to <code>FALSE</code> and <em>cancel_func</em> and <em>cancel_baton</em> set to <code>NULL</code>. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000193">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.4 API </dd></dl>

</div>
</div>
<a class="anchor" id="a9a26dab3678b7ee9c8ebdb8e1d60aedc"></a><!-- doxytag: member="svn_io.h::svn_io_remove_dir2" ref="a9a26dab3678b7ee9c8ebdb8e1d60aedc" args="(const char *path, svn_boolean_t ignore_enoent, svn_cancel_func_t cancel_func, void *cancel_baton, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_remove_dir2 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>ignore_enoent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#addaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a>&#160;</td>
          <td class="paramname"><em>cancel_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cancel_baton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recursively remove directory <em>path</em>. </p>
<p><em>path</em> is utf8-encoded. If <em>ignore_enoent</em> is <code>TRUE</code>, don't fail if the target directory doesn't exist. Use <em>pool</em> for temporary allocations.</p>
<p>Because recursive delete of a directory tree can be a lengthy operation, provide <em>cancel_func</em> and <em>cancel_baton</em> for interruptibility.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="abce28e789f76b15917b28b157d54dcfb"></a><!-- doxytag: member="svn_io.h::svn_io_remove_file" ref="abce28e789f76b15917b28b157d54dcfb" args="(const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_remove_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Similar to <a class="el" href="svn__io_8h.html#a528121fa3625ec79bea870b5e53d98c6" title="Remove file path, a utf8-encoded path.">svn_io_remove_file2()</a>, except with <em>ignore_enoent</em> set to FALSE. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000192">Deprecated:</a></b></dt><dd>Provided for backwards compatibility with the 1.6 API. </dd></dl>

</div>
</div>
<a class="anchor" id="a528121fa3625ec79bea870b5e53d98c6"></a><!-- doxytag: member="svn_io.h::svn_io_remove_file2" ref="a528121fa3625ec79bea870b5e53d98c6" args="(const char *path, svn_boolean_t ignore_enoent, apr_pool_t *scratch_pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_remove_file2 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>ignore_enoent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove file <em>path</em>, a utf8-encoded path. </p>
<p>This wraps apr_file_remove(), converting any error to a Subversion error. If <em>ignore_enoent</em> is TRUE, and the file is not present (APR_STATUS_IS_ENOENT returns TRUE), then no error will be returned.</p>
<p>The file will be removed even if it is not writable. (On Windows and OS/2, this function first clears the file's read-only bit.)</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="ab59c1c8d67cf405ca36a5556858da82d"></a><!-- doxytag: member="svn_io.h::svn_io_run_cmd" ref="ab59c1c8d67cf405ca36a5556858da82d" args="(const char *path, const char *cmd, const char *const *args, int *exitcode, apr_exit_why_e *exitwhy, svn_boolean_t inherit, apr_file_t *infile, apr_file_t *outfile, apr_file_t *errfile, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_run_cmd </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>exitcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_exit_why_e *&#160;</td>
          <td class="paramname"><em>exitwhy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>inherit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>infile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>outfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>errfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Run a command to completion, by first calling <a class="el" href="svn__io_8h.html#a4ee2641c854734f78337aee204b79201" title="Similar to svn_io_start_cmd2() but with infile_pipe, outfile_pipe, and errfile_pipe always FALSE...">svn_io_start_cmd()</a> and then calling <a class="el" href="svn__io_8h.html#acc0478196081ff559613daf3ac8a39c7" title="Wait for the process *cmd_proc to complete and optionally retrieve its exit code.">svn_io_wait_for_cmd()</a>. </p>
<p>The parameters correspond to the same-named parameters of those two functions. </p>

</div>
</div>
<a class="anchor" id="a6c0266e00c285a0b90eef9faf0e31024"></a><!-- doxytag: member="svn_io.h::svn_io_run_diff" ref="a6c0266e00c285a0b90eef9faf0e31024" args="(const char *dir, const char *const *user_args, int num_user_args, const char *label1, const char *label2, const char *from, const char *to, int *exitcode, apr_file_t *outfile, apr_file_t *errfile, const char *diff_cmd, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_run_diff </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>user_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_user_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>exitcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>outfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>errfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>diff_cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Similar to <a class="el" href="svn__io_8h.html#acabda4f4f591bec06ece8e35829a79f4" title="Invoke the configured diff program, with user_args (an array of utf8-encoded num_user_args arguments)...">svn_io_run_diff2()</a> but with <em>diff_cmd</em> encoded in internal encoding used by APR. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000199">Deprecated:</a></b></dt><dd>Provided for backwards compatibility with the 1.5 API. </dd></dl>

</div>
</div>
<a class="anchor" id="acabda4f4f591bec06ece8e35829a79f4"></a><!-- doxytag: member="svn_io.h::svn_io_run_diff2" ref="acabda4f4f591bec06ece8e35829a79f4" args="(const char *dir, const char *const *user_args, int num_user_args, const char *label1, const char *label2, const char *from, const char *to, int *exitcode, apr_file_t *outfile, apr_file_t *errfile, const char *diff_cmd, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_run_diff2 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>user_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_user_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>exitcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>outfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>errfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>diff_cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Invoke the configured <code>diff</code> program, with <em>user_args</em> (an array of utf8-encoded <em>num_user_args</em> arguments) if they are specified (that is, if <em>user_args</em> is non-NULL), or "-u" if they are not. </p>
<p>If <em>user_args</em> is NULL, the value of <em>num_user_args</em> is ignored.</p>
<p>Diff runs in utf8-encoded <em>dir</em>, and its exit status is stored in <em>exitcode</em>, if it is not <code>NULL</code>.</p>
<p>If <em>label1</em> and/or <em>label2</em> are not NULL they will be passed to the diff process as the arguments of "-L" options. <em>label1</em> and <em>label2</em> are also in utf8, and will be converted to native charset along with the other args.</p>
<p><em>from</em> is the first file passed to diff, and <em>to</em> is the second. The stdout of diff will be sent to <em>outfile</em>, and the stderr to <em>errfile</em>.</p>
<p><em>diff_cmd</em> must be non-NULL.</p>
<p>Do all allocation in <em>pool</em>. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.6.0. </dd></dl>

</div>
</div>
<a class="anchor" id="ae800def15e3ffc5e1645b296c4e7a1ca"></a><!-- doxytag: member="svn_io.h::svn_io_run_diff3" ref="ae800def15e3ffc5e1645b296c4e7a1ca" args="(const char *dir, const char *mine, const char *older, const char *yours, const char *mine_label, const char *older_label, const char *yours_label, apr_file_t *merged, int *exitcode, const char *diff3_cmd, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_run_diff3 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>older</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>yours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mine_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>older_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>yours_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>merged</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>exitcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>diff3_cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Similar to <a class="el" href="svn__io_8h.html#a284650316c8ceefd30c4dae9aef49ec4" title="Similar to svn_io_run_diff3_3(), but with diff3_cmd encoded in internal encoding used by APR...">svn_io_run_diff3_2()</a>, but with <em>user_args</em> set to <code>NULL</code>. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000201">Deprecated:</a></b></dt><dd>Provided for backwards compatibility with the 1.3 API. </dd></dl>

</div>
</div>
<a class="anchor" id="a284650316c8ceefd30c4dae9aef49ec4"></a><!-- doxytag: member="svn_io.h::svn_io_run_diff3_2" ref="a284650316c8ceefd30c4dae9aef49ec4" args="(int *exitcode, const char *dir, const char *mine, const char *older, const char *yours, const char *mine_label, const char *older_label, const char *yours_label, apr_file_t *merged, const char *diff3_cmd, const apr_array_header_t *user_args, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_run_diff3_2 </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>exitcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>older</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>yours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mine_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>older_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>yours_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>merged</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>diff3_cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const apr_array_header_t *&#160;</td>
          <td class="paramname"><em>user_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Similar to <a class="el" href="svn__io_8h.html#a0ef4f589d31a5578526c3de2d0587cf7" title="Invoke the configured diff3 program, in utf8-encoded dir like this:">svn_io_run_diff3_3()</a>, but with <em>diff3_cmd</em> encoded in internal encoding used by APR. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000200">Deprecated:</a></b></dt><dd>Provided for backwards compatibility with the 1.5 API. </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.4. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ef4f589d31a5578526c3de2d0587cf7"></a><!-- doxytag: member="svn_io.h::svn_io_run_diff3_3" ref="a0ef4f589d31a5578526c3de2d0587cf7" args="(int *exitcode, const char *dir, const char *mine, const char *older, const char *yours, const char *mine_label, const char *older_label, const char *yours_label, apr_file_t *merged, const char *diff3_cmd, const apr_array_header_t *user_args, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_run_diff3_3 </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>exitcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>older</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>yours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mine_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>older_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>yours_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>merged</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>diff3_cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const apr_array_header_t *&#160;</td>
          <td class="paramname"><em>user_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Invoke the configured <code>diff3</code> program, in utf8-encoded <em>dir</em> like this: </p>
<p>diff3 -E -m <em>mine</em> <em>older</em> <em>yours</em> &gt; <em>merged</em> </p>
<p>(See the diff3 documentation for details.)</p>
<p>If <em>user_args</em> is non-NULL, replace "-E" with the <code>const char*</code> elements that <em>user_args</em> contains.</p>
<p><em>mine</em>, <em>older</em> and <em>yours</em> are utf8-encoded paths (relative to <em>dir</em> or absolute) to three files that already exist.</p>
<p><em>merged</em> is an open file handle, and is left open after the merge result is written to it. (<em>merged</em> should *not* be the same file as <em>mine</em>, or nondeterministic things may happen!)</p>
<p><em>mine_label</em>, <em>older_label</em>, <em>yours_label</em> are utf8-encoded label parameters for diff3's -L option. Any of them may be <code>NULL</code>, in which case the corresponding <em>mine</em>, <em>older</em>, or <em>yours</em> parameter is used instead.</p>
<p>Set <em>*exitcode</em> to diff3's exit status. If <em>*exitcode</em> is anything other than 0 or 1, then return <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660a9638ec0a50748fe97beb95d6befb73ca" title="&quot;Error calling external program&quot;">SVN_ERR_EXTERNAL_PROGRAM</a>. (Note the following from the diff3 info pages: "An exit status of 0 means `diff3' was successful, 1 means some conflicts were found, and 2 means trouble.")</p>
<p><em>diff3_cmd</em> must be non-NULL.</p>
<p>Do all allocation in <em>pool</em>.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.4. </dd></dl>

</div>
</div>
<a class="anchor" id="a474cc5427ee6e900ff8c96559e368fe6"></a><!-- doxytag: member="svn_io.h::svn_io_set_file_affected_time" ref="a474cc5427ee6e900ff8c96559e368fe6" args="(apr_time_t apr_time, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_set_file_affected_time </td>
          <td>(</td>
          <td class="paramtype">apr_time_t&#160;</td>
          <td class="paramname"><em>apr_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the timestamp of file <em>path</em> to <em>apr_time</em>. </p>
<p><em>path</em> is utf8-encoded.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is the APR mtime which corresponds to the traditional mtime on Unix, and the last write time on Windows. </dd></dl>

</div>
</div>
<a class="anchor" id="a358a735a173b43509cf4060b73930cf5"></a><!-- doxytag: member="svn_io.h::svn_io_set_file_executable" ref="a358a735a173b43509cf4060b73930cf5" args="(const char *path, svn_boolean_t executable, svn_boolean_t ignore_enoent, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_set_file_executable </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>executable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>ignore_enoent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set <em>path's</em> "executability" (but do nothing if it is a symlink). </p>
<p><em>path</em> is the utf8-encoded path to the file. If <em>executable</em> is <code>TRUE</code>, then make the file executable. If <code>FALSE</code>, make it non-executable. If <em>ignore_enoent</em> is <code>TRUE</code>, don't fail if the target file doesn't exist.</p>
<p>When making the file executable on operating systems with unix style permissions, never add an execute permission where there is not already a read permission: that is, only make the file executable for the user, group or world if the corresponding read permission is already set for user, group or world.</p>
<p>When making the file non-executable on operating systems with unix style permissions, remove all execute permissions.</p>
<p>On other operating systems, toggle the file's "executability" as much as the operating system allows.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If <em>path</em> is a directory, act on it as though it were a file, as described above, but note that you probably don't want to call this function on directories. We have left it effective on directories for compatibility reasons, but as its name implies, it should be used only for files. </dd></dl>

</div>
</div>
<a class="anchor" id="a185f4ee690965e622aa1748339847ae5"></a><!-- doxytag: member="svn_io.h::svn_io_set_file_read_only" ref="a185f4ee690965e622aa1748339847ae5" args="(const char *path, svn_boolean_t ignore_enoent, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_set_file_read_only </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>ignore_enoent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a file as read-only as the operating system allows. </p>
<p><em>path</em> is the utf8-encoded path to the file. If <em>ignore_enoent</em> is <code>TRUE</code>, don't fail if the target file doesn't exist.</p>
<p>If <em>path</em> is a symlink, do nothing.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If <em>path</em> is a directory, act on it as though it were a file, as described above, but note that you probably don't want to call this function on directories. We have left it effective on directories for compatibility reasons, but as its name implies, it should be used only for files. </dd></dl>

</div>
</div>
<a class="anchor" id="ac407a16bc12b63d2e57a3e2375490ad5"></a><!-- doxytag: member="svn_io.h::svn_io_set_file_read_write" ref="ac407a16bc12b63d2e57a3e2375490ad5" args="(const char *path, svn_boolean_t ignore_enoent, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_set_file_read_write </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>ignore_enoent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a file as writable as the operating system allows. </p>
<p><em>path</em> is the utf8-encoded path to the file. If <em>ignore_enoent</em> is <code>TRUE</code>, don't fail if the target file doesn't exist. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>On Unix this function will do the equivalent of chmod a+w path. If this is not what you want you should not use this function, but rather use apr_file_perms_set().</dd></dl>
<p>If <em>path</em> is a symlink, do nothing.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If <em>path</em> is a directory, act on it as though it were a file, as described above, but note that you probably don't want to call this function on directories. We have left it effective on directories for compatibility reasons, but as its name implies, it should be used only for files. </dd></dl>

</div>
</div>
<a class="anchor" id="a02cd461341834d955e258a70def4f56f"></a><!-- doxytag: member="svn_io.h::svn_io_set_file_read_write_carefully" ref="a02cd461341834d955e258a70def4f56f" args="(const char *path, svn_boolean_t enable_write, svn_boolean_t ignore_enoent, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_set_file_read_write_carefully </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>enable_write</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>ignore_enoent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Similar to svn_io_set_file_read_* functions. </p>
<p>Change the read-write permissions of a file. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.1.</dd></dl>
<p>When making <em>path</em> read-write on operating systems with unix style permissions, set the permissions on <em>path</em> to the permissions that are set when a new file is created (effectively honoring the user's umask).</p>
<p>When making the file read-only on operating systems with unix style permissions, remove all write permissions.</p>
<p>On other operating systems, toggle the file's "writability" as much as the operating system allows.</p>
<p><em>path</em> is the utf8-encoded path to the file. If <em>enable_write</em> is <code>TRUE</code>, then make the file read-write. If <code>FALSE</code>, make it read-only. If <em>ignore_enoent</em> is <code>TRUE</code>, don't fail if the target file doesn't exist.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000183">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.3 API. </dd></dl>

</div>
</div>
<a class="anchor" id="a07a20fcb725f0941e6c53410ad5c12e4"></a><!-- doxytag: member="svn_io.h::svn_io_sleep_for_timestamps" ref="a07a20fcb725f0941e6c53410ad5c12e4" args="(const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_io_sleep_for_timestamps </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sleep to ensure that any files modified after we exit have a different timestamp than the one we recorded. </p>
<p>If <em>path</em> is not NULL, check if we can determine how long we should wait for a new timestamp on the filesystem containing <em>path</em>, an existing file or directory. If <em>path</em> is NULL or we can't determine the timestamp resolution, sleep until the next second.</p>
<p>Use <em>pool</em> for any necessary allocations. <em>pool</em> can be null if <em>path</em> is NULL.</p>
<p>Errors while retrieving the timestamp resolution will result in sleeping to the next second, to keep the working copy stable in error conditions.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a class="anchor" id="a4ee2641c854734f78337aee204b79201"></a><!-- doxytag: member="svn_io.h::svn_io_start_cmd" ref="a4ee2641c854734f78337aee204b79201" args="(apr_proc_t *cmd_proc, const char *path, const char *cmd, const char *const *args, svn_boolean_t inherit, apr_file_t *infile, apr_file_t *outfile, apr_file_t *errfile, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_start_cmd </td>
          <td>(</td>
          <td class="paramtype">apr_proc_t *&#160;</td>
          <td class="paramname"><em>cmd_proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>inherit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>infile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>outfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>errfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Similar to <a class="el" href="svn__io_8h.html#aa9e4a63f9f1c86d6ff712bcb6d51ddf4" title="Start cmd with args, using utf8-encoded path as working directory.">svn_io_start_cmd2()</a> but with <em>infile_pipe</em>, <em>outfile_pipe</em>, and <em>errfile_pipe</em> always FALSE. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000198">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.6 API </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.3. </dd></dl>

</div>
</div>
<a class="anchor" id="aa9e4a63f9f1c86d6ff712bcb6d51ddf4"></a><!-- doxytag: member="svn_io.h::svn_io_start_cmd2" ref="aa9e4a63f9f1c86d6ff712bcb6d51ddf4" args="(apr_proc_t *cmd_proc, const char *path, const char *cmd, const char *const *args, svn_boolean_t inherit, svn_boolean_t infile_pipe, apr_file_t *infile, svn_boolean_t outfile_pipe, apr_file_t *outfile, svn_boolean_t errfile_pipe, apr_file_t *errfile, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_start_cmd2 </td>
          <td>(</td>
          <td class="paramtype">apr_proc_t *&#160;</td>
          <td class="paramname"><em>cmd_proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>inherit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>infile_pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>infile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>outfile_pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>outfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>errfile_pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>errfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start <em>cmd</em> with <em>args</em>, using utf8-encoded <em>path</em> as working directory. </p>
<p>Return the process handle for the invoked program in <em>*cmd_proc</em>.</p>
<p>If <em>infile_pipe</em> is TRUE, connect <em>cmd's</em> stdin to a pipe; otherwise, connect it to <em>infile</em> (which may be NULL). If <em>outfile_pipe</em> is TRUE, connect <em>cmd's</em> stdout to a pipe; otherwise, connect it to <em>outfile</em> (which may be NULL). If <em>errfile_pipe</em> is TRUE, connect <em>cmd's</em> stderr to a pipe; otherwise, connect it to <em>errfile</em> (which may be NULL). (Callers must pass FALSE for each of these boolean values for which the corresponding file handle is non-NULL.)</p>
<p><em>args</em> is a list of utf8-encoded <code>const char *</code> arguments, terminated by <code>NULL</code>. <em>args</em>[0] is the name of the program, though it need not be the same as <em>cmd</em>.</p>
<p>If <em>inherit</em> is TRUE, the invoked program inherits its environment from the caller and <em>cmd</em>, if not absolute, is searched for in PATH. Otherwise, the invoked program runs with an empty environment and <em>cmd</em> must be an absolute path.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>On some platforms, failure to execute <em>cmd</em> in the child process will result in error output being written to <em>errfile</em>, if non-NULL, and a non-zero exit status being returned to the parent process.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="a8b3c8bc2bdde3a1a28eb402432e410e0"></a><!-- doxytag: member="svn_io.h::svn_io_stat" ref="a8b3c8bc2bdde3a1a28eb402432e410e0" args="(apr_finfo_t *finfo, const char *fname, apr_int32_t wanted, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_stat </td>
          <td>(</td>
          <td class="paramtype">apr_finfo_t *&#160;</td>
          <td class="paramname"><em>finfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_int32_t&#160;</td>
          <td class="paramname"><em>wanted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrapper for apr_stat(). </p>
<p><em>fname</em> is utf8-encoded. </p>

</div>
</div>
<a class="anchor" id="a5f173471fff3a277d315845056e61f94"></a><!-- doxytag: member="svn_io.h::svn_io_stat_dirent" ref="a5f173471fff3a277d315845056e61f94" args="(const svn_io_dirent2_t **dirent_p, const char *path, svn_boolean_t ignore_enoent, apr_pool_t *result_pool, apr_pool_t *scratch_pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_stat_dirent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsvn__io__dirent2__t.html">svn_io_dirent2_t</a> **&#160;</td>
          <td class="paramname"><em>dirent_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>ignore_enoent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a <a class="el" href="structsvn__io__dirent2__t.html" title="A set of directory entry data elements as returned by svn_io_get_dirents.">svn_io_dirent2_t</a> instance for path. </p>
<p>Specialized variant of <a class="el" href="svn__io_8h.html#a8b3c8bc2bdde3a1a28eb402432e410e0" title="Wrapper for apr_stat().">svn_io_stat()</a> that directly translates node_kind and special.</p>
<p>If <em>ignore_enoent</em> is set to <code>TRUE</code>, set *dirent_p-&gt;kind to svn_node_none instead of returning an error.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="acc0478196081ff559613daf3ac8a39c7"></a><!-- doxytag: member="svn_io.h::svn_io_wait_for_cmd" ref="acc0478196081ff559613daf3ac8a39c7" args="(apr_proc_t *cmd_proc, const char *cmd, int *exitcode, apr_exit_why_e *exitwhy, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_wait_for_cmd </td>
          <td>(</td>
          <td class="paramtype">apr_proc_t *&#160;</td>
          <td class="paramname"><em>cmd_proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>exitcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_exit_why_e *&#160;</td>
          <td class="paramname"><em>exitwhy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for the process <em>*cmd_proc</em> to complete and optionally retrieve its exit code. </p>
<p><em>cmd</em> is used only in error messages.</p>
<p>If <em>exitcode</em> is not NULL, set <em>*exitcode</em> to the exit code of the process and do not consider any exit code to be an error. If <em>exitcode</em> is NULL, then if the exit code of the process is non-zero then return an <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660a9638ec0a50748fe97beb95d6befb73ca" title="&quot;Error calling external program&quot;">SVN_ERR_EXTERNAL_PROGRAM</a> error.</p>
<p>If <em>exitwhy</em> is not NULL, set <em>*exitwhy</em> to indicate why the process terminated and do not consider any reason to be an error. If <em>exitwhy</em> is NULL, then if the termination reason is not <code>APR_PROC_CHECK_EXIT()</code> then return an <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660a9638ec0a50748fe97beb95d6befb73ca" title="&quot;Error calling external program&quot;">SVN_ERR_EXTERNAL_PROGRAM</a> error.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.3. </dd></dl>

</div>
</div>
<a class="anchor" id="aabcfef527a38cb25dde9f1e1565bf578"></a><!-- doxytag: member="svn_io.h::svn_io_write_unique" ref="aabcfef527a38cb25dde9f1e1565bf578" args="(const char **tmp_path, const char *dirpath, const void *buf, apr_size_t nbytes, svn_io_file_del_t delete_when, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_write_unique </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>tmp_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dirpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__io_8h.html#aa78fffc81af962281813070c753d7884">svn_io_file_del_t</a>&#160;</td>
          <td class="paramname"><em>delete_when</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open a unique file in <em>dirpath</em>, and write <em>nbytes</em> from <em>buf</em> to the file before flushing it to disk and closing it. </p>
<p>Return the name of the newly created file in <em>*tmp_path</em>, allocated in <em>pool</em>.</p>
<p>If <em>dirpath</em> is <code>NULL</code>, use the path returned from <a class="el" href="svn__io_8h.html#afbb4b86585411439008e934ede6f8b39" title="Set *dir to a directory path (allocated in pool) deemed usable for the creation of temporary files an...">svn_io_temp_dir()</a>. (Note that when using the system-provided temp directory, it may not be possible to atomically rename the resulting file due to cross-device issues.)</p>
<p>The file will be deleted according to <em>delete_when</em>.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a class="anchor" id="a59b7be5b78cc045ed972b226e06ab509"></a><!-- doxytag: member="svn_io.h::svn_stringbuf_from_aprfile" ref="a59b7be5b78cc045ed972b226e06ab509" args="(svn_stringbuf_t **result, apr_file_t *file, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stringbuf_from_aprfile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> **&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets <em>*result</em> to a string containing the contents of the already opened <em>file</em>. </p>
<p>Reads from the current position in file to the end. Does not close the file or reset the cursor position.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>due to memory pseudo-reallocation behavior (due to pools), this can be a memory-intensive operation for large files. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ffefcabf44f9e9fb2f71d409fcf782e"></a><!-- doxytag: member="svn_io.h::svn_stringbuf_from_file" ref="a2ffefcabf44f9e9fb2f71d409fcf782e" args="(svn_stringbuf_t **result, const char *filename, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stringbuf_from_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> **&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Similar to <a class="el" href="svn__io_8h.html#a9135b41547d59296fc54c8316278a0d6" title="Set *result to a string containing the contents of filename, which is either &quot;-&quot; (indicating that std...">svn_stringbuf_from_file2()</a>, except that if <em>filename</em> is "-", return the error <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660a4152fa8f6143f7bcd6f2f7d656096c8b" title="&quot;Trying to use an unsupported feature&quot;">SVN_ERR_UNSUPPORTED_FEATURE</a> and don't touch <em>*result</em>. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000191">Deprecated:</a></b></dt><dd>Provided for backwards compatibility with the 1.4 API. </dd></dl>

</div>
</div>
<a class="anchor" id="a9135b41547d59296fc54c8316278a0d6"></a><!-- doxytag: member="svn_io.h::svn_stringbuf_from_file2" ref="a9135b41547d59296fc54c8316278a0d6" args="(svn_stringbuf_t **result, const char *filename, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stringbuf_from_file2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> **&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set <em>*result</em> to a string containing the contents of <em>filename</em>, which is either "-" (indicating that stdin should be read) or the utf8-encoded path of a real file. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Callers should be aware of possible unexpected results when using this function to read from stdin where additional stdin-reading processes abound. For example, if a program tries both to invoke an external editor and to read from stdin, stdin could be trashed and the editor might act funky or die outright.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>due to memory pseudo-reallocation behavior (due to pools), this can be a memory-intensive operation for large files.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 23 2011 09:20:39 for Subversion by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
