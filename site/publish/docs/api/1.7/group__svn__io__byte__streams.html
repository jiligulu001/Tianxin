<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Subversion: Generic byte streams</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Subversion
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Generic byte streams</div>  </div>
</div>
<div class="contents">

<p>Generic byte-streams.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract stream of bytes--either incoming or outgoing or both.  <a href="#ga06d6291c397e63f895deb92a2c14e6af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga9a8939b5258b070a48aa1e0cd154909a">svn_read_fn_t</a> )(void *baton, char *buffer, apr_size_t *len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read handler function for a generic stream.  <a href="#ga9a8939b5258b070a48aa1e0cd154909a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga2c0bc2f0ebff96271f427013fece2a39">svn_stream_skip_fn_t</a> )(void *baton, apr_size_t len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip data handler function for a generic stream.  <a href="#ga2c0bc2f0ebff96271f427013fece2a39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gaa79398b116a9209eb3a79947a6066f54">svn_write_fn_t</a> )(void *baton, const char *data, apr_size_t *len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write handler function for a generic stream.  <a href="#gaa79398b116a9209eb3a79947a6066f54"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga576facc62f51e98c14cb440df1e58cd9">svn_close_fn_t</a> )(void *baton)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Close handler function for a generic stream.  <a href="#ga576facc62f51e98c14cb440df1e58cd9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__svn__io__byte__streams.html#gaca2f3b74a1215c13b5ae2ca3b99437b9">svn_stream_mark_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gaca2f3b74a1215c13b5ae2ca3b99437b9">svn_stream_mark_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque type which represents a mark on a stream.  <a href="#gaca2f3b74a1215c13b5ae2ca3b99437b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gaf811477b7cafa3c5c20cb3428976d0be">svn_stream_mark_fn_t</a> )(void *baton, <a class="el" href="group__svn__io__byte__streams.html#gaca2f3b74a1215c13b5ae2ca3b99437b9">svn_stream_mark_t</a> **mark, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark handler function for a generic stream.  <a href="#gaf811477b7cafa3c5c20cb3428976d0be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gaa5291159cc874084805155ccdfd68b4b">svn_stream_seek_fn_t</a> )(void *baton, const <a class="el" href="group__svn__io__byte__streams.html#gaca2f3b74a1215c13b5ae2ca3b99437b9">svn_stream_mark_t</a> *mark)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek handler function for a generic stream.  <a href="#gaa5291159cc874084805155ccdfd68b4b"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gadc3e897290c9479c6b903876d18dc87c">svn_stream_create</a> (void *baton, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a generic stream.  <a href="#gadc3e897290c9479c6b903876d18dc87c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0ff601f7fb4a7c8c92770edd7376b052"></a><!-- doxytag: member="svn_io_byte_streams::svn_stream_set_baton" ref="ga0ff601f7fb4a7c8c92770edd7376b052" args="(svn_stream_t *stream, void *baton)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga0ff601f7fb4a7c8c92770edd7376b052">svn_stream_set_baton</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, void *baton)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>stream's</em> baton to <em>baton</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae9ebdcf950b897d9c0cb89c331262aed"></a><!-- doxytag: member="svn_io_byte_streams::svn_stream_set_read" ref="gae9ebdcf950b897d9c0cb89c331262aed" args="(svn_stream_t *stream, svn_read_fn_t read_fn)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gae9ebdcf950b897d9c0cb89c331262aed">svn_stream_set_read</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, <a class="el" href="group__svn__io__byte__streams.html#ga9a8939b5258b070a48aa1e0cd154909a">svn_read_fn_t</a> read_fn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>stream's</em> read function to <em>read_fn</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gaf834f41616e68fa7d0214814a56b81d4">svn_stream_set_skip</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, <a class="el" href="group__svn__io__byte__streams.html#ga2c0bc2f0ebff96271f427013fece2a39">svn_stream_skip_fn_t</a> skip_fn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>stream's</em> skip function to <em>skip_fn</em>.  <a href="#gaf834f41616e68fa7d0214814a56b81d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaea19e182974e64a77d3f949a25f496a1"></a><!-- doxytag: member="svn_io_byte_streams::svn_stream_set_write" ref="gaea19e182974e64a77d3f949a25f496a1" args="(svn_stream_t *stream, svn_write_fn_t write_fn)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gaea19e182974e64a77d3f949a25f496a1">svn_stream_set_write</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, <a class="el" href="group__svn__io__byte__streams.html#gaa79398b116a9209eb3a79947a6066f54">svn_write_fn_t</a> write_fn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>stream's</em> write function to <em>write_fn</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga090c93a72964b78a00de75fa10fc5078"></a><!-- doxytag: member="svn_io_byte_streams::svn_stream_set_close" ref="ga090c93a72964b78a00de75fa10fc5078" args="(svn_stream_t *stream, svn_close_fn_t close_fn)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga090c93a72964b78a00de75fa10fc5078">svn_stream_set_close</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, <a class="el" href="group__svn__io__byte__streams.html#ga576facc62f51e98c14cb440df1e58cd9">svn_close_fn_t</a> close_fn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>stream's</em> close function to <em>close_fn</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gacdce9efd65576fafecb4df5fd2960d13">svn_stream_set_mark</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, <a class="el" href="group__svn__io__byte__streams.html#gaf811477b7cafa3c5c20cb3428976d0be">svn_stream_mark_fn_t</a> mark_fn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>stream's</em> mark function to <em>mark_fn</em>.  <a href="#gacdce9efd65576fafecb4df5fd2960d13"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga96e94eff159f85a3c8c6b7936e5c908d">svn_stream_set_seek</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, <a class="el" href="group__svn__io__byte__streams.html#gaa5291159cc874084805155ccdfd68b4b">svn_stream_seek_fn_t</a> seek_fn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>stream's</em> seek function to <em>seek_fn</em>.  <a href="#ga96e94eff159f85a3c8c6b7936e5c908d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga9f0acad4da18e90c1dc5250643af7049">svn_stream_empty</a> (apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a stream that is empty for reading and infinite for writing.  <a href="#ga9f0acad4da18e90c1dc5250643af7049"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga61c69116290c1f5e5fedd91ed7bed5ca">svn_stream_disown</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a stream allocated in <em>pool</em> which forwards all requests to <em>stream</em>.  <a href="#ga61c69116290c1f5e5fedd91ed7bed5ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga4d03d151fe2d8fb4068dab914823d059">svn_stream_open_readonly</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **stream, const char *path, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a stream to read the file at <em>path</em>.  <a href="#ga4d03d151fe2d8fb4068dab914823d059"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gace8995769bb736796262450ef90f033e">svn_stream_open_writable</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **stream, const char *path, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a stream to write a file at <em>path</em>.  <a href="#gace8995769bb736796262450ef90f033e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga821ab7add7a0216c86b1a7f94456fae9">svn_stream_open_unique</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **stream, const char **temp_path, const char *dirpath, <a class="el" href="svn__io_8h.html#aa78fffc81af962281813070c753d7884">svn_io_file_del_t</a> delete_when, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a writable stream to a file in the directory <em>dirpath</em>.  <a href="#ga821ab7add7a0216c86b1a7f94456fae9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gadf2971328919edf3fed5ef8353a90525">svn_stream_from_aprfile2</a> (apr_file_t *file, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> disown, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a stream from an APR file.  <a href="#gadf2971328919edf3fed5ef8353a90525"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gad12a2e4cbc23bcf8ee3f650966b8c43b">svn_stream_from_aprfile</a> (apr_file_t *file, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="group__svn__io__byte__streams.html#gadf2971328919edf3fed5ef8353a90525" title="Create a stream from an APR file.">svn_stream_from_aprfile2()</a>, except that the file will always be disowned.  <a href="#gad12a2e4cbc23bcf8ee3f650966b8c43b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga2e8d5c7ca3a74393f3350540149e8e3d">svn_stream_for_stdin</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **in, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*in</em> to a generic stream connected to stdin, allocated in <em>pool</em>.  <a href="#ga2e8d5c7ca3a74393f3350540149e8e3d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gaa76703167b5bc9cc53a1f66e64c5f77a">svn_stream_for_stderr</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **err, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*err</em> to a generic stream connected to stderr, allocated in <em>pool</em>.  <a href="#gaa76703167b5bc9cc53a1f66e64c5f77a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga64eca282d3b75b431a6f8ae5a6637fbb">svn_stream_for_stdout</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **out, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*out</em> to a generic stream connected to stdout, allocated in <em>pool</em>.  <a href="#ga64eca282d3b75b431a6f8ae5a6637fbb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gabe260b52fa278bc63ba75ea695e54303">svn_stream_from_stringbuf</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *str, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a generic stream connected to stringbuf <em>str</em>.  <a href="#gabe260b52fa278bc63ba75ea695e54303"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga8e85f7340b0f3471fb79c1bc501e4fea">svn_stream_from_string</a> (const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *str, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a generic read-only stream connected to string <em>str</em>.  <a href="#ga8e85f7340b0f3471fb79c1bc501e4fea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga10756ab562fd20d32fb880c859607b4c">svn_stream_compressed</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a stream that decompresses all data read and compresses all data written.  <a href="#ga10756ab562fd20d32fb880c859607b4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga823456ae87bbacf8b7022e8ea4c0d356">svn_stream_checksummed2</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, <a class="el" href="structsvn__checksum__t.html">svn_checksum_t</a> **read_checksum, <a class="el" href="structsvn__checksum__t.html">svn_checksum_t</a> **write_checksum, <a class="el" href="svn__checksum_8h.html#a7a6c373d03d7e6ec6b832a039f5e0aa1">svn_checksum_kind_t</a> checksum_kind, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> read_all, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a stream that calculates checksums for all data read and written.  <a href="#ga823456ae87bbacf8b7022e8ea4c0d356"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gadda74c8a8bf6d4dc64488979aa197afc">svn_stream_checksummed</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, const unsigned char **read_digest, const unsigned char **write_digest, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> read_all, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="group__svn__io__byte__streams.html#ga823456ae87bbacf8b7022e8ea4c0d356" title="Return a stream that calculates checksums for all data read and written.">svn_stream_checksummed2()</a>, but always returning the MD5 checksum in <em>read_digest</em> and <em>write_digest</em>.  <a href="#gadda74c8a8bf6d4dc64488979aa197afc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga241e8929f8f7631a629142bd749b25fc">svn_stream_read</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, char *buffer, apr_size_t *len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from a generic stream.  <a href="#ga241e8929f8f7631a629142bd749b25fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga139e177f2f8600c47f01319f12dc5d4a">svn_stream_skip</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, apr_size_t len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip <em>len</em> bytes from a generic <em>stream</em>.  <a href="#ga139e177f2f8600c47f01319f12dc5d4a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga0094764a89afdedecac79df9ad1ebccb">svn_stream_write</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, const char *data, apr_size_t *len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to a generic stream.  <a href="#ga0094764a89afdedecac79df9ad1ebccb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga7d9cdab4d5d8707d59a1b1d3dab95bb4">svn_stream_close</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a generic stream.  <a href="#ga7d9cdab4d5d8707d59a1b1d3dab95bb4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gac7574ccd5c0f60779bdaef7f5b44febd">svn_stream_reset</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset a generic stream back to its origin.  <a href="#gac7574ccd5c0f60779bdaef7f5b44febd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gab5dc6f7105e2332ebda600b2d2300eb7">svn_stream_supports_mark</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>TRUE</code> if the generic <em>stream</em> supports <a class="el" href="group__svn__io__byte__streams.html#ga47c17fbf09effd084d6b426d18175942" title="Set a mark at the current position of a generic stream, which can later be sought back to using svn_s...">svn_stream_mark()</a>.  <a href="#gab5dc6f7105e2332ebda600b2d2300eb7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga47c17fbf09effd084d6b426d18175942">svn_stream_mark</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, <a class="el" href="group__svn__io__byte__streams.html#gaca2f3b74a1215c13b5ae2ca3b99437b9">svn_stream_mark_t</a> **mark, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a <em>mark</em> at the current position of a generic <em>stream</em>, which can later be sought back to using <a class="el" href="group__svn__io__byte__streams.html#ga1cb32df4e14164a911490bae5e58e99e" title="Seek to a mark in a generic stream.">svn_stream_seek()</a>.  <a href="#ga47c17fbf09effd084d6b426d18175942"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga1cb32df4e14164a911490bae5e58e99e">svn_stream_seek</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, const <a class="el" href="group__svn__io__byte__streams.html#gaca2f3b74a1215c13b5ae2ca3b99437b9">svn_stream_mark_t</a> *mark)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek to a <em>mark</em> in a generic <em>stream</em>.  <a href="#ga1cb32df4e14164a911490bae5e58e99e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga77fdb810198d9c7832610882fd57546b">svn_stream_tee</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *out1, <a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *out2, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable stream which, when written to, writes to both of the underlying streams.  <a href="#ga77fdb810198d9c7832610882fd57546b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8665c4828daad13a35fd7e670552d888"></a><!-- doxytag: member="svn_io_byte_streams::svn_stream_printf" ref="ga8665c4828daad13a35fd7e670552d888" args="(svn_stream_t *stream, apr_pool_t *pool, const char *fmt,...)" -->
<a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga8665c4828daad13a35fd7e670552d888">svn_stream_printf</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, apr_pool_t *pool, const char *fmt,...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to <em>stream</em> using a printf-style <em>fmt</em> specifier, passed through apr_psprintf() using memory from <em>pool</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gacfb10864df6c3a6fd6e5fc08ae8ef7e8">svn_stream_printf_from_utf8</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, const char *encoding, apr_pool_t *pool, const char *fmt,...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to <em>stream</em> using a printf-style <em>fmt</em> specifier, passed through apr_psprintf() using memory from <em>pool</em>.  <a href="#gacfb10864df6c3a6fd6e5fc08ae8ef7e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gaccbf1cdff3857cad09096f8f01f37260">svn_stream_readline</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, <a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> **stringbuf, const char *eol, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *eof, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate <em>*stringbuf</em> in <em>pool</em>, and read into it one line (terminated by <em>eol</em>) from <em>stream</em>.  <a href="#gaccbf1cdff3857cad09096f8f01f37260"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga674a71b48f810dd21ad2db6fd611930d">svn_stream_copy3</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *from, <a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *to, <a class="el" href="svn__types_8h.html#addaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a> cancel_func, void *cancel_baton, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the contents of the readable stream <em>from</em> and write them to the writable stream <em>to</em> calling <em>cancel_func</em> before copying each chunk.  <a href="#ga674a71b48f810dd21ad2db6fd611930d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga1960de4b4eb0cf1a69a5ba5e11aaa6be">svn_stream_copy2</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *from, <a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *to, <a class="el" href="svn__types_8h.html#addaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a> cancel_func, void *cancel_baton, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="group__svn__io__byte__streams.html#ga674a71b48f810dd21ad2db6fd611930d" title="Read the contents of the readable stream from and write them to the writable stream to calling cancel...">svn_stream_copy3()</a> but the streams are not closed.  <a href="#ga1960de4b4eb0cf1a69a5ba5e11aaa6be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga444db383401ed714a240ff6ca5ca76b3">svn_stream_copy</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *from, <a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *to, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="group__svn__io__byte__streams.html#ga674a71b48f810dd21ad2db6fd611930d" title="Read the contents of the readable stream from and write them to the writable stream to calling cancel...">svn_stream_copy3()</a>, but without the cancellation function or stream closing.  <a href="#ga444db383401ed714a240ff6ca5ca76b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga4a84c869ab835792b5e441b5eb426fd6">svn_stream_contents_same2</a> (<a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *same, <a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream1, <a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream2, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*same</em> to TRUE if <em>stream1</em> and <em>stream2</em> have the same contents, else set it to FALSE.  <a href="#ga4a84c869ab835792b5e441b5eb426fd6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga14b9375f4e0300888b853650e15a987a">svn_stream_contents_same</a> (<a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *same, <a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream1, <a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream2, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="group__svn__io__byte__streams.html#ga4a84c869ab835792b5e441b5eb426fd6" title="Set *same to TRUE if stream1 and stream2 have the same contents, else set it to FALSE.">svn_stream_contents_same2()</a>, but the streams will not be closed.  <a href="#ga14b9375f4e0300888b853650e15a987a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga91b87b96c3f9a302d390263bd0d451a2">svn_string_from_stream</a> (<a class="el" href="structsvn__string__t.html">svn_string_t</a> **result, <a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the contents of <em>stream</em> into memory, returning the data in <em>result</em>.  <a href="#ga91b87b96c3f9a302d390263bd0d451a2"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>Generic byte-streams. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga576facc62f51e98c14cb440df1e58cd9"></a><!-- doxytag: member="svn_io.h::svn_close_fn_t" ref="ga576facc62f51e98c14cb440df1e58cd9" args=")(void *baton)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* <a class="el" href="group__svn__io__byte__streams.html#ga576facc62f51e98c14cb440df1e58cd9">svn_close_fn_t</a>)(void *baton)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close handler function for a generic stream. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af" title="An abstract stream of bytes--either incoming or outgoing or both.">svn_stream_t</a>. </dd></dl>

<p>Definition at line <a class="el" href="svn__io_8h_source.html#l00765">765</a> of file <a class="el" href="svn__io_8h_source.html">svn_io.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga9a8939b5258b070a48aa1e0cd154909a"></a><!-- doxytag: member="svn_io.h::svn_read_fn_t" ref="ga9a8939b5258b070a48aa1e0cd154909a" args=")(void *baton, char *buffer, apr_size_t *len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* <a class="el" href="group__svn__io__byte__streams.html#ga9a8939b5258b070a48aa1e0cd154909a">svn_read_fn_t</a>)(void *baton, char *buffer, apr_size_t *len)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read handler function for a generic stream. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af" title="An abstract stream of bytes--either incoming or outgoing or both.">svn_stream_t</a>. </dd></dl>

<p>Definition at line <a class="el" href="svn__io_8h_source.html#l00748">748</a> of file <a class="el" href="svn__io_8h_source.html">svn_io.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaf811477b7cafa3c5c20cb3428976d0be"></a><!-- doxytag: member="svn_io.h::svn_stream_mark_fn_t" ref="gaf811477b7cafa3c5c20cb3428976d0be" args=")(void *baton, svn_stream_mark_t **mark, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* <a class="el" href="group__svn__io__byte__streams.html#gaf811477b7cafa3c5c20cb3428976d0be">svn_stream_mark_fn_t</a>)(void *baton, <a class="el" href="group__svn__io__byte__streams.html#gaca2f3b74a1215c13b5ae2ca3b99437b9">svn_stream_mark_t</a> **mark, apr_pool_t *pool)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mark handler function for a generic stream. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af" title="An abstract stream of bytes--either incoming or outgoing or both.">svn_stream_t</a> and <a class="el" href="group__svn__io__byte__streams.html#ga47c17fbf09effd084d6b426d18175942" title="Set a mark at the current position of a generic stream, which can later be sought back to using svn_s...">svn_stream_mark()</a>.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7. </dd></dl>

<p>Definition at line <a class="el" href="svn__io_8h_source.html#l00781">781</a> of file <a class="el" href="svn__io_8h_source.html">svn_io.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaca2f3b74a1215c13b5ae2ca3b99437b9"></a><!-- doxytag: member="svn_io.h::svn_stream_mark_t" ref="gaca2f3b74a1215c13b5ae2ca3b99437b9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__svn__io__byte__streams.html#gaca2f3b74a1215c13b5ae2ca3b99437b9">svn_stream_mark_t</a> <a class="el" href="group__svn__io__byte__streams.html#gaca2f3b74a1215c13b5ae2ca3b99437b9">svn_stream_mark_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An opaque type which represents a mark on a stream. </p>
<p>There is no concrete definition of this type, it is a named type for stream implementation specific baton pointers.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__svn__io__byte__streams.html#ga47c17fbf09effd084d6b426d18175942" title="Set a mark at the current position of a generic stream, which can later be sought back to using svn_s...">svn_stream_mark()</a>. </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7. </dd></dl>

<p>Definition at line <a class="el" href="svn__io_8h_source.html#l00774">774</a> of file <a class="el" href="svn__io_8h_source.html">svn_io.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaa5291159cc874084805155ccdfd68b4b"></a><!-- doxytag: member="svn_io.h::svn_stream_seek_fn_t" ref="gaa5291159cc874084805155ccdfd68b4b" args=")(void *baton, const svn_stream_mark_t *mark)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* <a class="el" href="group__svn__io__byte__streams.html#gaa5291159cc874084805155ccdfd68b4b">svn_stream_seek_fn_t</a>)(void *baton, const <a class="el" href="group__svn__io__byte__streams.html#gaca2f3b74a1215c13b5ae2ca3b99437b9">svn_stream_mark_t</a> *mark)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Seek handler function for a generic stream. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af" title="An abstract stream of bytes--either incoming or outgoing or both.">svn_stream_t</a> and <a class="el" href="group__svn__io__byte__streams.html#ga1cb32df4e14164a911490bae5e58e99e" title="Seek to a mark in a generic stream.">svn_stream_seek()</a>.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7. </dd></dl>

<p>Definition at line <a class="el" href="svn__io_8h_source.html#l00790">790</a> of file <a class="el" href="svn__io_8h_source.html">svn_io.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga2c0bc2f0ebff96271f427013fece2a39"></a><!-- doxytag: member="svn_io.h::svn_stream_skip_fn_t" ref="ga2c0bc2f0ebff96271f427013fece2a39" args=")(void *baton, apr_size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* <a class="el" href="group__svn__io__byte__streams.html#ga2c0bc2f0ebff96271f427013fece2a39">svn_stream_skip_fn_t</a>)(void *baton, apr_size_t len)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Skip data handler function for a generic stream. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af" title="An abstract stream of bytes--either incoming or outgoing or both.">svn_stream_t</a> and <a class="el" href="group__svn__io__byte__streams.html#ga139e177f2f8600c47f01319f12dc5d4a" title="Skip len bytes from a generic stream.">svn_stream_skip()</a>. </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7. </dd></dl>

<p>Definition at line <a class="el" href="svn__io_8h_source.html#l00756">756</a> of file <a class="el" href="svn__io_8h_source.html">svn_io.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga06d6291c397e63f895deb92a2c14e6af"></a><!-- doxytag: member="svn_io.h::svn_stream_t" ref="ga06d6291c397e63f895deb92a2c14e6af" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> <a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An abstract stream of bytes--either incoming or outgoing or both. </p>
<p>The creator of a stream sets functions to handle read and write. Both of these handlers accept a baton whose value is determined at stream creation time; this baton can point to a structure containing data associated with the stream. If a caller attempts to invoke a handler which has not been set, it will generate a runtime assertion failure. The creator can also set a handler for close requests so that it can flush buffered data or whatever; if a close handler is not specified, a close request on the stream will simply be ignored. Note that <a class="el" href="group__svn__io__byte__streams.html#ga7d9cdab4d5d8707d59a1b1d3dab95bb4" title="Close a generic stream.">svn_stream_close()</a> does not deallocate the memory used to allocate the stream structure; free the pool you created the stream in to free that memory.</p>
<p>The read and write handlers accept length arguments via pointer. On entry to the handler, the pointed-to value should be the amount of data which can be read or the amount of data to write. When the handler returns, the value is reset to the amount of data actually read or written. Handlers are obliged to complete a read or write to the maximum extent possible; thus, a short read with no associated error implies the end of the input stream, and a short write should never occur without an associated error.</p>
<p>In Subversion 1.7 reset support was added as an optional feature of streams. If a stream implements resetting it allows reading the data again after a successful call to <a class="el" href="group__svn__io__byte__streams.html#gac7574ccd5c0f60779bdaef7f5b44febd" title="Reset a generic stream back to its origin.">svn_stream_reset()</a>. </p>

<p>Definition at line <a class="el" href="svn__io_8h_source.html#l00743">743</a> of file <a class="el" href="svn__io_8h_source.html">svn_io.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaa79398b116a9209eb3a79947a6066f54"></a><!-- doxytag: member="svn_io.h::svn_write_fn_t" ref="gaa79398b116a9209eb3a79947a6066f54" args=")(void *baton, const char *data, apr_size_t *len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* <a class="el" href="group__svn__io__byte__streams.html#gaa79398b116a9209eb3a79947a6066f54">svn_write_fn_t</a>)(void *baton, const char *data, apr_size_t *len)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write handler function for a generic stream. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af" title="An abstract stream of bytes--either incoming or outgoing or both.">svn_stream_t</a>. </dd></dl>

<p>Definition at line <a class="el" href="svn__io_8h_source.html#l00760">760</a> of file <a class="el" href="svn__io_8h_source.html">svn_io.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gadda74c8a8bf6d4dc64488979aa197afc"></a><!-- doxytag: member="svn_io.h::svn_stream_checksummed" ref="gadda74c8a8bf6d4dc64488979aa197afc" args="(svn_stream_t *stream, const unsigned char **read_digest, const unsigned char **write_digest, svn_boolean_t read_all, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>* svn_stream_checksummed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char **&#160;</td>
          <td class="paramname"><em>read_digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char **&#160;</td>
          <td class="paramname"><em>write_digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>read_all</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Similar to <a class="el" href="group__svn__io__byte__streams.html#ga823456ae87bbacf8b7022e8ea4c0d356" title="Return a stream that calculates checksums for all data read and written.">svn_stream_checksummed2()</a>, but always returning the MD5 checksum in <em>read_digest</em> and <em>write_digest</em>. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.4. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000187">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.5 API. </dd></dl>

</div>
</div>
<a class="anchor" id="ga823456ae87bbacf8b7022e8ea4c0d356"></a><!-- doxytag: member="svn_io.h::svn_stream_checksummed2" ref="ga823456ae87bbacf8b7022e8ea4c0d356" args="(svn_stream_t *stream, svn_checksum_t **read_checksum, svn_checksum_t **write_checksum, svn_checksum_kind_t checksum_kind, svn_boolean_t read_all, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>* svn_stream_checksummed2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsvn__checksum__t.html">svn_checksum_t</a> **&#160;</td>
          <td class="paramname"><em>read_checksum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsvn__checksum__t.html">svn_checksum_t</a> **&#160;</td>
          <td class="paramname"><em>write_checksum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__checksum_8h.html#a7a6c373d03d7e6ec6b832a039f5e0aa1">svn_checksum_kind_t</a>&#160;</td>
          <td class="paramname"><em>checksum_kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>read_all</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a stream that calculates checksums for all data read and written. </p>
<p>The stream <em>stream</em> is used to read and write all data. The stream and the resulting digests are allocated in <em>pool</em>.</p>
<p>When the stream is closed, <em>*read_checksum</em> and <em>*write_checksum</em> are set to point to the resulting checksums, of type <em>read_checksum_kind</em> and <em>write_checksum_kind</em>, respectively.</p>
<p>Both <em>read_checksum</em> and <em>write_checksum</em> can be <code>NULL</code>, in which case the respective checksum isn't calculated.</p>
<p>If <em>read_all</em> is TRUE, make sure that all data available on <em>stream</em> is read (and checksummed) when the stream is closed.</p>
<p>Read and write operations can be mixed without interfering.</p>
<p>The <em>stream</em> passed into this function is closed when the created stream is closed.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7d9cdab4d5d8707d59a1b1d3dab95bb4"></a><!-- doxytag: member="svn_io.h::svn_stream_close" ref="ga7d9cdab4d5d8707d59a1b1d3dab95bb4" args="(svn_stream_t *stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close a generic stream. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af" title="An abstract stream of bytes--either incoming or outgoing or both.">svn_stream_t</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga10756ab562fd20d32fb880c859607b4c"></a><!-- doxytag: member="svn_io.h::svn_stream_compressed" ref="ga10756ab562fd20d32fb880c859607b4c" args="(svn_stream_t *stream, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>* svn_stream_compressed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a stream that decompresses all data read and compresses all data written. </p>
<p>The stream <em>stream</em> is used to read and write all compressed data. All compression data structures are allocated on <em>pool</em>. If compression support is not compiled in then <a class="el" href="group__svn__io__byte__streams.html#ga10756ab562fd20d32fb880c859607b4c" title="Return a stream that decompresses all data read and compresses all data written.">svn_stream_compressed()</a> returns <em>stream</em> unmodified. Make sure you call <a class="el" href="group__svn__io__byte__streams.html#ga7d9cdab4d5d8707d59a1b1d3dab95bb4" title="Close a generic stream.">svn_stream_close()</a> on the stream returned by this function, so that all data are flushed and cleaned up.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>From 1.4, compression support is always compiled in. </dd></dl>

</div>
</div>
<a class="anchor" id="ga14b9375f4e0300888b853650e15a987a"></a><!-- doxytag: member="svn_io.h::svn_stream_contents_same" ref="ga14b9375f4e0300888b853650e15a987a" args="(svn_boolean_t *same, svn_stream_t *stream1, svn_stream_t *stream2, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_contents_same </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *&#160;</td>
          <td class="paramname"><em>same</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Same as <a class="el" href="group__svn__io__byte__streams.html#ga4a84c869ab835792b5e441b5eb426fd6" title="Set *same to TRUE if stream1 and stream2 have the same contents, else set it to FALSE.">svn_stream_contents_same2()</a>, but the streams will not be closed. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.4. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000190">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.6 API. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4a84c869ab835792b5e441b5eb426fd6"></a><!-- doxytag: member="svn_io.h::svn_stream_contents_same2" ref="ga4a84c869ab835792b5e441b5eb426fd6" args="(svn_boolean_t *same, svn_stream_t *stream1, svn_stream_t *stream2, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_contents_same2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *&#160;</td>
          <td class="paramname"><em>same</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set <em>*same</em> to TRUE if <em>stream1</em> and <em>stream2</em> have the same contents, else set it to FALSE. </p>
<p>Both streams will be closed before this function returns (regardless of the result, or any possible error).</p>
<p>Use <em>scratch_pool</em> for temporary allocations.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="ga444db383401ed714a240ff6ca5ca76b3"></a><!-- doxytag: member="svn_io.h::svn_stream_copy" ref="ga444db383401ed714a240ff6ca5ca76b3" args="(svn_stream_t *from, svn_stream_t *to, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Same as <a class="el" href="group__svn__io__byte__streams.html#ga674a71b48f810dd21ad2db6fd611930d" title="Read the contents of the readable stream from and write them to the writable stream to calling cancel...">svn_stream_copy3()</a>, but without the cancellation function or stream closing. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.1. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000189">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.4 API. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1960de4b4eb0cf1a69a5ba5e11aaa6be"></a><!-- doxytag: member="svn_io.h::svn_stream_copy2" ref="ga1960de4b4eb0cf1a69a5ba5e11aaa6be" args="(svn_stream_t *from, svn_stream_t *to, svn_cancel_func_t cancel_func, void *cancel_baton, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_copy2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#addaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a>&#160;</td>
          <td class="paramname"><em>cancel_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cancel_baton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Same as <a class="el" href="group__svn__io__byte__streams.html#ga674a71b48f810dd21ad2db6fd611930d" title="Read the contents of the readable stream from and write them to the writable stream to calling cancel...">svn_stream_copy3()</a> but the streams are not closed. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000188">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.5 API. </dd></dl>

</div>
</div>
<a class="anchor" id="ga674a71b48f810dd21ad2db6fd611930d"></a><!-- doxytag: member="svn_io.h::svn_stream_copy3" ref="ga674a71b48f810dd21ad2db6fd611930d" args="(svn_stream_t *from, svn_stream_t *to, svn_cancel_func_t cancel_func, void *cancel_baton, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_copy3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#addaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a>&#160;</td>
          <td class="paramname"><em>cancel_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cancel_baton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read the contents of the readable stream <em>from</em> and write them to the writable stream <em>to</em> calling <em>cancel_func</em> before copying each chunk. </p>
<p><em>cancel_func</em> may be <code>NULL</code>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>both <em>from</em> and <em>to</em> will be closed upon successful completion of the copy (but an error may still be returned, based on trying to close the two streams). If the closure is not desired, then you can use <a class="el" href="group__svn__io__byte__streams.html#ga61c69116290c1f5e5fedd91ed7bed5ca" title="Return a stream allocated in pool which forwards all requests to stream.">svn_stream_disown()</a> to protect either or both of the streams from being closed.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a class="anchor" id="gadc3e897290c9479c6b903876d18dc87c"></a><!-- doxytag: member="svn_io.h::svn_stream_create" ref="gadc3e897290c9479c6b903876d18dc87c" args="(void *baton, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>* svn_stream_create </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>baton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a generic stream. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af" title="An abstract stream of bytes--either incoming or outgoing or both.">svn_stream_t</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga61c69116290c1f5e5fedd91ed7bed5ca"></a><!-- doxytag: member="svn_io.h::svn_stream_disown" ref="ga61c69116290c1f5e5fedd91ed7bed5ca" args="(svn_stream_t *stream, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>* svn_stream_disown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a stream allocated in <em>pool</em> which forwards all requests to <em>stream</em>. </p>
<p>Destruction is explicitly excluded from forwarding.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>notes/destruction-of-stacked-resources</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.4. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9f0acad4da18e90c1dc5250643af7049"></a><!-- doxytag: member="svn_io.h::svn_stream_empty" ref="ga9f0acad4da18e90c1dc5250643af7049" args="(apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>* svn_stream_empty </td>
          <td>(</td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a stream that is empty for reading and infinite for writing. </p>

</div>
</div>
<a class="anchor" id="gaa76703167b5bc9cc53a1f66e64c5f77a"></a><!-- doxytag: member="svn_io.h::svn_stream_for_stderr" ref="gaa76703167b5bc9cc53a1f66e64c5f77a" args="(svn_stream_t **err, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_for_stderr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **&#160;</td>
          <td class="paramname"><em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set <em>*err</em> to a generic stream connected to stderr, allocated in <em>pool</em>. </p>
<p>The stream and its underlying APR handle will be closed when <em>pool</em> is cleared or destroyed.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2e8d5c7ca3a74393f3350540149e8e3d"></a><!-- doxytag: member="svn_io.h::svn_stream_for_stdin" ref="ga2e8d5c7ca3a74393f3350540149e8e3d" args="(svn_stream_t **in, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_for_stdin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set <em>*in</em> to a generic stream connected to stdin, allocated in <em>pool</em>. </p>
<p>The stream and its underlying APR handle will be closed when <em>pool</em> is cleared or destroyed.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="ga64eca282d3b75b431a6f8ae5a6637fbb"></a><!-- doxytag: member="svn_io.h::svn_stream_for_stdout" ref="ga64eca282d3b75b431a6f8ae5a6637fbb" args="(svn_stream_t **out, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_for_stdout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set <em>*out</em> to a generic stream connected to stdout, allocated in <em>pool</em>. </p>
<p>The stream and its underlying APR handle will be closed when <em>pool</em> is cleared or destroyed. </p>

</div>
</div>
<a class="anchor" id="gad12a2e4cbc23bcf8ee3f650966b8c43b"></a><!-- doxytag: member="svn_io.h::svn_stream_from_aprfile" ref="gad12a2e4cbc23bcf8ee3f650966b8c43b" args="(apr_file_t *file, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>* svn_stream_from_aprfile </td>
          <td>(</td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Similar to <a class="el" href="group__svn__io__byte__streams.html#gadf2971328919edf3fed5ef8353a90525" title="Create a stream from an APR file.">svn_stream_from_aprfile2()</a>, except that the file will always be disowned. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The stream returned is not considered to "own" the underlying file, meaning that <a class="el" href="group__svn__io__byte__streams.html#ga7d9cdab4d5d8707d59a1b1d3dab95bb4" title="Close a generic stream.">svn_stream_close()</a> on the stream will not close the file.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000186">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.3 API. </dd></dl>

</div>
</div>
<a class="anchor" id="gadf2971328919edf3fed5ef8353a90525"></a><!-- doxytag: member="svn_io.h::svn_stream_from_aprfile2" ref="gadf2971328919edf3fed5ef8353a90525" args="(apr_file_t *file, svn_boolean_t disown, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>* svn_stream_from_aprfile2 </td>
          <td>(</td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>disown</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a stream from an APR file. </p>
<p>For convenience, if <em>file</em> is <code>NULL</code>, an empty stream created by <a class="el" href="group__svn__io__byte__streams.html#ga9f0acad4da18e90c1dc5250643af7049" title="Create a stream that is empty for reading and infinite for writing.">svn_stream_empty()</a> is returned.</p>
<p>This function should normally be called with <em>disown</em> set to FALSE, in which case closing the stream will also close the underlying file.</p>
<p>If <em>disown</em> is TRUE, the stream will disown the underlying file, meaning that <a class="el" href="group__svn__io__byte__streams.html#ga7d9cdab4d5d8707d59a1b1d3dab95bb4" title="Close a generic stream.">svn_stream_close()</a> will not close the file.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.4. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8e85f7340b0f3471fb79c1bc501e4fea"></a><!-- doxytag: member="svn_io.h::svn_stream_from_string" ref="ga8e85f7340b0f3471fb79c1bc501e4fea" args="(const svn_string_t *str, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>* svn_stream_from_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a generic read-only stream connected to string <em>str</em>. </p>
<p>Allocate the stream in <em>pool</em>. </p>

</div>
</div>
<a class="anchor" id="gabe260b52fa278bc63ba75ea695e54303"></a><!-- doxytag: member="svn_io.h::svn_stream_from_stringbuf" ref="gabe260b52fa278bc63ba75ea695e54303" args="(svn_stringbuf_t *str, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>* svn_stream_from_stringbuf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a generic stream connected to stringbuf <em>str</em>. </p>
<p>Allocate the stream in <em>pool</em>. </p>

</div>
</div>
<a class="anchor" id="ga47c17fbf09effd084d6b426d18175942"></a><!-- doxytag: member="svn_io.h::svn_stream_mark" ref="ga47c17fbf09effd084d6b426d18175942" args="(svn_stream_t *stream, svn_stream_mark_t **mark, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_mark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#gaca2f3b74a1215c13b5ae2ca3b99437b9">svn_stream_mark_t</a> **&#160;</td>
          <td class="paramname"><em>mark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a <em>mark</em> at the current position of a generic <em>stream</em>, which can later be sought back to using <a class="el" href="group__svn__io__byte__streams.html#ga1cb32df4e14164a911490bae5e58e99e" title="Seek to a mark in a generic stream.">svn_stream_seek()</a>. </p>
<p>The <em>mark</em> is allocated in <em>pool</em>.</p>
<p>This function returns the <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660a4cb4098e25ea204783c9063a54142098" title="&quot;Stream doesn&#39;t support seeking&quot;">SVN_ERR_STREAM_SEEK_NOT_SUPPORTED</a> error if the stream doesn't implement seeking.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__svn__io__byte__streams.html#ga1cb32df4e14164a911490bae5e58e99e" title="Seek to a mark in a generic stream.">svn_stream_seek()</a> </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4d03d151fe2d8fb4068dab914823d059"></a><!-- doxytag: member="svn_io.h::svn_stream_open_readonly" ref="ga4d03d151fe2d8fb4068dab914823d059" args="(svn_stream_t **stream, const char *path, apr_pool_t *result_pool, apr_pool_t *scratch_pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_open_readonly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a stream to read the file at <em>path</em>. </p>
<p>It will be opened using the APR_BUFFERED and APR_BINARY flag, and APR_OS_DEFAULT for the perms. If you'd like to use different values, then open the file yourself, and use the <a class="el" href="group__svn__io__byte__streams.html#gadf2971328919edf3fed5ef8353a90525" title="Create a stream from an APR file.">svn_stream_from_aprfile2()</a> interface.</p>
<p>The stream will be returned in <em>stream</em>, and allocated from <em>result_pool</em>. Temporary allocations will be performed in <em>scratch_pool</em>.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.6 </dd></dl>

</div>
</div>
<a class="anchor" id="ga821ab7add7a0216c86b1a7f94456fae9"></a><!-- doxytag: member="svn_io.h::svn_stream_open_unique" ref="ga821ab7add7a0216c86b1a7f94456fae9" args="(svn_stream_t **stream, const char **temp_path, const char *dirpath, svn_io_file_del_t delete_when, apr_pool_t *result_pool, apr_pool_t *scratch_pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_open_unique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>temp_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dirpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__io_8h.html#aa78fffc81af962281813070c753d7884">svn_io_file_del_t</a>&#160;</td>
          <td class="paramname"><em>delete_when</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a writable stream to a file in the directory <em>dirpath</em>. </p>
<p>The file will have an arbitrary and unique name, and the full path will be returned in <em>temp_path</em>. The stream will be returned in <em>stream</em>. Both will be allocated from <em>result_pool</em>.</p>
<p>If <em>dirpath</em> is <code>NULL</code>, use the path returned from <a class="el" href="svn__io_8h.html#afbb4b86585411439008e934ede6f8b39" title="Set *dir to a directory path (allocated in pool) deemed usable for the creation of temporary files an...">svn_io_temp_dir()</a>. (Note that when using the system-provided temp directory, it may not be possible to atomically rename the resulting file due to cross-device issues.)</p>
<p>The file will be deleted according to <em>delete_when</em>.</p>
<p>Temporary allocations will be performed in <em>scratch_pool</em>.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.6 </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="svn__io_8h.html#ad1a7a7299bfe130c25becdd56ff0e870" title="Create a writable file, with an arbitrary and unique name, in the directory dirpath.">svn_io_open_unique_file3()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gace8995769bb736796262450ef90f033e"></a><!-- doxytag: member="svn_io.h::svn_stream_open_writable" ref="gace8995769bb736796262450ef90f033e" args="(svn_stream_t **stream, const char *path, apr_pool_t *result_pool, apr_pool_t *scratch_pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_open_writable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a stream to write a file at <em>path</em>. </p>
<p>The file will be *created* using the APR_BUFFERED and APR_BINARY flag, and APR_OS_DEFAULT for the perms. The file will be created "exclusively", so if it already exists, then an error will be thrown. If you'd like to use different values, or open an existing file, then open the file yourself, and use the <a class="el" href="group__svn__io__byte__streams.html#gadf2971328919edf3fed5ef8353a90525" title="Create a stream from an APR file.">svn_stream_from_aprfile2()</a> interface.</p>
<p>The stream will be returned in <em>stream</em>, and allocated from <em>result_pool</em>. Temporary allocations will be performed in <em>scratch_pool</em>.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.6 </dd></dl>

</div>
</div>
<a class="anchor" id="gacfb10864df6c3a6fd6e5fc08ae8ef7e8"></a><!-- doxytag: member="svn_io.h::svn_stream_printf_from_utf8" ref="gacfb10864df6c3a6fd6e5fc08ae8ef7e8" args="(svn_stream_t *stream, const char *encoding, apr_pool_t *pool, const char *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_printf_from_utf8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>encoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write to <em>stream</em> using a printf-style <em>fmt</em> specifier, passed through apr_psprintf() using memory from <em>pool</em>. </p>
<p>The resulting string will be translated to <em>encoding</em> before it is sent to <em>stream</em>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Use <code>APR_LOCALE_CHARSET</code> to translate to the encoding of the current locale.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.3. </dd></dl>

</div>
</div>
<a class="anchor" id="ga241e8929f8f7631a629142bd749b25fc"></a><!-- doxytag: member="svn_io.h::svn_stream_read" ref="ga241e8929f8f7631a629142bd749b25fc" args="(svn_stream_t *stream, char *buffer, apr_size_t *len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read from a generic stream. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af" title="An abstract stream of bytes--either incoming or outgoing or both.">svn_stream_t</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaccbf1cdff3857cad09096f8f01f37260"></a><!-- doxytag: member="svn_io.h::svn_stream_readline" ref="gaccbf1cdff3857cad09096f8f01f37260" args="(svn_stream_t *stream, svn_stringbuf_t **stringbuf, const char *eol, svn_boolean_t *eof, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_readline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> **&#160;</td>
          <td class="paramname"><em>stringbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>eol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *&#160;</td>
          <td class="paramname"><em>eof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate <em>*stringbuf</em> in <em>pool</em>, and read into it one line (terminated by <em>eol</em>) from <em>stream</em>. </p>
<p>The line-terminator is read from the stream, but is not added to the end of the stringbuf. Instead, the stringbuf ends with a usual '\0'.</p>
<p>If <em>stream</em> runs out of bytes before encountering a line-terminator, then set <em>*eof</em> to <code>TRUE</code>, otherwise set <em>*eof</em> to FALSE. </p>

</div>
</div>
<a class="anchor" id="gac7574ccd5c0f60779bdaef7f5b44febd"></a><!-- doxytag: member="svn_io.h::svn_stream_reset" ref="gac7574ccd5c0f60779bdaef7f5b44febd" args="(svn_stream_t *stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset a generic stream back to its origin. </p>
<p>E.g. On a file this would be implemented as a seek to position 0). This function returns a #SVN_ERR_STREAM_RESET_NOT_SUPPORTED error when the stream doesn't implement resetting.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1cb32df4e14164a911490bae5e58e99e"></a><!-- doxytag: member="svn_io.h::svn_stream_seek" ref="ga1cb32df4e14164a911490bae5e58e99e" args="(svn_stream_t *stream, const svn_stream_mark_t *mark)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_seek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__svn__io__byte__streams.html#gaca2f3b74a1215c13b5ae2ca3b99437b9">svn_stream_mark_t</a> *&#160;</td>
          <td class="paramname"><em>mark</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Seek to a <em>mark</em> in a generic <em>stream</em>. </p>
<p>This function returns the <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660a4cb4098e25ea204783c9063a54142098" title="&quot;Stream doesn&#39;t support seeking&quot;">SVN_ERR_STREAM_SEEK_NOT_SUPPORTED</a> error if the stream doesn't implement seeking. Passing NULL as <em>mark</em>, seeks to the start of the stream.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__svn__io__byte__streams.html#ga47c17fbf09effd084d6b426d18175942" title="Set a mark at the current position of a generic stream, which can later be sought back to using svn_s...">svn_stream_mark()</a> </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="gacdce9efd65576fafecb4df5fd2960d13"></a><!-- doxytag: member="svn_io.h::svn_stream_set_mark" ref="gacdce9efd65576fafecb4df5fd2960d13" args="(svn_stream_t *stream, svn_stream_mark_fn_t mark_fn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_stream_set_mark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#gaf811477b7cafa3c5c20cb3428976d0be">svn_stream_mark_fn_t</a>&#160;</td>
          <td class="paramname"><em>mark_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set <em>stream's</em> mark function to <em>mark_fn</em>. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="ga96e94eff159f85a3c8c6b7936e5c908d"></a><!-- doxytag: member="svn_io.h::svn_stream_set_seek" ref="ga96e94eff159f85a3c8c6b7936e5c908d" args="(svn_stream_t *stream, svn_stream_seek_fn_t seek_fn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_stream_set_seek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#gaa5291159cc874084805155ccdfd68b4b">svn_stream_seek_fn_t</a>&#160;</td>
          <td class="paramname"><em>seek_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set <em>stream's</em> seek function to <em>seek_fn</em>. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf834f41616e68fa7d0214814a56b81d4"></a><!-- doxytag: member="svn_io.h::svn_stream_set_skip" ref="gaf834f41616e68fa7d0214814a56b81d4" args="(svn_stream_t *stream, svn_stream_skip_fn_t skip_fn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_stream_set_skip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga2c0bc2f0ebff96271f427013fece2a39">svn_stream_skip_fn_t</a>&#160;</td>
          <td class="paramname"><em>skip_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set <em>stream's</em> skip function to <em>skip_fn</em>. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7 </dd></dl>

</div>
</div>
<a class="anchor" id="ga139e177f2f8600c47f01319f12dc5d4a"></a><!-- doxytag: member="svn_io.h::svn_stream_skip" ref="ga139e177f2f8600c47f01319f12dc5d4a" args="(svn_stream_t *stream, apr_size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_skip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Skip <em>len</em> bytes from a generic <em>stream</em>. </p>
<p>If the stream is exhausted before <em>len</em> bytes have been read, return an error.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>No assumption can be made on the semantics of this function other than that the stream read pointer will be advanced by *len bytes. Depending on the capabilities of the underlying stream implementation, this may for instance be translated into a sequence of reads or a simple seek operation. If the stream implementation has not provided a skip function, this will read from the stream and discard the data. </dd></dl>

</div>
</div>
<a class="anchor" id="gab5dc6f7105e2332ebda600b2d2300eb7"></a><!-- doxytag: member="svn_io.h::svn_stream_supports_mark" ref="gab5dc6f7105e2332ebda600b2d2300eb7" args="(svn_stream_t *stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> svn_stream_supports_mark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>TRUE</code> if the generic <em>stream</em> supports <a class="el" href="group__svn__io__byte__streams.html#ga47c17fbf09effd084d6b426d18175942" title="Set a mark at the current position of a generic stream, which can later be sought back to using svn_s...">svn_stream_mark()</a>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__svn__io__byte__streams.html#ga47c17fbf09effd084d6b426d18175942" title="Set a mark at the current position of a generic stream, which can later be sought back to using svn_s...">svn_stream_mark()</a> </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="ga77fdb810198d9c7832610882fd57546b"></a><!-- doxytag: member="svn_io.h::svn_stream_tee" ref="ga77fdb810198d9c7832610882fd57546b" args="(svn_stream_t *out1, svn_stream_t *out2, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>* svn_stream_tee </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>out1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>out2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a writable stream which, when written to, writes to both of the underlying streams. </p>
<p>Both of these streams will be closed upon closure of the returned stream; use <a class="el" href="group__svn__io__byte__streams.html#ga61c69116290c1f5e5fedd91ed7bed5ca" title="Return a stream allocated in pool which forwards all requests to stream.">svn_stream_disown()</a> if this is not the desired behavior. One or both of <em>out1</em> and <em>out2</em> may be <code>NULL</code>. If both are <code>NULL</code>, <code>NULL</code> is returned.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0094764a89afdedecac79df9ad1ebccb"></a><!-- doxytag: member="svn_io.h::svn_stream_write" ref="ga0094764a89afdedecac79df9ad1ebccb" args="(svn_stream_t *stream, const char *data, apr_size_t *len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write to a generic stream. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af" title="An abstract stream of bytes--either incoming or outgoing or both.">svn_stream_t</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga91b87b96c3f9a302d390263bd0d451a2"></a><!-- doxytag: member="svn_io.h::svn_string_from_stream" ref="ga91b87b96c3f9a302d390263bd0d451a2" args="(svn_string_t **result, svn_stream_t *stream, apr_pool_t *result_pool, apr_pool_t *scratch_pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_string_from_stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__string__t.html">svn_string_t</a> **&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read the contents of <em>stream</em> into memory, returning the data in <em>result</em>. </p>
<p>The stream will be closed when it has been successfully and completely read.</p>
<p>The returned memory is allocated in <em>result_pool</em>, and any temporary allocations are performed in <em>scratch_pool</em>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>due to memory pseudo-reallocation behavior (due to pools), this can be a memory-intensive operation for large files.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.6 </dd></dl>

</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 23 2011 09:20:41 for Subversion by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
