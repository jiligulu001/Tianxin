<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Subversion: Filesystem interaction subsystem</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Subversion
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#groups">Modules</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Filesystem interaction subsystem</div>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__fs__dirent__t.html">svn_fs_dirent_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a Subversion directory entry.  <a href="structsvn__fs__dirent__t.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="groups"></a>
Modules</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__bdb.html">Berkeley DB filesystems</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Subversion filesystems based on Berkeley DB. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__access__ctx.html">Filesystem access contexts</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Filesystem Access Contexts. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__nodes.html">Filesystem nodes</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Filesystem Nodes and Node-Revisions. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__txns.html">Filesystem transactions</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Filesystem Transactions. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__roots.html">Filesystem roots</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Roots. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__directories.html">Filesystem directories</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Directory entry names and directory paths. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__locks.html">Filesystem locks</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An object representing a Subversion filesystem.  <a href="#ga2419fff1bb2c1e523b00e276ed3862e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gafa2c790fffb1abbd103c954a5d983646">svn_fs_warning_callback_t</a> )(void *baton, <a class="el" href="structsvn__error__t.html">svn_error_t</a> *err)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a warning callback function.  <a href="#gafa2c790fffb1abbd103c954a5d983646"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__fs__handling.html#gaa31b679ed9ca7b53241ebda04c035140">svn_fs_history_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gaa31b679ed9ca7b53241ebda04c035140">svn_fs_history_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque node history object.  <a href="#gaa31b679ed9ca7b53241ebda04c035140"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structsvn__fs__dirent__t.html">svn_fs_dirent_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga2697d2b291384d9511aef9857daf8aa1">svn_fs_dirent_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a Subversion directory entry.  <a href="#ga2697d2b291384d9511aef9857daf8aa1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef enum <br class="typebreak"/>
<a class="el" href="group__fs__handling.html#ga7c9b681798a28beb90cb747c0626b5b2">svn_fs_pack_notify_action_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga32fc8b28e63f9f0e7cab74c8a44f819c">svn_fs_pack_notify_action_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The kind of action being taken by 'pack'.  <a href="#ga32fc8b28e63f9f0e7cab74c8a44f819c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga418eae984b0da828404197edf9fcc46e">svn_fs_pack_notify_t</a> )(void *baton, apr_int64_t shard, <a class="el" href="group__fs__handling.html#ga7c9b681798a28beb90cb747c0626b5b2">svn_fs_pack_notify_action_t</a> action, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a pack notification function.  <a href="#ga418eae984b0da828404197edf9fcc46e"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga7c9b681798a28beb90cb747c0626b5b2">svn_fs_pack_notify_action_t</a> { <br/>
&#160;&#160;<a class="el" href="group__fs__handling.html#gga7c9b681798a28beb90cb747c0626b5b2afba8e92df732aad1d260c907a671d974">svn_fs_pack_notify_start</a> =  0, 
<br/>
&#160;&#160;<a class="el" href="group__fs__handling.html#gga7c9b681798a28beb90cb747c0626b5b2a418f1ef1d170f644d49d055b4d4e244f">svn_fs_pack_notify_end</a>, 
<br/>
&#160;&#160;<a class="el" href="group__fs__handling.html#gga7c9b681798a28beb90cb747c0626b5b2a7e2b473fa5c9367b08a76f92f7e856fa">svn_fs_pack_notify_start_revprop</a>, 
<br/>
&#160;&#160;<a class="el" href="group__fs__handling.html#gga7c9b681798a28beb90cb747c0626b5b2a3d08320b848ebe9a3f5b6846e67cda2f">svn_fs_pack_notify_end_revprop</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The kind of action being taken by 'pack'.  <a href="group__fs__handling.html#ga7c9b681798a28beb90cb747c0626b5b2">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gaf3bce1e26521c4432f14f3adfc617f17">svn_fs_initialize</a> (apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Callers should invoke this function to initialize global state in the FS library before creating FS objects.  <a href="#gaf3bce1e26521c4432f14f3adfc617f17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gabc881c866ebe2cbd41767374264532e8">svn_fs_set_warning_func</a> (<a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, <a class="el" href="group__fs__handling.html#gafa2c790fffb1abbd103c954a5d983646">svn_fs_warning_callback_t</a> warning, void *warning_baton)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a callback function, <em>warning</em>, that <em>fs</em> should use to report (non-fatal) errors.  <a href="#gabc881c866ebe2cbd41767374264532e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga24b9cee11c6d584ddb0b9d74efca5dd5">svn_fs_create</a> (<a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> **fs_p, const char *path, apr_hash_t *fs_config, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new, empty Subversion filesystem, stored in the directory <em>path</em>, and return a pointer to it in <em>*fs_p</em>.  <a href="#ga24b9cee11c6d584ddb0b9d74efca5dd5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gaf31aff19f6ddd70e665235ff1857fc35">svn_fs_open</a> (<a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> **fs_p, const char *path, apr_hash_t *fs_config, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a Subversion filesystem located in the directory <em>path</em>, and return a pointer to it in <em>*fs_p</em>.  <a href="#gaf31aff19f6ddd70e665235ff1857fc35"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga64cb2a37367de523f56b89e5ec603a73">svn_fs_upgrade</a> (const char *path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Upgrade the Subversion filesystem located in the directory <em>path</em> to the latest version supported by this library.  <a href="#ga64cb2a37367de523f56b89e5ec603a73"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gae771342c2800751277423c552cfeee48">svn_fs_type</a> (const char **fs_type, const char *path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return, in <em>*fs_type</em>, a string identifying the back-end type of the Subversion filesystem located in <em>path</em>.  <a href="#gae771342c2800751277423c552cfeee48"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gaa1a79172a1faa38b234d365240079c3a">svn_fs_path</a> (<a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the path to <em>fs's</em> repository, allocated in <em>pool</em>.  <a href="#gaa1a79172a1faa38b234d365240079c3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga6d1642cd31bc5e860d521c8c80058058">svn_fs_delete_fs</a> (const char *path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the filesystem at <em>path</em>.  <a href="#ga6d1642cd31bc5e860d521c8c80058058"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga2909d84e561fbfd8b0f321dbded129b6">svn_fs_hotcopy</a> (const char *src_path, const char *dest_path, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> clean, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a possibly live Subversion filesystem from <em>src_path</em> to <em>dest_path</em>.  <a href="#ga2909d84e561fbfd8b0f321dbded129b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gaf6f1f42958e3f56326185b91fc1ae679">svn_fs_recover</a> (const char *path, <a class="el" href="svn__types_8h.html#addaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a> cancel_func, void *cancel_baton, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform any necessary non-catastrophic recovery on the Subversion filesystem located at <em>path</em>.  <a href="#gaf6f1f42958e3f56326185b91fc1ae679"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga8795c6c2a696353b550c2f733787a015">svn_fs_check_path</a> (<a class="el" href="svn__types_8h.html#ac3ca125707a8ca1289c73236b5ce7f9a">svn_node_kind_t</a> *kind_p, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*kind_p</em> to the type of node present at <em>path</em> under <em>root</em>.  <a href="#ga8795c6c2a696353b550c2f733787a015"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga2412ddc868b0ef6cdbbe3b682827885e">svn_fs_node_history</a> (<a class="el" href="group__fs__handling.html#gaa31b679ed9ca7b53241ebda04c035140">svn_fs_history_t</a> **history_p, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*history_p</em> to an opaque node history object which represents <em>path</em> under <em>root</em>.  <a href="#ga2412ddc868b0ef6cdbbe3b682827885e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga58dd5d7dc74bef946a4dc1129c342038">svn_fs_history_prev</a> (<a class="el" href="group__fs__handling.html#gaa31b679ed9ca7b53241ebda04c035140">svn_fs_history_t</a> **prev_history_p, <a class="el" href="group__fs__handling.html#gaa31b679ed9ca7b53241ebda04c035140">svn_fs_history_t</a> *history, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> cross_copies, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*prev_history_p</em> to an opaque node history object which represents the previous (or "next oldest") interesting history location for the filesystem node represented by <em>history</em>, or <code>NULL</code> if no such previous history exists.  <a href="#ga58dd5d7dc74bef946a4dc1129c342038"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga266d0597466eb198dc4b593fcd44490e">svn_fs_history_location</a> (const char **path, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> *revision, <a class="el" href="group__fs__handling.html#gaa31b679ed9ca7b53241ebda04c035140">svn_fs_history_t</a> *history, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*path</em> and <em>*revision</em> to the path and revision, respectively, of the <em>history</em> object.  <a href="#ga266d0597466eb198dc4b593fcd44490e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga1a5ecfab7f53876e9ad6def4265df7e6">svn_fs_is_dir</a> (<a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *is_dir, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*is_dir</em> to <code>TRUE</code> iff <em>path</em> in <em>root</em> is a directory.  <a href="#ga1a5ecfab7f53876e9ad6def4265df7e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga84b9e2f502354e16162edd12e8f5cc5b">svn_fs_is_file</a> (<a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *is_file, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*is_file</em> to <code>TRUE</code> iff <em>path</em> in <em>root</em> is a file.  <a href="#ga84b9e2f502354e16162edd12e8f5cc5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gaf59a66cf510e6da06dadfe2b3bb372e1">svn_fs_node_id</a> (const <a class="el" href="group__svn__fs__nodes.html#gaeca8f1c373c50ca7bb08e3417242b106">svn_fs_id_t</a> **id_p, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the id of a node.  <a href="#gaf59a66cf510e6da06dadfe2b3bb372e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gad3be25cd08e898319e14cce69580992e">svn_fs_node_created_rev</a> (<a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> *revision, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*revision</em> to the revision in which <em>path</em> under <em>root</em> was created.  <a href="#gad3be25cd08e898319e14cce69580992e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gaf26ebca946019f3761f48ad8dadd6eaa">svn_fs_node_origin_rev</a> (<a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> *revision, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*revision</em> to the revision in which the line of history represented by <em>path</em> under <em>root</em> originated.  <a href="#gaf26ebca946019f3761f48ad8dadd6eaa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gaf25b3de3d8930d857cf6c94777ce9bca">svn_fs_node_created_path</a> (const char **created_path, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*created_path</em> to the path at which <em>path</em> under <em>root</em> was created.  <a href="#gaf25b3de3d8930d857cf6c94777ce9bca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga830b554597da876e1b6256f2836cf349">svn_fs_node_prop</a> (<a class="el" href="structsvn__string__t.html">svn_string_t</a> **value_p, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, const char *propname, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*value_p</em> to the value of the property named <em>propname</em> of <em>path</em> in <em>root</em>.  <a href="#ga830b554597da876e1b6256f2836cf349"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga079534da68d59ac24307ae171189dd61">svn_fs_node_proplist</a> (apr_hash_t **table_p, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*table_p</em> to the entire property list of <em>path</em> in <em>root</em>, as an APR hash table allocated in <em>pool</em>.  <a href="#ga079534da68d59ac24307ae171189dd61"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga75ce7073e254911b82f9acc4825d4247">svn_fs_change_node_prop</a> (<a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, const char *name, const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *value, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change a node's property's value, or add/delete a property.  <a href="#ga75ce7073e254911b82f9acc4825d4247"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gaac7c1a6f4732d24a8ee387abb33e33dc">svn_fs_props_changed</a> (<a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *changed_p, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root1, const char *path1, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root2, const char *path2, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the properties of two path/root combinations are different.  <a href="#gaac7c1a6f4732d24a8ee387abb33e33dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gaed6116279287a80ec4f7de380a732f45">svn_fs_copied_from</a> (<a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> *rev_p, const char **path_p, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Discover a node's copy ancestry, if any.  <a href="#gaed6116279287a80ec4f7de380a732f45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga9d7839028ca775d36c6fdc851973f9ac">svn_fs_closest_copy</a> (<a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> **root_p, const char **path_p, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*root_p</em> and <em>*path_p</em> to the revision root and path of the destination of the most recent copy event that caused <em>path</em> to exist where it does in <em>root</em>, or to NULL if no such copy exists.  <a href="#ga9d7839028ca775d36c6fdc851973f9ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga2976ec837ee7caa7771e61ed266933b5">svn_fs_get_mergeinfo</a> (svn_mergeinfo_catalog_t *catalog, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const apr_array_header_t *paths, <a class="el" href="svn__mergeinfo_8h.html#acd81e9d0f5bcc4eec4df7b8a140f435c">svn_mergeinfo_inheritance_t</a> inherit, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> include_descendants, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve mergeinfo for multiple nodes.  <a href="#ga2976ec837ee7caa7771e61ed266933b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gafc5df16564312635dc97077a29e73d8e">svn_fs_merge</a> (const char **conflict_p, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *source_root, const char *source_path, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *target_root, const char *target_path, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *ancestor_root, const char *ancestor_path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge changes between two nodes into a third node.  <a href="#gafc5df16564312635dc97077a29e73d8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gad254aea2a12fbd7c8c62c8aaa3c4624c">svn_fs_dir_entries</a> (apr_hash_t **entries_p, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*entries_p</em> to a newly allocated APR hash table containing the entries of the directory at <em>path</em> in <em>root</em>.  <a href="#gad254aea2a12fbd7c8c62c8aaa3c4624c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga8484e37e57a52bb38e5067c38bf41e16">svn_fs_make_dir</a> (<a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new directory named <em>path</em> in <em>root</em>.  <a href="#ga8484e37e57a52bb38e5067c38bf41e16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga528e3cf9010e463b511584f4143b6a72">svn_fs_delete</a> (<a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the node named <em>path</em> in <em>root</em>.  <a href="#ga528e3cf9010e463b511584f4143b6a72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga9da8e22bd1058f877a275099699bb86b">svn_fs_copy</a> (<a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *from_root, const char *from_path, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *to_root, const char *to_path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of <em>from_path</em> in <em>from_root</em> named <em>to_path</em> in <em>to_root</em>.  <a href="#ga9da8e22bd1058f877a275099699bb86b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gaddd7ec5b6e3306c609e46d4f5a2b8a5c">svn_fs_revision_link</a> (<a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *from_root, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *to_root, const char *path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="group__fs__handling.html#ga9da8e22bd1058f877a275099699bb86b" title="Create a copy of from_path in from_root named to_path in to_root.">svn_fs_copy()</a>, but doesn't record copy history, and preserves the PATH.  <a href="#gaddd7ec5b6e3306c609e46d4f5a2b8a5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gabd675ec4bc28c7f4e72a121feeb60059">svn_fs_file_length</a> (<a class="el" href="svn__types_8h.html#a726e581898461c1d3e7dbdb16d99dad0">svn_filesize_t</a> *length_p, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*length_p</em> to the length of the file <em>path</em> in <em>root</em>, in bytes.  <a href="#gabd675ec4bc28c7f4e72a121feeb60059"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga3a35bf47dcd1d43fdf7572166eb0eeb4">svn_fs_file_checksum</a> (<a class="el" href="structsvn__checksum__t.html">svn_checksum_t</a> **checksum, <a class="el" href="svn__checksum_8h.html#a7a6c373d03d7e6ec6b832a039f5e0aa1">svn_checksum_kind_t</a> kind, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> force, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*checksum</em> to the checksum of type <em>kind</em> for the file <em>path</em>.  <a href="#ga3a35bf47dcd1d43fdf7572166eb0eeb4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga9dfe5ed9f63bb8b222d2adb2b96f0220">svn_fs_file_md5_checksum</a> (unsigned char digest[], <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="group__fs__handling.html#ga3a35bf47dcd1d43fdf7572166eb0eeb4" title="Set *checksum to the checksum of type kind for the file path.">svn_fs_file_checksum()</a>, only always put the MD5 checksum of file <em>path</em> into <em>digest</em>, which should point to <code>APR_MD5_DIGESTSIZE</code> bytes of storage.  <a href="#ga9dfe5ed9f63bb8b222d2adb2b96f0220"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gafe8eadb1c6950e3bfdca49bbb497d6fb">svn_fs_file_contents</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **contents, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*contents</em> to a readable generic stream that will yield the contents of the file <em>path</em> in <em>root</em>.  <a href="#gafe8eadb1c6950e3bfdca49bbb497d6fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gac760753f1ae74fc19991d5dab7cb643c">svn_fs_make_file</a> (<a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new file named <em>path</em> in <em>root</em>.  <a href="#gac760753f1ae74fc19991d5dab7cb643c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga8ae7391b579009b76e238fe9ef5b8053">svn_fs_apply_textdelta</a> (<a class="el" href="group__svn__delta__txt__delta.html#ga1c0d461a3f244928d7f0339c1cbe3219">svn_txdelta_window_handler_t</a> *contents_p, void **contents_baton_p, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, const char *base_checksum, const char *result_checksum, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a text delta to the file <em>path</em> in <em>root</em>.  <a href="#ga8ae7391b579009b76e238fe9ef5b8053"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga61f5a039a4ad8818de163578b9c054f7">svn_fs_apply_text</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **contents_p, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, const char *result_checksum, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data directly to the file <em>path</em> in <em>root</em>.  <a href="#ga61f5a039a4ad8818de163578b9c054f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gaede66ee7850d389bcdeb5ddef1540fdc">svn_fs_contents_changed</a> (<a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *changed_p, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root1, const char *path1, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root2, const char *path2, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the contents of two root/path combos have changed.  <a href="#gaede66ee7850d389bcdeb5ddef1540fdc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga4af11f84095941c21fad6e22f62dd31d">svn_fs_youngest_rev</a> (<a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> *youngest_p, <a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*youngest_p</em> to the number of the youngest revision in filesystem <em>fs</em>.  <a href="#ga4af11f84095941c21fad6e22f62dd31d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga3f29dd4915629fc66ea1af713b659ce5">svn_fs_deltify_revision</a> (<a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> revision, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide filesystem <em>fs</em> the opportunity to compress storage relating to associated with <em>revision</em> in filesystem <em>fs</em>.  <a href="#ga3f29dd4915629fc66ea1af713b659ce5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga0cd6959ee54cd16768477d608fd33c34">svn_fs_revision_prop</a> (<a class="el" href="structsvn__string__t.html">svn_string_t</a> **value_p, <a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> rev, const char *propname, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*value_p</em> to the value of the property named <em>propname</em> on revision <em>rev</em> in the filesystem <em>fs</em>.  <a href="#ga0cd6959ee54cd16768477d608fd33c34"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga423da8c30eacc9787ec7bc3dd1b9e351">svn_fs_revision_proplist</a> (apr_hash_t **table_p, <a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> rev, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*table_p</em> to the entire property list of revision <em>rev</em> in filesystem <em>fs</em>, as an APR hash table allocated in <em>pool</em>.  <a href="#ga423da8c30eacc9787ec7bc3dd1b9e351"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga42e1c39fc4980da8c2f2f575fa7515ac">svn_fs_change_rev_prop2</a> (<a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> rev, const char *name, const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *const *old_value_p, const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *value, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change a revision's property's value, or add/delete a property.  <a href="#ga42e1c39fc4980da8c2f2f575fa7515ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gab368d97a4f5093e8c71f8082f4664937">svn_fs_change_rev_prop</a> (<a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> rev, const char *name, const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *value, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="group__fs__handling.html#ga42e1c39fc4980da8c2f2f575fa7515ac" title="Change a revision&#39;s property&#39;s value, or add/delete a property.">svn_fs_change_rev_prop2()</a>, but with <em>old_value_p</em> passed as <code>NULL</code>.  <a href="#gab368d97a4f5093e8c71f8082f4664937"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gad2d4b1fa18c0bbda6719d4414b52f4c2">svn_fs_get_file_delta_stream</a> (<a class="el" href="group__svn__delta__txt__delta.html#gaf599af000e3c3b976c17fd4e101ff7cf">svn_txdelta_stream_t</a> **stream_p, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *source_root, const char *source_path, <a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *target_root, const char *target_path, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*stream_p</em> to a pointer to a delta stream that will turn the contents of the file <em>source</em> into the contents of the file <em>target</em>.  <a href="#gad2d4b1fa18c0bbda6719d4414b52f4c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga2ce6bd7610fc7201f4ea6b4e20e49e67">svn_fs_get_uuid</a> (<a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, const char **uuid, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate <em>*uuid</em> with the UUID associated with <em>fs</em>.  <a href="#ga2ce6bd7610fc7201f4ea6b4e20e49e67"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gabec2453f61fb9356db9526d4c56f3a62">svn_fs_set_uuid</a> (<a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, const char *uuid, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If not <code>NULL</code>, associate <em>*uuid</em> with <em>fs</em>.  <a href="#gabec2453f61fb9356db9526d4c56f3a62"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga26cf98c986a0f71fe9d86be0f73266b6">svn_fs_print_modules</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *output, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a textual list of all available FS modules to the stringbuf <em>output</em>.  <a href="#ga26cf98c986a0f71fe9d86be0f73266b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga307aa2f60e82d9f78d7f7990991533c3">svn_fs_pack</a> (const char *db_path, <a class="el" href="group__fs__handling.html#ga418eae984b0da828404197edf9fcc46e">svn_fs_pack_notify_t</a> notify_func, void *notify_baton, <a class="el" href="svn__types_8h.html#addaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a> cancel_func, void *cancel_baton, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Possibly update the filesystem located in the directory <em>path</em> to use disk space more efficiently.  <a href="#ga307aa2f60e82d9f78d7f7990991533c3"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Filesystem configuration options</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaab167e36e29a071fa657b15690153fd6"></a><!-- doxytag: member="fs_handling::SVN_FS_CONFIG_BDB_TXN_NOSYNC" ref="gaab167e36e29a071fa657b15690153fd6" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SVN_FS_CONFIG_BDB_TXN_NOSYNC</b>&#160;&#160;&#160;&quot;bdb-txn-nosync&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga164c04ce6347133c7b3404c02237c885"></a><!-- doxytag: member="fs_handling::SVN_FS_CONFIG_BDB_LOG_AUTOREMOVE" ref="ga164c04ce6347133c7b3404c02237c885" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SVN_FS_CONFIG_BDB_LOG_AUTOREMOVE</b>&#160;&#160;&#160;&quot;bdb-log-autoremove&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gabc9c69b38e7648f51d44c19d30264768">SVN_FS_CONFIG_FSFS_CACHE_DELTAS</a>&#160;&#160;&#160;&quot;fsfs-cache-deltas&quot;</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable / disable text delta caching for a FSFS repository.  <a href="#gabc9c69b38e7648f51d44c19d30264768"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga5723e5da32aff3655370c74df55869ec">SVN_FS_CONFIG_FSFS_CACHE_FULLTEXTS</a>&#160;&#160;&#160;&quot;fsfs-cache-fulltexts&quot;</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable / disable full-text caching for a FSFS repository.  <a href="#ga5723e5da32aff3655370c74df55869ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga8cce99342f8830d9541901fcbc5fa8b3">SVN_FS_CONFIG_FS_TYPE</a>&#160;&#160;&#160;&quot;fs-type&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga29b820d53571bccdf8f381652f584ab9">SVN_FS_TYPE_BDB</a>&#160;&#160;&#160;&quot;bdb&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gad9fcc8cddb1a0cd207b53196d88152d8">SVN_FS_TYPE_FSFS</a>&#160;&#160;&#160;&quot;fsfs&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gadc13f77df450863a919070b29b21c781">SVN_FS_CONFIG_PRE_1_4_COMPATIBLE</a>&#160;&#160;&#160;&quot;pre-1.4-compatible&quot;</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create repository format compatible with Subversion versions earlier than 1.4.  <a href="#gadc13f77df450863a919070b29b21c781"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga1c752f75cbf1c1baa0e9162a69c3d726">SVN_FS_CONFIG_PRE_1_5_COMPATIBLE</a>&#160;&#160;&#160;&quot;pre-1.5-compatible&quot;</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create repository format compatible with Subversion versions earlier than 1.5.  <a href="#ga1c752f75cbf1c1baa0e9162a69c3d726"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga3a32c49aff9bb931c07c6cca5f4f80c9">SVN_FS_CONFIG_PRE_1_6_COMPATIBLE</a>&#160;&#160;&#160;&quot;pre-1.6-compatible&quot;</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create repository format compatible with Subversion versions earlier than 1.6.  <a href="#ga3a32c49aff9bb931c07c6cca5f4f80c9"></a><br/></td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga8cce99342f8830d9541901fcbc5fa8b3"></a><!-- doxytag: member="svn_fs.h::SVN_FS_CONFIG_FS_TYPE" ref="ga8cce99342f8830d9541901fcbc5fa8b3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SVN_FS_CONFIG_FS_TYPE&#160;&#160;&#160;&quot;fs-type&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.1. </dd></dl>

<p>Definition at line <a class="el" href="svn__fs_8h_source.html#l00090">90</a> of file <a class="el" href="svn__fs_8h_source.html">svn_fs.h</a>.</p>

</div>
</div>
<a class="anchor" id="gabc9c69b38e7648f51d44c19d30264768"></a><!-- doxytag: member="svn_fs.h::SVN_FS_CONFIG_FSFS_CACHE_DELTAS" ref="gabc9c69b38e7648f51d44c19d30264768" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SVN_FS_CONFIG_FSFS_CACHE_DELTAS&#160;&#160;&#160;&quot;fsfs-cache-deltas&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable / disable text delta caching for a FSFS repository. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7. </dd></dl>

<p>Definition at line <a class="el" href="svn__fs_8h_source.html#l00080">80</a> of file <a class="el" href="svn__fs_8h_source.html">svn_fs.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga5723e5da32aff3655370c74df55869ec"></a><!-- doxytag: member="svn_fs.h::SVN_FS_CONFIG_FSFS_CACHE_FULLTEXTS" ref="ga5723e5da32aff3655370c74df55869ec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SVN_FS_CONFIG_FSFS_CACHE_FULLTEXTS&#160;&#160;&#160;&quot;fsfs-cache-fulltexts&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable / disable full-text caching for a FSFS repository. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7. </dd></dl>

<p>Definition at line <a class="el" href="svn__fs_8h_source.html#l00086">86</a> of file <a class="el" href="svn__fs_8h_source.html">svn_fs.h</a>.</p>

</div>
</div>
<a class="anchor" id="gadc13f77df450863a919070b29b21c781"></a><!-- doxytag: member="svn_fs.h::SVN_FS_CONFIG_PRE_1_4_COMPATIBLE" ref="gadc13f77df450863a919070b29b21c781" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SVN_FS_CONFIG_PRE_1_4_COMPATIBLE&#160;&#160;&#160;&quot;pre-1.4-compatible&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create repository format compatible with Subversion versions earlier than 1.4. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.4. </dd></dl>

<p>Definition at line <a class="el" href="svn__fs_8h_source.html#l00101">101</a> of file <a class="el" href="svn__fs_8h_source.html">svn_fs.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga1c752f75cbf1c1baa0e9162a69c3d726"></a><!-- doxytag: member="svn_fs.h::SVN_FS_CONFIG_PRE_1_5_COMPATIBLE" ref="ga1c752f75cbf1c1baa0e9162a69c3d726" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SVN_FS_CONFIG_PRE_1_5_COMPATIBLE&#160;&#160;&#160;&quot;pre-1.5-compatible&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create repository format compatible with Subversion versions earlier than 1.5. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

<p>Definition at line <a class="el" href="svn__fs_8h_source.html#l00108">108</a> of file <a class="el" href="svn__fs_8h_source.html">svn_fs.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga3a32c49aff9bb931c07c6cca5f4f80c9"></a><!-- doxytag: member="svn_fs.h::SVN_FS_CONFIG_PRE_1_6_COMPATIBLE" ref="ga3a32c49aff9bb931c07c6cca5f4f80c9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SVN_FS_CONFIG_PRE_1_6_COMPATIBLE&#160;&#160;&#160;&quot;pre-1.6-compatible&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create repository format compatible with Subversion versions earlier than 1.6. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.6. </dd></dl>

<p>Definition at line <a class="el" href="svn__fs_8h_source.html#l00115">115</a> of file <a class="el" href="svn__fs_8h_source.html">svn_fs.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga29b820d53571bccdf8f381652f584ab9"></a><!-- doxytag: member="svn_fs.h::SVN_FS_TYPE_BDB" ref="ga29b820d53571bccdf8f381652f584ab9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SVN_FS_TYPE_BDB&#160;&#160;&#160;&quot;bdb&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.1. </dd></dl>

<p>Definition at line <a class="el" href="svn__fs_8h_source.html#l00092">92</a> of file <a class="el" href="svn__fs_8h_source.html">svn_fs.h</a>.</p>

</div>
</div>
<a class="anchor" id="gad9fcc8cddb1a0cd207b53196d88152d8"></a><!-- doxytag: member="svn_fs.h::SVN_FS_TYPE_FSFS" ref="gad9fcc8cddb1a0cd207b53196d88152d8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SVN_FS_TYPE_FSFS&#160;&#160;&#160;&quot;fsfs&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.1. </dd></dl>

<p>Definition at line <a class="el" href="svn__fs_8h_source.html#l00094">94</a> of file <a class="el" href="svn__fs_8h_source.html">svn_fs.h</a>.</p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga2697d2b291384d9511aef9857daf8aa1"></a><!-- doxytag: member="svn_fs.h::svn_fs_dirent_t" ref="ga2697d2b291384d9511aef9857daf8aa1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structsvn__fs__dirent__t.html">svn_fs_dirent_t</a>  <a class="el" href="structsvn__fs__dirent__t.html">svn_fs_dirent_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The type of a Subversion directory entry. </p>

</div>
</div>
<a class="anchor" id="gaa31b679ed9ca7b53241ebda04c035140"></a><!-- doxytag: member="svn_fs.h::svn_fs_history_t" ref="gaa31b679ed9ca7b53241ebda04c035140" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__fs__handling.html#gaa31b679ed9ca7b53241ebda04c035140">svn_fs_history_t</a> <a class="el" href="group__fs__handling.html#gaa31b679ed9ca7b53241ebda04c035140">svn_fs_history_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An opaque node history object. </p>

<p>Definition at line <a class="el" href="svn__fs_8h_source.html#l01211">1211</a> of file <a class="el" href="svn__fs_8h_source.html">svn_fs.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga32fc8b28e63f9f0e7cab74c8a44f819c"></a><!-- doxytag: member="svn_fs.h::svn_fs_pack_notify_action_t" ref="ga32fc8b28e63f9f0e7cab74c8a44f819c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group__fs__handling.html#ga7c9b681798a28beb90cb747c0626b5b2">svn_fs_pack_notify_action_t</a>  <a class="el" href="group__fs__handling.html#ga7c9b681798a28beb90cb747c0626b5b2">svn_fs_pack_notify_action_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The kind of action being taken by 'pack'. </p>

</div>
</div>
<a class="anchor" id="ga418eae984b0da828404197edf9fcc46e"></a><!-- doxytag: member="svn_fs.h::svn_fs_pack_notify_t" ref="ga418eae984b0da828404197edf9fcc46e" args=")(void *baton, apr_int64_t shard, svn_fs_pack_notify_action_t action, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* <a class="el" href="group__fs__handling.html#ga418eae984b0da828404197edf9fcc46e">svn_fs_pack_notify_t</a>)(void *baton, apr_int64_t shard, <a class="el" href="group__fs__handling.html#ga7c9b681798a28beb90cb747c0626b5b2">svn_fs_pack_notify_action_t</a> action, apr_pool_t *pool)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The type of a pack notification function. </p>
<p><em>shard</em> is the shard being acted upon; <em>action</em> is the type of action being performed. <em>baton</em> is the corresponding baton for the notification function, and <em>pool</em> can be used for temporary allocations, but will be cleared between invocations. </p>

<p>Definition at line <a class="el" href="svn__fs_8h_source.html#l02220">2220</a> of file <a class="el" href="svn__fs_8h_source.html">svn_fs.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga2419fff1bb2c1e523b00e276ed3862e3"></a><!-- doxytag: member="svn_fs.h::svn_fs_t" ref="ga2419fff1bb2c1e523b00e276ed3862e3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> <a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An object representing a Subversion filesystem. </p>

<p>Definition at line <a class="el" href="svn__fs_8h_source.html#l00066">66</a> of file <a class="el" href="svn__fs_8h_source.html">svn_fs.h</a>.</p>

</div>
</div>
<a class="anchor" id="gafa2c790fffb1abbd103c954a5d983646"></a><!-- doxytag: member="svn_fs.h::svn_fs_warning_callback_t" ref="gafa2c790fffb1abbd103c954a5d983646" args=")(void *baton, svn_error_t *err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="group__fs__handling.html#gafa2c790fffb1abbd103c954a5d983646">svn_fs_warning_callback_t</a>)(void *baton, <a class="el" href="structsvn__error__t.html">svn_error_t</a> *err)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The type of a warning callback function. </p>
<p><em>baton</em> is the value specified in the call to <a class="el" href="group__fs__handling.html#gabc881c866ebe2cbd41767374264532e8" title="Provide a callback function, warning, that fs should use to report (non-fatal) errors.">svn_fs_set_warning_func()</a>; the filesystem passes it through to the callback. <em>err</em> contains the warning message.</p>
<p>The callback function should not clear the error that is passed to it; its caller should do that. </p>

<p>Definition at line <a class="el" href="svn__fs_8h_source.html#l00152">152</a> of file <a class="el" href="svn__fs_8h_source.html">svn_fs.h</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga7c9b681798a28beb90cb747c0626b5b2"></a><!-- doxytag: member="svn_fs.h::svn_fs_pack_notify_action_t" ref="ga7c9b681798a28beb90cb747c0626b5b2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__fs__handling.html#ga7c9b681798a28beb90cb747c0626b5b2">svn_fs_pack_notify_action_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The kind of action being taken by 'pack'. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga7c9b681798a28beb90cb747c0626b5b2afba8e92df732aad1d260c907a671d974"></a><!-- doxytag: member="svn_fs_pack_notify_start" ref="gga7c9b681798a28beb90cb747c0626b5b2afba8e92df732aad1d260c907a671d974" args="" -->svn_fs_pack_notify_start</em>&nbsp;</td><td>
<p>packing of the shard has commenced </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga7c9b681798a28beb90cb747c0626b5b2a418f1ef1d170f644d49d055b4d4e244f"></a><!-- doxytag: member="svn_fs_pack_notify_end" ref="gga7c9b681798a28beb90cb747c0626b5b2a418f1ef1d170f644d49d055b4d4e244f" args="" -->svn_fs_pack_notify_end</em>&nbsp;</td><td>
<p>packing of the shard is completed </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga7c9b681798a28beb90cb747c0626b5b2a7e2b473fa5c9367b08a76f92f7e856fa"></a><!-- doxytag: member="svn_fs_pack_notify_start_revprop" ref="gga7c9b681798a28beb90cb747c0626b5b2a7e2b473fa5c9367b08a76f92f7e856fa" args="" -->svn_fs_pack_notify_start_revprop</em>&nbsp;</td><td>
<p>packing of the shard revprops has commenced </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7. </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga7c9b681798a28beb90cb747c0626b5b2a3d08320b848ebe9a3f5b6846e67cda2f"></a><!-- doxytag: member="svn_fs_pack_notify_end_revprop" ref="gga7c9b681798a28beb90cb747c0626b5b2a3d08320b848ebe9a3f5b6846e67cda2f" args="" -->svn_fs_pack_notify_end_revprop</em>&nbsp;</td><td>
<p>packing of the shard revprops has completed </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7. </dd></dl>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="svn__fs_8h_source.html#l02197">2197</a> of file <a class="el" href="svn__fs_8h_source.html">svn_fs.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga61f5a039a4ad8818de163578b9c054f7"></a><!-- doxytag: member="svn_fs.h::svn_fs_apply_text" ref="ga61f5a039a4ad8818de163578b9c054f7" args="(svn_stream_t **contents_p, svn_fs_root_t *root, const char *path, const char *result_checksum, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_apply_text </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **&#160;</td>
          <td class="paramname"><em>contents_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>result_checksum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write data directly to the file <em>path</em> in <em>root</em>. </p>
<p><em>root</em> must be the root of a transaction, not a revision.</p>
<p>Set <em>*contents_p</em> to a stream ready to receive full textual data. When the caller closes this stream, the data replaces the previous contents of the file. The caller must write all file data and close the stream before making further changes to the transaction.</p>
<p>If <em>path</em> does not exist in <em>root</em>, return an error. (You cannot use this routine to create new files; use <a class="el" href="group__fs__handling.html#gac760753f1ae74fc19991d5dab7cb643c" title="Create a new file named path in root.">svn_fs_make_file()</a> to create an empty file first.)</p>
<p><em>result_checksum</em> is the hex MD5 digest for the final fulltext written to the stream. It is ignored if NULL, but if not null, it must match the checksum of the result; if it does not, then the <em>*contents_p</em> call which detects the mismatch will return the error <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660ae0b4dcc1b314982153e251724ce8d40b" title="&quot;A checksum mismatch occurred&quot;">SVN_ERR_CHECKSUM_MISMATCH</a>.</p>
<p>Do any necessary temporary allocation in <em>pool</em>.</p>
<p>### This is like <a class="el" href="group__fs__handling.html#ga8ae7391b579009b76e238fe9ef5b8053" title="Apply a text delta to the file path in root.">svn_fs_apply_textdelta()</a>, but takes the text straight. It is currently used only by the loader, see libsvn_repos/load.c. It should accept a checksum, of course, which would come from an (optional) header in the dump file. See <a href="http://subversion.tigris.org/issues/show_bug.cgi?id=1102">http://subversion.tigris.org/issues/show_bug.cgi?id=1102</a> for more. </p>

</div>
</div>
<a class="anchor" id="ga8ae7391b579009b76e238fe9ef5b8053"></a><!-- doxytag: member="svn_fs.h::svn_fs_apply_textdelta" ref="ga8ae7391b579009b76e238fe9ef5b8053" args="(svn_txdelta_window_handler_t *contents_p, void **contents_baton_p, svn_fs_root_t *root, const char *path, const char *base_checksum, const char *result_checksum, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_apply_textdelta </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__delta__txt__delta.html#ga1c0d461a3f244928d7f0339c1cbe3219">svn_txdelta_window_handler_t</a> *&#160;</td>
          <td class="paramname"><em>contents_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>contents_baton_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>base_checksum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>result_checksum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply a text delta to the file <em>path</em> in <em>root</em>. </p>
<p><em>root</em> must be the root of a transaction, not a revision.</p>
<p>Set <em>*contents_p</em> to a function ready to receive text delta windows describing how to change the file's contents, relative to its current contents. Set <em>*contents_baton_p</em> to a baton to pass to <em>*contents_p</em>.</p>
<p>If <em>path</em> does not exist in <em>root</em>, return an error. (You cannot use this routine to create new files; use <a class="el" href="group__fs__handling.html#gac760753f1ae74fc19991d5dab7cb643c" title="Create a new file named path in root.">svn_fs_make_file()</a> to create an empty file first.)</p>
<p><em>base_checksum</em> is the hex MD5 digest for the base text against which the delta is to be applied; it is ignored if NULL, and may be ignored even if not NULL. If it is not ignored, it must match the checksum of the base text against which svndiff data is being applied; if not, <a class="el" href="group__fs__handling.html#ga8ae7391b579009b76e238fe9ef5b8053" title="Apply a text delta to the file path in root.">svn_fs_apply_textdelta()</a> or the <em>*contents_p</em> call which detects the mismatch will return the error <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660ae0b4dcc1b314982153e251724ce8d40b" title="&quot;A checksum mismatch occurred&quot;">SVN_ERR_CHECKSUM_MISMATCH</a> (if there is no base text, there may still be an error if <em>base_checksum</em> is neither NULL nor the checksum of the empty string).</p>
<p><em>result_checksum</em> is the hex MD5 digest for the fulltext that results from this delta application. It is ignored if NULL, but if not NULL, it must match the checksum of the result; if it does not, then the <em>*contents_p</em> call which detects the mismatch will return the error <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660ae0b4dcc1b314982153e251724ce8d40b" title="&quot;A checksum mismatch occurred&quot;">SVN_ERR_CHECKSUM_MISMATCH</a>.</p>
<p>The caller must send all delta windows including the terminating NULL window to <em>*contents_p</em> before making further changes to the transaction.</p>
<p>Do temporary allocation in <em>pool</em>. </p>

</div>
</div>
<a class="anchor" id="ga75ce7073e254911b82f9acc4825d4247"></a><!-- doxytag: member="svn_fs.h::svn_fs_change_node_prop" ref="ga75ce7073e254911b82f9acc4825d4247" args="(svn_fs_root_t *root, const char *path, const char *name, const svn_string_t *value, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_change_node_prop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change a node's property's value, or add/delete a property. </p>
<ul>
<li><em>root</em> and <em>path</em> indicate the node whose property should change. <em>root</em> must be the root of a transaction, not the root of a revision.</li>
<li><em>name</em> is the name of the property to change.</li>
<li><em>value</em> is the new value of the property, or zero if the property should be removed altogether. Do any necessary temporary allocation in <em>pool</em>. </li>
</ul>

</div>
</div>
<a class="anchor" id="gab368d97a4f5093e8c71f8082f4664937"></a><!-- doxytag: member="svn_fs.h::svn_fs_change_rev_prop" ref="gab368d97a4f5093e8c71f8082f4664937" args="(svn_fs_t *fs, svn_revnum_t rev, const char *name, const svn_string_t *value, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_change_rev_prop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a>&#160;</td>
          <td class="paramname"><em>rev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Similar to <a class="el" href="group__fs__handling.html#ga42e1c39fc4980da8c2f2f575fa7515ac" title="Change a revision&#39;s property&#39;s value, or add/delete a property.">svn_fs_change_rev_prop2()</a>, but with <em>old_value_p</em> passed as <code>NULL</code>. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000177">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.6 API. </dd></dl>

</div>
</div>
<a class="anchor" id="ga42e1c39fc4980da8c2f2f575fa7515ac"></a><!-- doxytag: member="svn_fs.h::svn_fs_change_rev_prop2" ref="ga42e1c39fc4980da8c2f2f575fa7515ac" args="(svn_fs_t *fs, svn_revnum_t rev, const char *name, const svn_string_t *const *old_value_p, const svn_string_t *value, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_change_rev_prop2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a>&#160;</td>
          <td class="paramname"><em>rev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *const *&#160;</td>
          <td class="paramname"><em>old_value_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change a revision's property's value, or add/delete a property. </p>
<ul>
<li><em>fs</em> is a filesystem, and <em>rev</em> is the revision in that filesystem whose property should change.</li>
<li><em>name</em> is the name of the property to change.</li>
<li>if <em>old_value_p</em> is not <code>NULL</code>, then changing the property will fail with error <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660a6dfc3b1c5aa7779e2a83373e735e1c88" title="&quot;Property value in filesystem differs from the provided &quot; &quot;base value&quot;">SVN_ERR_FS_PROP_BASEVALUE_MISMATCH</a> if the present value of the property is not <em>*old_value_p</em>. (This is an atomic test-and-set). <em>*old_value_p</em> may be <code>NULL</code>, representing that the property must be not already set.</li>
<li><em>value</em> is the new value of the property, or zero if the property should be removed altogether.</li>
</ul>
<p>Note that revision properties are non-historied --- you can change them after the revision has been committed. They are not protected via transactions.</p>
<p>Do any necessary temporary allocation in <em>pool</em>.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8795c6c2a696353b550c2f733787a015"></a><!-- doxytag: member="svn_fs.h::svn_fs_check_path" ref="ga8795c6c2a696353b550c2f733787a015" args="(svn_node_kind_t *kind_p, svn_fs_root_t *root, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_check_path </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#ac3ca125707a8ca1289c73236b5ce7f9a">svn_node_kind_t</a> *&#160;</td>
          <td class="paramname"><em>kind_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set <em>*kind_p</em> to the type of node present at <em>path</em> under <em>root</em>. </p>
<p>If <em>path</em> does not exist under <em>root</em>, set <em>*kind_p</em> to <a class="el" href="svn__types_8h.html#ac3ca125707a8ca1289c73236b5ce7f9aae4066898ada99c4a3bc94e80aabe78b5" title="absent">svn_node_none</a>. Use <em>pool</em> for temporary allocation. </p>

</div>
</div>
<a class="anchor" id="ga9d7839028ca775d36c6fdc851973f9ac"></a><!-- doxytag: member="svn_fs.h::svn_fs_closest_copy" ref="ga9d7839028ca775d36c6fdc851973f9ac" args="(svn_fs_root_t **root_p, const char **path_p, svn_fs_root_t *root, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_closest_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> **&#160;</td>
          <td class="paramname"><em>root_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>path_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set <em>*root_p</em> and <em>*path_p</em> to the revision root and path of the destination of the most recent copy event that caused <em>path</em> to exist where it does in <em>root</em>, or to NULL if no such copy exists. </p>
<p>When non-NULL, allocate <em>*root_p</em> and <em>*path_p</em> in <em>pool</em>.</p>
<p><em>*path_p</em> might be a parent of <em>path</em>, rather than <em>path</em> itself. However, it will always be the deepest relevant path. That is, if a copy occurs underneath another copy in the same txn, this function makes sure to set <em>*path_p</em> to the longest copy destination path that is still a parent of or equal to <em>path</em>.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.3. </dd></dl>

</div>
</div>
<a class="anchor" id="gaede66ee7850d389bcdeb5ddef1540fdc"></a><!-- doxytag: member="svn_fs.h::svn_fs_contents_changed" ref="gaede66ee7850d389bcdeb5ddef1540fdc" args="(svn_boolean_t *changed_p, svn_fs_root_t *root1, const char *path1, svn_fs_root_t *root2, const char *path2, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_contents_changed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *&#160;</td>
          <td class="paramname"><em>changed_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if the contents of two root/path combos have changed. </p>
<p>Set <em>*changed_p</em> to 1 if the contents at <em>path1</em> under <em>root1</em> differ from those at <em>path2</em> under <em>root2</em>, or set it to 0 if they are the same. Both paths must exist under their respective roots, and both roots must be in the same filesystem. </p>

</div>
</div>
<a class="anchor" id="gaed6116279287a80ec4f7de380a732f45"></a><!-- doxytag: member="svn_fs.h::svn_fs_copied_from" ref="gaed6116279287a80ec4f7de380a732f45" args="(svn_revnum_t *rev_p, const char **path_p, svn_fs_root_t *root, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_copied_from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> *&#160;</td>
          <td class="paramname"><em>rev_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>path_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Discover a node's copy ancestry, if any. </p>
<p>If the node at <em>path</em> in <em>root</em> was copied from some other node, set <em>*rev_p</em> and <em>*path_p</em> to the revision and path (expressed as an absolute filesystem path) of the other node, allocating <em>*path_p</em> in <em>pool</em>.</p>
<p>Else if there is no copy ancestry for the node, set <em>*rev_p</em> to <a class="el" href="svn__types_8h.html#a8857d4630bf116eaba54a1b65d43ad92" title="The &#39;official&#39; invalid revision num.">SVN_INVALID_REVNUM</a> and <em>*path_p</em> to NULL.</p>
<p>If an error is returned, the values of <em>*rev_p</em> and <em>*path_p</em> are undefined, but otherwise, if one of them is set as described above, you may assume the other is set correspondingly.</p>
<p><em>root</em> may be a revision root or a transaction root.</p>
<p>Notes:</p>
<ul>
<li>Copy ancestry does not descend. After copying directory D to E, E will have copy ancestry referring to D, but E's children may not. See also <a class="el" href="group__fs__handling.html#ga9da8e22bd1058f877a275099699bb86b" title="Create a copy of from_path in from_root named to_path in to_root.">svn_fs_copy()</a>.</li>
</ul>
<ul>
<li>Copy ancestry *under* a copy is preserved. That is, if you copy /A/D/G/pi to /A/D/G/pi2, and then copy /A/D/G to /G, then /G/pi2 will still have copy ancestry pointing to /A/D/G/pi. We don't know if this is a feature or a bug yet; if it turns out to be a bug, then the fix is to make <a class="el" href="group__fs__handling.html#gaed6116279287a80ec4f7de380a732f45" title="Discover a node&#39;s copy ancestry, if any.">svn_fs_copied_from()</a> observe the following logic, which currently callers may choose to follow themselves: if node X has copy history, but its ancestor A also has copy history, then you may ignore X's history if X's revision-of-origin is earlier than A's -- because that would mean that X's copy history was preserved in a copy-under-a-copy scenario. If X's revision-of-origin is the same as A's, then it was copied under A during the same transaction that created A. (X's revision-of-origin cannot be greater than A's, if X has copy history.)<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>See how people like this, it can always be hidden behind the curtain if necessary.</dd></dl>
</li>
</ul>
<ul>
<li>Copy ancestry is not stored as a regular subversion property because it is not inherited. Copying foo to bar results in a revision of bar with copy ancestry; but committing a text change to bar right after that results in a new revision of bar without copy ancestry. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga9da8e22bd1058f877a275099699bb86b"></a><!-- doxytag: member="svn_fs.h::svn_fs_copy" ref="ga9da8e22bd1058f877a275099699bb86b" args="(svn_fs_root_t *from_root, const char *from_path, svn_fs_root_t *to_root, const char *to_path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>from_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>to_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a copy of <em>from_path</em> in <em>from_root</em> named <em>to_path</em> in <em>to_root</em>. </p>
<p>If <em>from_path</em> in <em>from_root</em> is a directory, copy the tree it refers to recursively.</p>
<p>The copy will remember its source; use <a class="el" href="group__fs__handling.html#gaed6116279287a80ec4f7de380a732f45" title="Discover a node&#39;s copy ancestry, if any.">svn_fs_copied_from()</a> to access this information.</p>
<p><em>to_root</em> must be the root of a transaction; <em>from_root</em> must be the root of a revision. (Requiring <em>from_root</em> to be the root of a revision makes the implementation trivial: there is no detectable difference (modulo node revision ID's) between copying <em>from</em> and simply adding a reference to it. So the operation takes place in constant time. However, there's no reason not to extend this to mutable nodes --- it's just more code.) Further, <em>to_root</em> and <em>from_root</em> must represent the same filesystem.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>To do a copy without preserving copy history, use <a class="el" href="group__fs__handling.html#gaddd7ec5b6e3306c609e46d4f5a2b8a5c" title="Like svn_fs_copy(), but doesn&#39;t record copy history, and preserves the PATH.">svn_fs_revision_link()</a>.</dd></dl>
<p>Do any necessary temporary allocation in <em>pool</em>. </p>

</div>
</div>
<a class="anchor" id="ga24b9cee11c6d584ddb0b9d74efca5dd5"></a><!-- doxytag: member="svn_fs.h::svn_fs_create" ref="ga24b9cee11c6d584ddb0b9d74efca5dd5" args="(svn_fs_t **fs_p, const char *path, apr_hash_t *fs_config, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> **&#160;</td>
          <td class="paramname"><em>fs_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_hash_t *&#160;</td>
          <td class="paramname"><em>fs_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new, empty Subversion filesystem, stored in the directory <em>path</em>, and return a pointer to it in <em>*fs_p</em>. </p>
<p><em>path</em> must not currently exist, but its parent must exist. If <em>fs_config</em> is not <code>NULL</code>, the options it contains modify the behavior of the filesystem. The interpretation of <em>fs_config</em> is specific to the filesystem back-end. The new filesystem may be closed by destroying <em>pool</em>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The lifetime of <em>fs_config</em> must not be shorter than <em>pool's</em>. It's a good idea to allocate <em>fs_config</em> from <em>pool</em> or one of its ancestors.</dd></dl>
<p>If <em>fs_config</em> contains a value for <a class="el" href="group__fs__handling.html#ga8cce99342f8830d9541901fcbc5fa8b3">SVN_FS_CONFIG_FS_TYPE</a>, that value determines the filesystem type for the new filesystem. Currently defined values are:</p>
<p>SVN_FS_TYPE_BDB Berkeley-DB implementation SVN_FS_TYPE_FSFS Native-filesystem implementation</p>
<p>If <em>fs_config</em> is <code>NULL</code> or does not contain a value for <a class="el" href="group__fs__handling.html#ga8cce99342f8830d9541901fcbc5fa8b3">SVN_FS_CONFIG_FS_TYPE</a> then the default filesystem type will be used. This will typically be BDB for version 1.1 and FSFS for later versions, though the caller should not rely upon any particular default if they wish to ensure that a filesystem of a specific type is created.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.1. </dd></dl>

</div>
</div>
<a class="anchor" id="ga528e3cf9010e463b511584f4143b6a72"></a><!-- doxytag: member="svn_fs.h::svn_fs_delete" ref="ga528e3cf9010e463b511584f4143b6a72" args="(svn_fs_root_t *root, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete the node named <em>path</em> in <em>root</em>. </p>
<p>If the node being deleted is a directory, its contents will be deleted recursively. <em>root</em> must be the root of a transaction, not of a revision. Use <em>pool</em> for temporary allocation.</p>
<p>If return <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660afe8be58c4336e3738d014080bad824b5" title="&quot;Filesystem directory has no such entry&quot;">SVN_ERR_FS_NO_SUCH_ENTRY</a>, then the basename of <em>path</em> is missing from its parent, that is, the final target of the deletion is missing.</p>
<p>Attempting to remove the root dir also results in an error, <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660ac8c62e965631f70a309adc10762fd2ac" title="&quot;Attempt to remove or recreate fs root dir&quot;">SVN_ERR_FS_ROOT_DIR</a>, even if the dir is empty. </p>

</div>
</div>
<a class="anchor" id="ga6d1642cd31bc5e860d521c8c80058058"></a><!-- doxytag: member="svn_fs.h::svn_fs_delete_fs" ref="ga6d1642cd31bc5e860d521c8c80058058" args="(const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_delete_fs </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete the filesystem at <em>path</em>. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.1. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3f29dd4915629fc66ea1af713b659ce5"></a><!-- doxytag: member="svn_fs.h::svn_fs_deltify_revision" ref="ga3f29dd4915629fc66ea1af713b659ce5" args="(svn_fs_t *fs, svn_revnum_t revision, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_deltify_revision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a>&#160;</td>
          <td class="paramname"><em>revision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provide filesystem <em>fs</em> the opportunity to compress storage relating to associated with <em>revision</em> in filesystem <em>fs</em>. </p>
<p>Use <em>pool</em> for all allocations.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This can be a time-consuming process, depending the breadth of the changes made in <em>revision</em>, and the depth of the history of those changed paths. This may also be a no op. </dd></dl>

</div>
</div>
<a class="anchor" id="gad254aea2a12fbd7c8c62c8aaa3c4624c"></a><!-- doxytag: member="svn_fs.h::svn_fs_dir_entries" ref="gad254aea2a12fbd7c8c62c8aaa3c4624c" args="(apr_hash_t **entries_p, svn_fs_root_t *root, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_dir_entries </td>
          <td>(</td>
          <td class="paramtype">apr_hash_t **&#160;</td>
          <td class="paramname"><em>entries_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set <em>*entries_p</em> to a newly allocated APR hash table containing the entries of the directory at <em>path</em> in <em>root</em>. </p>
<p>The keys of the table are entry names, as byte strings, excluding the final NULL character; the table's values are pointers to <a class="el" href="structsvn__fs__dirent__t.html" title="The type of a Subversion directory entry.">svn_fs_dirent_t</a> structures. Allocate the table and its contents in <em>pool</em>. </p>

</div>
</div>
<a class="anchor" id="ga3a35bf47dcd1d43fdf7572166eb0eeb4"></a><!-- doxytag: member="svn_fs.h::svn_fs_file_checksum" ref="ga3a35bf47dcd1d43fdf7572166eb0eeb4" args="(svn_checksum_t **checksum, svn_checksum_kind_t kind, svn_fs_root_t *root, const char *path, svn_boolean_t force, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_file_checksum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__checksum__t.html">svn_checksum_t</a> **&#160;</td>
          <td class="paramname"><em>checksum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__checksum_8h.html#a7a6c373d03d7e6ec6b832a039f5e0aa1">svn_checksum_kind_t</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>force</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set <em>*checksum</em> to the checksum of type <em>kind</em> for the file <em>path</em>. </p>
<p><em>*checksum</em> will be allocated out of <em>pool</em>, which will also be used for temporary allocations.</p>
<p>If the filesystem does not have a prerecorded checksum of <em>kind</em> for <em>path</em>, and <em>force</em> is not TRUE, do not calculate a checksum dynamically, just put NULL into <em>checksum</em>. (By convention, the NULL checksum is considered to match any checksum.)</p>
<p>Notes:</p>
<p>You might wonder, why do we only provide this interface for file contents, and not for properties or directories?</p>
<p>The answer is that property lists and directory entry lists are essentially data structures, not text. We serialize them for transmission, but there is no guarantee that the consumer will parse them into the same form, or even the same order, as the producer. It's difficult to find a checksumming method that reaches the same result given such variation in input. (I suppose we could calculate an independent MD5 sum for each propname and value, and XOR them together; same with directory entry names. Maybe that's the solution?) Anyway, for now we punt. The most important data, and the only data that goes through svndiff processing, is file contents, so that's what we provide checksumming for.</p>
<p>Internally, of course, the filesystem checksums everything, because it has access to the lowest level storage forms: strings behind representations.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a class="anchor" id="gafe8eadb1c6950e3bfdca49bbb497d6fb"></a><!-- doxytag: member="svn_fs.h::svn_fs_file_contents" ref="gafe8eadb1c6950e3bfdca49bbb497d6fb" args="(svn_stream_t **contents, svn_fs_root_t *root, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_file_contents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set <em>*contents</em> to a readable generic stream that will yield the contents of the file <em>path</em> in <em>root</em>. </p>
<p>Allocate the stream in <em>pool</em>. You can only use <em>*contents</em> for as long as the underlying filesystem is open. If <em>path</em> is not a file, return <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660aa450bc43bfe000e40bc1461ced205a8d" title="&quot;Name does not refer to a filesystem file&quot;">SVN_ERR_FS_NOT_FILE</a>.</p>
<p>If <em>root</em> is the root of a transaction, it is possible that the contents of the file <em>path</em> will change between calls to <a class="el" href="group__fs__handling.html#gafe8eadb1c6950e3bfdca49bbb497d6fb" title="Set *contents to a readable generic stream that will yield the contents of the file path in root...">svn_fs_file_contents()</a>. In that case, the result of reading from <em>*contents</em> is undefined.</p>
<p>###</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>kff: I am worried about lifetime issues with this pool vs the trail created farther down the call stack. Trace this function to investigate... </dd></dl>

</div>
</div>
<a class="anchor" id="gabd675ec4bc28c7f4e72a121feeb60059"></a><!-- doxytag: member="svn_fs.h::svn_fs_file_length" ref="gabd675ec4bc28c7f4e72a121feeb60059" args="(svn_filesize_t *length_p, svn_fs_root_t *root, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_file_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a726e581898461c1d3e7dbdb16d99dad0">svn_filesize_t</a> *&#160;</td>
          <td class="paramname"><em>length_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set <em>*length_p</em> to the length of the file <em>path</em> in <em>root</em>, in bytes. </p>
<p>Do any necessary temporary allocation in <em>pool</em>. </p>

</div>
</div>
<a class="anchor" id="ga9dfe5ed9f63bb8b222d2adb2b96f0220"></a><!-- doxytag: member="svn_fs.h::svn_fs_file_md5_checksum" ref="ga9dfe5ed9f63bb8b222d2adb2b96f0220" args="(unsigned char digest[], svn_fs_root_t *root, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_file_md5_checksum </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>digest</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Same as <a class="el" href="group__fs__handling.html#ga3a35bf47dcd1d43fdf7572166eb0eeb4" title="Set *checksum to the checksum of type kind for the file path.">svn_fs_file_checksum()</a>, only always put the MD5 checksum of file <em>path</em> into <em>digest</em>, which should point to <code>APR_MD5_DIGESTSIZE</code> bytes of storage. </p>
<p>If the checksum doesn't exist, put all 0's into <em>digest</em>.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000176">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.5 API. </dd></dl>

</div>
</div>
<a class="anchor" id="gad2d4b1fa18c0bbda6719d4414b52f4c2"></a><!-- doxytag: member="svn_fs.h::svn_fs_get_file_delta_stream" ref="gad2d4b1fa18c0bbda6719d4414b52f4c2" args="(svn_txdelta_stream_t **stream_p, svn_fs_root_t *source_root, const char *source_path, svn_fs_root_t *target_root, const char *target_path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_get_file_delta_stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__delta__txt__delta.html#gaf599af000e3c3b976c17fd4e101ff7cf">svn_txdelta_stream_t</a> **&#160;</td>
          <td class="paramname"><em>stream_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>source_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>source_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>target_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>target_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set <em>*stream_p</em> to a pointer to a delta stream that will turn the contents of the file <em>source</em> into the contents of the file <em>target</em>. </p>
<p>If <em>source_root</em> is zero, use a file with zero length as the source.</p>
<p>This function does not compare the two files' properties.</p>
<p>Allocate <em>*stream_p</em>, and do any necessary temporary allocation, in <em>pool</em>. </p>

</div>
</div>
<a class="anchor" id="ga2976ec837ee7caa7771e61ed266933b5"></a><!-- doxytag: member="svn_fs.h::svn_fs_get_mergeinfo" ref="ga2976ec837ee7caa7771e61ed266933b5" args="(svn_mergeinfo_catalog_t *catalog, svn_fs_root_t *root, const apr_array_header_t *paths, svn_mergeinfo_inheritance_t inherit, svn_boolean_t include_descendants, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_get_mergeinfo </td>
          <td>(</td>
          <td class="paramtype">svn_mergeinfo_catalog_t *&#160;</td>
          <td class="paramname"><em>catalog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const apr_array_header_t *&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#acd81e9d0f5bcc4eec4df7b8a140f435c">svn_mergeinfo_inheritance_t</a>&#160;</td>
          <td class="paramname"><em>inherit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>include_descendants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve mergeinfo for multiple nodes. </p>
<p><em>*catalog</em> is a catalog for <em>paths</em>. It will never be <code>NULL</code>, but may be empty.</p>
<p><em>root</em> is revision root to use when looking up paths.</p>
<p><em>paths</em> are the paths you are requesting information for.</p>
<p><em>inherit</em> indicates whether to retrieve explicit, explicit-or-inherited, or only inherited mergeinfo.</p>
<p>If <em>include_descendants</em> is TRUE, then additionally return the mergeinfo for any descendant of any element of <em>paths</em> which has the <a class="el" href="group__svn__prop__visible__props.html#gadfcde61bc857d2fa1741eb8e55588425" title="Merge info property used to record a resource&#39;s merge history.">SVN_PROP_MERGEINFO</a> property explicitly set on it. (Note that inheritance is only taken into account for the elements in <em>paths</em>; descendants of the elements in <em>paths</em> which get their mergeinfo via inheritance are not included in <em>*catalog</em>.)</p>
<p>Do any necessary temporary allocation in <em>pool</em>.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2ce6bd7610fc7201f4ea6b4e20e49e67"></a><!-- doxytag: member="svn_fs.h::svn_fs_get_uuid" ref="ga2ce6bd7610fc7201f4ea6b4e20e49e67" args="(svn_fs_t *fs, const char **uuid, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_get_uuid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>uuid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Populate <em>*uuid</em> with the UUID associated with <em>fs</em>. </p>
<p>Allocate <em>*uuid</em> in <em>pool</em>. </p>

</div>
</div>
<a class="anchor" id="ga266d0597466eb198dc4b593fcd44490e"></a><!-- doxytag: member="svn_fs.h::svn_fs_history_location" ref="ga266d0597466eb198dc4b593fcd44490e" args="(const char **path, svn_revnum_t *revision, svn_fs_history_t *history, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_history_location </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> *&#160;</td>
          <td class="paramname"><em>revision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#gaa31b679ed9ca7b53241ebda04c035140">svn_fs_history_t</a> *&#160;</td>
          <td class="paramname"><em>history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set <em>*path</em> and <em>*revision</em> to the path and revision, respectively, of the <em>history</em> object. </p>
<p>Use <em>pool</em> for all allocations. </p>

</div>
</div>
<a class="anchor" id="ga58dd5d7dc74bef946a4dc1129c342038"></a><!-- doxytag: member="svn_fs.h::svn_fs_history_prev" ref="ga58dd5d7dc74bef946a4dc1129c342038" args="(svn_fs_history_t **prev_history_p, svn_fs_history_t *history, svn_boolean_t cross_copies, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_history_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#gaa31b679ed9ca7b53241ebda04c035140">svn_fs_history_t</a> **&#160;</td>
          <td class="paramname"><em>prev_history_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#gaa31b679ed9ca7b53241ebda04c035140">svn_fs_history_t</a> *&#160;</td>
          <td class="paramname"><em>history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>cross_copies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set <em>*prev_history_p</em> to an opaque node history object which represents the previous (or "next oldest") interesting history location for the filesystem node represented by <em>history</em>, or <code>NULL</code> if no such previous history exists. </p>
<p>If <em>cross_copies</em> is <code>FALSE</code>, also return <code>NULL</code> if stepping backwards in history to <em>*prev_history_p</em> would cross a filesystem copy operation.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If this is the first call to <a class="el" href="group__fs__handling.html#ga58dd5d7dc74bef946a4dc1129c342038" title="Set *prev_history_p to an opaque node history object which represents the previous (or &quot;next oldest&quot;)...">svn_fs_history_prev()</a> for the <em>history</em> object, it could return a history object whose location is the same as the original. This will happen if the original location was an interesting one (where the node was modified, or took place in a copy event). This behavior allows looping callers to avoid the calling <a class="el" href="group__fs__handling.html#ga266d0597466eb198dc4b593fcd44490e" title="Set *path and *revision to the path and revision, respectively, of the history object.">svn_fs_history_location()</a> on the object returned by <a class="el" href="group__fs__handling.html#ga2412ddc868b0ef6cdbbe3b682827885e" title="Set *history_p to an opaque node history object which represents path under root.">svn_fs_node_history()</a>, and instead go ahead and begin calling <a class="el" href="group__fs__handling.html#ga58dd5d7dc74bef946a4dc1129c342038" title="Set *prev_history_p to an opaque node history object which represents the previous (or &quot;next oldest&quot;)...">svn_fs_history_prev()</a>.</dd>
<dd>
This function uses node-id ancestry alone to determine modifiedness, and therefore does NOT claim that in any of the returned revisions file contents changed, properties changed, directory entries lists changed, etc.</dd>
<dd>
The revisions returned for <em>path</em> will be older than or the same age as the revision of that path in <em>root</em>. That is, if <em>root</em> is a revision root based on revision X, and <em>path</em> was modified in some revision(s) younger than X, those revisions younger than X will not be included for <em>path</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2909d84e561fbfd8b0f321dbded129b6"></a><!-- doxytag: member="svn_fs.h::svn_fs_hotcopy" ref="ga2909d84e561fbfd8b0f321dbded129b6" args="(const char *src_path, const char *dest_path, svn_boolean_t clean, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_hotcopy </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dest_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>clean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy a possibly live Subversion filesystem from <em>src_path</em> to <em>dest_path</em>. </p>
<p>If <em>clean</em> is <code>TRUE</code>, perform cleanup on the source filesystem as part of the copy operation; currently, this means deleting copied, unused logfiles for a Berkeley DB source filesystem.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.1. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf3bce1e26521c4432f14f3adfc617f17"></a><!-- doxytag: member="svn_fs.h::svn_fs_initialize" ref="gaf3bce1e26521c4432f14f3adfc617f17" args="(apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_initialize </td>
          <td>(</td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callers should invoke this function to initialize global state in the FS library before creating FS objects. </p>
<p>If this function is invoked, no FS objects may be created in another thread at the same time as this invocation, and the provided <em>pool</em> must last longer than any FS object created subsequently.</p>
<p>If this function is not called, the FS library will make a best effort to bootstrap a mutex for protecting data common to FS objects; however, there is a small window of failure. Also, a small amount of data will be leaked if the Subversion FS library is dynamically unloaded, and using the bdb FS can potentially segfault or invoke other undefined behavior if this function is not called with an appropriate pool (such as the pool the module was loaded into) when loaded dynamically.</p>
<p>If this function is called multiple times before the pool passed to the first call is destroyed or cleared, the later calls will have no effect.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.2. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1a5ecfab7f53876e9ad6def4265df7e6"></a><!-- doxytag: member="svn_fs.h::svn_fs_is_dir" ref="ga1a5ecfab7f53876e9ad6def4265df7e6" args="(svn_boolean_t *is_dir, svn_fs_root_t *root, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_is_dir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *&#160;</td>
          <td class="paramname"><em>is_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set <em>*is_dir</em> to <code>TRUE</code> iff <em>path</em> in <em>root</em> is a directory. </p>
<p>Do any necessary temporary allocation in <em>pool</em>. </p>

</div>
</div>
<a class="anchor" id="ga84b9e2f502354e16162edd12e8f5cc5b"></a><!-- doxytag: member="svn_fs.h::svn_fs_is_file" ref="ga84b9e2f502354e16162edd12e8f5cc5b" args="(svn_boolean_t *is_file, svn_fs_root_t *root, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_is_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *&#160;</td>
          <td class="paramname"><em>is_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set <em>*is_file</em> to <code>TRUE</code> iff <em>path</em> in <em>root</em> is a file. </p>
<p>Do any necessary temporary allocation in <em>pool</em>. </p>

</div>
</div>
<a class="anchor" id="ga8484e37e57a52bb38e5067c38bf41e16"></a><!-- doxytag: member="svn_fs.h::svn_fs_make_dir" ref="ga8484e37e57a52bb38e5067c38bf41e16" args="(svn_fs_root_t *root, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_make_dir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new directory named <em>path</em> in <em>root</em>. </p>
<p>The new directory has no entries, and no properties. <em>root</em> must be the root of a transaction, not a revision.</p>
<p>Do any necessary temporary allocation in <em>pool</em>. </p>

</div>
</div>
<a class="anchor" id="gac760753f1ae74fc19991d5dab7cb643c"></a><!-- doxytag: member="svn_fs.h::svn_fs_make_file" ref="gac760753f1ae74fc19991d5dab7cb643c" args="(svn_fs_root_t *root, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_make_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new file named <em>path</em> in <em>root</em>. </p>
<p>The file's initial contents are the empty string, and it has no properties. <em>root</em> must be the root of a transaction, not a revision.</p>
<p>Do any necessary temporary allocation in <em>pool</em>. </p>

</div>
</div>
<a class="anchor" id="gafc5df16564312635dc97077a29e73d8e"></a><!-- doxytag: member="svn_fs.h::svn_fs_merge" ref="gafc5df16564312635dc97077a29e73d8e" args="(const char **conflict_p, svn_fs_root_t *source_root, const char *source_path, svn_fs_root_t *target_root, const char *target_path, svn_fs_root_t *ancestor_root, const char *ancestor_path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_merge </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>conflict_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>source_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>source_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>target_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>target_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>ancestor_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ancestor_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Merge changes between two nodes into a third node. </p>
<p>Given nodes <em>source</em> and <em>target</em>, and a common ancestor <em>ancestor</em>, modify <em>target</em> to contain all the changes made between <em>ancestor</em> and <em>source</em>, as well as the changes made between <em>ancestor</em> and <em>target</em>. <em>target_root</em> must be the root of a transaction, not a revision.</p>
<p><em>source</em>, <em>target</em>, and <em>ancestor</em> are generally directories; this function recursively merges the directories' contents. If they are files, this function simply returns an error whenever <em>source</em>, <em>target</em>, and <em>ancestor</em> are all distinct node revisions.</p>
<p>If there are differences between <em>ancestor</em> and <em>source</em> that conflict with changes between <em>ancestor</em> and <em>target</em>, this function returns an <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660a2556cd0052d1516e3985bcc99760a66d" title="&quot;Merge conflict during commit&quot;">SVN_ERR_FS_CONFLICT</a> error.</p>
<p>If the merge is successful, <em>target</em> is left in the merged state, and the base root of <em>target's</em> txn is set to the root node of <em>source</em>. If an error is returned (whether for conflict or otherwise), <em>target</em> is left unaffected.</p>
<p>If <em>conflict_p</em> is non-NULL, then: a conflict error sets <em>*conflict_p</em> to the name of the node in <em>target</em> which couldn't be merged, otherwise, success sets <em>*conflict_p</em> to NULL.</p>
<p>Do any necessary temporary allocation in <em>pool</em>. </p>

</div>
</div>
<a class="anchor" id="gaf25b3de3d8930d857cf6c94777ce9bca"></a><!-- doxytag: member="svn_fs.h::svn_fs_node_created_path" ref="gaf25b3de3d8930d857cf6c94777ce9bca" args="(const char **created_path, svn_fs_root_t *root, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_node_created_path </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>created_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set <em>*created_path</em> to the path at which <em>path</em> under <em>root</em> was created. </p>
<p>Use <em>pool</em> for all allocations. Callers may use this function in conjunction with <a class="el" href="group__fs__handling.html#gad3be25cd08e898319e14cce69580992e" title="Set *revision to the revision in which path under root was created.">svn_fs_node_created_rev()</a> to perform a reverse lookup of the mapping of (path, revision) -&gt; node-id that <a class="el" href="group__fs__handling.html#gaf59a66cf510e6da06dadfe2b3bb372e1" title="Get the id of a node.">svn_fs_node_id()</a> performs. </p>

</div>
</div>
<a class="anchor" id="gad3be25cd08e898319e14cce69580992e"></a><!-- doxytag: member="svn_fs.h::svn_fs_node_created_rev" ref="gad3be25cd08e898319e14cce69580992e" args="(svn_revnum_t *revision, svn_fs_root_t *root, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_node_created_rev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> *&#160;</td>
          <td class="paramname"><em>revision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set <em>*revision</em> to the revision in which <em>path</em> under <em>root</em> was created. </p>
<p>Use <em>pool</em> for any temporary allocations. <em>*revision</em> will be set to <a class="el" href="svn__types_8h.html#a8857d4630bf116eaba54a1b65d43ad92" title="The &#39;official&#39; invalid revision num.">SVN_INVALID_REVNUM</a> for uncommitted nodes (i.e. modified nodes under a transaction root). Note that the root of an unmodified transaction is not itself considered to be modified; in that case, return the revision upon which the transaction was based. </p>

</div>
</div>
<a class="anchor" id="ga2412ddc868b0ef6cdbbe3b682827885e"></a><!-- doxytag: member="svn_fs.h::svn_fs_node_history" ref="ga2412ddc868b0ef6cdbbe3b682827885e" args="(svn_fs_history_t **history_p, svn_fs_root_t *root, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_node_history </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#gaa31b679ed9ca7b53241ebda04c035140">svn_fs_history_t</a> **&#160;</td>
          <td class="paramname"><em>history_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set <em>*history_p</em> to an opaque node history object which represents <em>path</em> under <em>root</em>. </p>
<p><em>root</em> must be a revision root. Use <em>pool</em> for all allocations. </p>

</div>
</div>
<a class="anchor" id="gaf59a66cf510e6da06dadfe2b3bb372e1"></a><!-- doxytag: member="svn_fs.h::svn_fs_node_id" ref="gaf59a66cf510e6da06dadfe2b3bb372e1" args="(const svn_fs_id_t **id_p, svn_fs_root_t *root, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_node_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__svn__fs__nodes.html#gaeca8f1c373c50ca7bb08e3417242b106">svn_fs_id_t</a> **&#160;</td>
          <td class="paramname"><em>id_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the id of a node. </p>
<p>Set <em>*id_p</em> to the node revision ID of <em>path</em> in <em>root</em>, allocated in <em>pool</em>.</p>
<p>If <em>root</em> is the root of a transaction, keep in mind that other changes to the transaction can change which node <em>path</em> refers to, and even whether the path exists at all. </p>

</div>
</div>
<a class="anchor" id="gaf26ebca946019f3761f48ad8dadd6eaa"></a><!-- doxytag: member="svn_fs.h::svn_fs_node_origin_rev" ref="gaf26ebca946019f3761f48ad8dadd6eaa" args="(svn_revnum_t *revision, svn_fs_root_t *root, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_node_origin_rev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> *&#160;</td>
          <td class="paramname"><em>revision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set <em>*revision</em> to the revision in which the line of history represented by <em>path</em> under <em>root</em> originated. </p>
<p>Use <em>pool</em> for any temporary allocations. If <em>root</em> is a transaction root, <em>*revision</em> will be set to <a class="el" href="svn__types_8h.html#a8857d4630bf116eaba54a1b65d43ad92" title="The &#39;official&#39; invalid revision num.">SVN_INVALID_REVNUM</a> for any nodes newly added in that transaction (brand new files or directories created using <a class="el" href="group__fs__handling.html#ga8484e37e57a52bb38e5067c38bf41e16" title="Create a new directory named path in root.">svn_fs_make_dir</a> or <a class="el" href="group__fs__handling.html#gac760753f1ae74fc19991d5dab7cb643c" title="Create a new file named path in root.">svn_fs_make_file</a>).</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="ga830b554597da876e1b6256f2836cf349"></a><!-- doxytag: member="svn_fs.h::svn_fs_node_prop" ref="ga830b554597da876e1b6256f2836cf349" args="(svn_string_t **value_p, svn_fs_root_t *root, const char *path, const char *propname, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_node_prop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__string__t.html">svn_string_t</a> **&#160;</td>
          <td class="paramname"><em>value_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>propname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set <em>*value_p</em> to the value of the property named <em>propname</em> of <em>path</em> in <em>root</em>. </p>
<p>If the node has no property by that name, set <em>*value_p</em> to zero. Allocate the result in <em>pool</em>. </p>

</div>
</div>
<a class="anchor" id="ga079534da68d59ac24307ae171189dd61"></a><!-- doxytag: member="svn_fs.h::svn_fs_node_proplist" ref="ga079534da68d59ac24307ae171189dd61" args="(apr_hash_t **table_p, svn_fs_root_t *root, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_node_proplist </td>
          <td>(</td>
          <td class="paramtype">apr_hash_t **&#160;</td>
          <td class="paramname"><em>table_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set <em>*table_p</em> to the entire property list of <em>path</em> in <em>root</em>, as an APR hash table allocated in <em>pool</em>. </p>
<p>The resulting table maps property names to pointers to <a class="el" href="structsvn__string__t.html" title="A simple counted string.">svn_string_t</a> objects containing the property value. </p>

</div>
</div>
<a class="anchor" id="gaf31aff19f6ddd70e665235ff1857fc35"></a><!-- doxytag: member="svn_fs.h::svn_fs_open" ref="gaf31aff19f6ddd70e665235ff1857fc35" args="(svn_fs_t **fs_p, const char *path, apr_hash_t *fs_config, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> **&#160;</td>
          <td class="paramname"><em>fs_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_hash_t *&#160;</td>
          <td class="paramname"><em>fs_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open a Subversion filesystem located in the directory <em>path</em>, and return a pointer to it in <em>*fs_p</em>. </p>
<p>If <em>fs_config</em> is not <code>NULL</code>, the options it contains modify the behavior of the filesystem. The interpretation of <em>fs_config</em> is specific to the filesystem back-end. The opened filesystem may be closed by destroying <em>pool</em>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The lifetime of <em>fs_config</em> must not be shorter than <em>pool's</em>. It's a good idea to allocate <em>fs_config</em> from <em>pool</em> or one of its ancestors.</dd></dl>
<p>Only one thread may operate on any given filesystem object at once. Two threads may access the same filesystem simultaneously only if they open separate filesystem objects.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>You probably don't want to use this directly. Take a look at <a class="el" href="svn__repos_8h.html#a515e52a79813e3fc34fffd8fedd40df0" title="Set *repos_p to a repository object for the repository at path.">svn_repos_open2()</a> instead.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.1. </dd></dl>

</div>
</div>
<a class="anchor" id="ga307aa2f60e82d9f78d7f7990991533c3"></a><!-- doxytag: member="svn_fs.h::svn_fs_pack" ref="ga307aa2f60e82d9f78d7f7990991533c3" args="(const char *db_path, svn_fs_pack_notify_t notify_func, void *notify_baton, svn_cancel_func_t cancel_func, void *cancel_baton, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_pack </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga418eae984b0da828404197edf9fcc46e">svn_fs_pack_notify_t</a>&#160;</td>
          <td class="paramname"><em>notify_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>notify_baton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#addaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a>&#160;</td>
          <td class="paramname"><em>cancel_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cancel_baton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Possibly update the filesystem located in the directory <em>path</em> to use disk space more efficiently. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa1a79172a1faa38b234d365240079c3a"></a><!-- doxytag: member="svn_fs.h::svn_fs_path" ref="gaa1a79172a1faa38b234d365240079c3a" args="(svn_fs_t *fs, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* svn_fs_path </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the path to <em>fs's</em> repository, allocated in <em>pool</em>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is just what was passed to <a class="el" href="group__fs__handling.html#ga24b9cee11c6d584ddb0b9d74efca5dd5" title="Create a new, empty Subversion filesystem, stored in the directory path, and return a pointer to it i...">svn_fs_create()</a> or <a class="el" href="group__fs__handling.html#gaf31aff19f6ddd70e665235ff1857fc35" title="Open a Subversion filesystem located in the directory path, and return a pointer to it in *fs_p...">svn_fs_open()</a> -- might be absolute, might not.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.1. </dd></dl>

</div>
</div>
<a class="anchor" id="ga26cf98c986a0f71fe9d86be0f73266b6"></a><!-- doxytag: member="svn_fs.h::svn_fs_print_modules" ref="ga26cf98c986a0f71fe9d86be0f73266b6" args="(svn_stringbuf_t *output, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_print_modules </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append a textual list of all available FS modules to the stringbuf <em>output</em>. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.2. </dd></dl>

</div>
</div>
<a class="anchor" id="gaac7c1a6f4732d24a8ee387abb33e33dc"></a><!-- doxytag: member="svn_fs.h::svn_fs_props_changed" ref="gaac7c1a6f4732d24a8ee387abb33e33dc" args="(svn_boolean_t *changed_p, svn_fs_root_t *root1, const char *path1, svn_fs_root_t *root2, const char *path2, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_props_changed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *&#160;</td>
          <td class="paramname"><em>changed_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>root2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine if the properties of two path/root combinations are different. </p>
<p>Set <em>*changed_p</em> to 1 if the properties at <em>path1</em> under <em>root1</em> differ from those at <em>path2</em> under <em>root2</em>, or set it to 0 if they are the same. Both paths must exist under their respective roots, and both roots must be in the same filesystem. </p>

</div>
</div>
<a class="anchor" id="gaf6f1f42958e3f56326185b91fc1ae679"></a><!-- doxytag: member="svn_fs.h::svn_fs_recover" ref="gaf6f1f42958e3f56326185b91fc1ae679" args="(const char *path, svn_cancel_func_t cancel_func, void *cancel_baton, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_recover </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#addaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a>&#160;</td>
          <td class="paramname"><em>cancel_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cancel_baton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform any necessary non-catastrophic recovery on the Subversion filesystem located at <em>path</em>. </p>
<p>If <em>cancel_func</em> is not <code>NULL</code>, it is called periodically with <em>cancel_baton</em> as argument to see if the client wishes to cancel recovery. BDB filesystems do not currently support cancellation.</p>
<p>Do any necessary allocation within <em>pool</em>.</p>
<p>For FSFS filesystems, recovery is currently limited to recreating the db/current file, and does not require exclusive access.</p>
<p>For BDB filesystems, recovery requires exclusive access, and is described in detail below.</p>
<p>After an unexpected server exit, due to a server crash or a system crash, a Subversion filesystem based on Berkeley DB needs to run recovery procedures to bring the database back into a consistent state and release any locks that were held by the deceased process. The recovery procedures require exclusive access to the database --- while they execute, no other process or thread may access the database.</p>
<p>In a server with multiple worker processes, like Apache, if a worker process accessing the filesystem dies, you must stop the other worker processes, and run recovery. Then, the other worker processes can re-open the database and resume work.</p>
<p>If the server exited cleanly, there is no need to run recovery, but there is no harm in it, either, and it take very little time. So it's a fine idea to run recovery when the server process starts, before it begins handling any requests.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="gaddd7ec5b6e3306c609e46d4f5a2b8a5c"></a><!-- doxytag: member="svn_fs.h::svn_fs_revision_link" ref="gaddd7ec5b6e3306c609e46d4f5a2b8a5c" args="(svn_fs_root_t *from_root, svn_fs_root_t *to_root, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_revision_link </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>from_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#gaa0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&#160;</td>
          <td class="paramname"><em>to_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like <a class="el" href="group__fs__handling.html#ga9da8e22bd1058f877a275099699bb86b" title="Create a copy of from_path in from_root named to_path in to_root.">svn_fs_copy()</a>, but doesn't record copy history, and preserves the PATH. </p>
<p>You cannot use <a class="el" href="group__fs__handling.html#gaed6116279287a80ec4f7de380a732f45" title="Discover a node&#39;s copy ancestry, if any.">svn_fs_copied_from()</a> later to find out where this copy came from.</p>
<p>Use <a class="el" href="group__fs__handling.html#gaddd7ec5b6e3306c609e46d4f5a2b8a5c" title="Like svn_fs_copy(), but doesn&#39;t record copy history, and preserves the PATH.">svn_fs_revision_link()</a> in situations where you don't care about the copy history, and where <em>to_path</em> and <em>from_path</em> are the same, because it is cheaper than <a class="el" href="group__fs__handling.html#ga9da8e22bd1058f877a275099699bb86b" title="Create a copy of from_path in from_root named to_path in to_root.">svn_fs_copy()</a>. </p>

</div>
</div>
<a class="anchor" id="ga0cd6959ee54cd16768477d608fd33c34"></a><!-- doxytag: member="svn_fs.h::svn_fs_revision_prop" ref="ga0cd6959ee54cd16768477d608fd33c34" args="(svn_string_t **value_p, svn_fs_t *fs, svn_revnum_t rev, const char *propname, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_revision_prop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__string__t.html">svn_string_t</a> **&#160;</td>
          <td class="paramname"><em>value_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a>&#160;</td>
          <td class="paramname"><em>rev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>propname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set <em>*value_p</em> to the value of the property named <em>propname</em> on revision <em>rev</em> in the filesystem <em>fs</em>. </p>
<p>If <em>rev</em> has no property by that name, set <em>*value_p</em> to zero. Allocate the result in <em>pool</em>. </p>

</div>
</div>
<a class="anchor" id="ga423da8c30eacc9787ec7bc3dd1b9e351"></a><!-- doxytag: member="svn_fs.h::svn_fs_revision_proplist" ref="ga423da8c30eacc9787ec7bc3dd1b9e351" args="(apr_hash_t **table_p, svn_fs_t *fs, svn_revnum_t rev, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_revision_proplist </td>
          <td>(</td>
          <td class="paramtype">apr_hash_t **&#160;</td>
          <td class="paramname"><em>table_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a>&#160;</td>
          <td class="paramname"><em>rev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set <em>*table_p</em> to the entire property list of revision <em>rev</em> in filesystem <em>fs</em>, as an APR hash table allocated in <em>pool</em>. </p>
<p>The table maps <code>char *</code> property names to <a class="el" href="structsvn__string__t.html" title="A simple counted string.">svn_string_t</a> * values; the names and values are allocated in <em>pool</em>. </p>

</div>
</div>
<a class="anchor" id="gabec2453f61fb9356db9526d4c56f3a62"></a><!-- doxytag: member="svn_fs.h::svn_fs_set_uuid" ref="gabec2453f61fb9356db9526d4c56f3a62" args="(svn_fs_t *fs, const char *uuid, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_set_uuid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>uuid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If not <code>NULL</code>, associate <em>*uuid</em> with <em>fs</em>. </p>
<p>Otherwise (if <em>uuid</em> is <code>NULL</code>), generate a new UUID for <em>fs</em>. Use <em>pool</em> for any scratch work. </p>

</div>
</div>
<a class="anchor" id="gabc881c866ebe2cbd41767374264532e8"></a><!-- doxytag: member="svn_fs.h::svn_fs_set_warning_func" ref="gabc881c866ebe2cbd41767374264532e8" args="(svn_fs_t *fs, svn_fs_warning_callback_t warning, void *warning_baton)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_fs_set_warning_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#gafa2c790fffb1abbd103c954a5d983646">svn_fs_warning_callback_t</a>&#160;</td>
          <td class="paramname"><em>warning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>warning_baton</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provide a callback function, <em>warning</em>, that <em>fs</em> should use to report (non-fatal) errors. </p>
<p>To print an error, the filesystem will call <em>warning</em>, passing it <em>warning_baton</em> and the error.</p>
<p>By default, this is set to a function that will crash the process. Dumping to <code>stderr</code> or <code>/dev/tty</code> is not acceptable default behavior for server processes, since those may both be equivalent to <code>/dev/null</code>. </p>

</div>
</div>
<a class="anchor" id="gae771342c2800751277423c552cfeee48"></a><!-- doxytag: member="svn_fs.h::svn_fs_type" ref="gae771342c2800751277423c552cfeee48" args="(const char **fs_type, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_type </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>fs_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return, in <em>*fs_type</em>, a string identifying the back-end type of the Subversion filesystem located in <em>path</em>. </p>
<p>Allocate <em>*fs_type</em> in <em>pool</em>.</p>
<p>The string should be equal to one of the <code>SVN_FS_TYPE_*</code> defined constants, unless the filesystem is a new back-end type added in a later version of Subversion.</p>
<p>In general, the type should make no difference in the filesystem's semantics, but there are a few situations (such as backups) where it might matter.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.3. </dd></dl>

</div>
</div>
<a class="anchor" id="ga64cb2a37367de523f56b89e5ec603a73"></a><!-- doxytag: member="svn_fs.h::svn_fs_upgrade" ref="ga64cb2a37367de523f56b89e5ec603a73" args="(const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_upgrade </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Upgrade the Subversion filesystem located in the directory <em>path</em> to the latest version supported by this library. </p>
<p>Return <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660a51588550b5e7e9b961b68dbe4acb128c" title="&quot;Filesystem upgrade is not supported&quot;">SVN_ERR_FS_UNSUPPORTED_UPGRADE</a> and make no changes to the filesystem if the requested upgrade is not supported. Use <em>pool</em> for necessary allocations.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>You probably don't want to use this directly. Take a look at <a class="el" href="svn__repos_8h.html#afa89fd30c6a04e09d025bcf1e30148cd" title="Similar to svn_repos_upgrade2(), but with start_callback and baton, rather than a notify_callback / b...">svn_repos_upgrade()</a> instead.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4af11f84095941c21fad6e22f62dd31d"></a><!-- doxytag: member="svn_fs.h::svn_fs_youngest_rev" ref="ga4af11f84095941c21fad6e22f62dd31d" args="(svn_revnum_t *youngest_p, svn_fs_t *fs, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_youngest_rev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> *&#160;</td>
          <td class="paramname"><em>youngest_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set <em>*youngest_p</em> to the number of the youngest revision in filesystem <em>fs</em>. </p>
<p>Use <em>pool</em> for all temporary allocation.</p>
<p>The oldest revision in any filesystem is numbered zero. </p>

</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 23 2011 09:20:41 for Subversion by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
