<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Subversion: Generic byte streams</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Subversion
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Generic byte streams</div>  </div>
</div><!--header-->
<div class="contents">

<p>Generic byte-streams.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga06d6291c397e63f895deb92a2c14e6af"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a></td></tr>
<tr class="memdesc:ga06d6291c397e63f895deb92a2c14e6af"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract stream of bytes&ndash;either incoming or outgoing or both.  <a href="#ga06d6291c397e63f895deb92a2c14e6af">More...</a><br/></td></tr>
<tr class="separator:ga06d6291c397e63f895deb92a2c14e6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a8939b5258b070a48aa1e0cd154909a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga9a8939b5258b070a48aa1e0cd154909a">svn_read_fn_t</a> )(void *baton, char *buffer, apr_size_t *len)</td></tr>
<tr class="memdesc:ga9a8939b5258b070a48aa1e0cd154909a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read handler function for a generic stream.  <a href="#ga9a8939b5258b070a48aa1e0cd154909a">More...</a><br/></td></tr>
<tr class="separator:ga9a8939b5258b070a48aa1e0cd154909a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c0bc2f0ebff96271f427013fece2a39"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga2c0bc2f0ebff96271f427013fece2a39">svn_stream_skip_fn_t</a> )(void *baton, apr_size_t len)</td></tr>
<tr class="memdesc:ga2c0bc2f0ebff96271f427013fece2a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip data handler function for a generic stream.  <a href="#ga2c0bc2f0ebff96271f427013fece2a39">More...</a><br/></td></tr>
<tr class="separator:ga2c0bc2f0ebff96271f427013fece2a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa79398b116a9209eb3a79947a6066f54"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gaa79398b116a9209eb3a79947a6066f54">svn_write_fn_t</a> )(void *baton, const char *data, apr_size_t *len)</td></tr>
<tr class="memdesc:gaa79398b116a9209eb3a79947a6066f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write handler function for a generic stream.  <a href="#gaa79398b116a9209eb3a79947a6066f54">More...</a><br/></td></tr>
<tr class="separator:gaa79398b116a9209eb3a79947a6066f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga576facc62f51e98c14cb440df1e58cd9"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga576facc62f51e98c14cb440df1e58cd9">svn_close_fn_t</a> )(void *baton)</td></tr>
<tr class="memdesc:ga576facc62f51e98c14cb440df1e58cd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close handler function for a generic stream.  <a href="#ga576facc62f51e98c14cb440df1e58cd9">More...</a><br/></td></tr>
<tr class="separator:ga576facc62f51e98c14cb440df1e58cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca2f3b74a1215c13b5ae2ca3b99437b9"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__svn__io__byte__streams.html#gaca2f3b74a1215c13b5ae2ca3b99437b9">svn_stream_mark_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gaca2f3b74a1215c13b5ae2ca3b99437b9">svn_stream_mark_t</a></td></tr>
<tr class="memdesc:gaca2f3b74a1215c13b5ae2ca3b99437b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque type which represents a mark on a stream.  <a href="#gaca2f3b74a1215c13b5ae2ca3b99437b9">More...</a><br/></td></tr>
<tr class="separator:gaca2f3b74a1215c13b5ae2ca3b99437b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf811477b7cafa3c5c20cb3428976d0be"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gaf811477b7cafa3c5c20cb3428976d0be">svn_stream_mark_fn_t</a> )(void *baton, <a class="el" href="group__svn__io__byte__streams.html#gaca2f3b74a1215c13b5ae2ca3b99437b9">svn_stream_mark_t</a> **mark, apr_pool_t *pool)</td></tr>
<tr class="memdesc:gaf811477b7cafa3c5c20cb3428976d0be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark handler function for a generic stream.  <a href="#gaf811477b7cafa3c5c20cb3428976d0be">More...</a><br/></td></tr>
<tr class="separator:gaf811477b7cafa3c5c20cb3428976d0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5291159cc874084805155ccdfd68b4b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gaa5291159cc874084805155ccdfd68b4b">svn_stream_seek_fn_t</a> )(void *baton, const <a class="el" href="group__svn__io__byte__streams.html#gaca2f3b74a1215c13b5ae2ca3b99437b9">svn_stream_mark_t</a> *mark)</td></tr>
<tr class="memdesc:gaa5291159cc874084805155ccdfd68b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek handler function for a generic stream.  <a href="#gaa5291159cc874084805155ccdfd68b4b">More...</a><br/></td></tr>
<tr class="separator:gaa5291159cc874084805155ccdfd68b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13364f11af5666587fa9fd282812219e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga13364f11af5666587fa9fd282812219e">svn_stream_lazyopen_func_t</a> )(<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **stream, void *baton, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:ga13364f11af5666587fa9fd282812219e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function type provided for use as a callback from <code><a class="el" href="group__svn__io__byte__streams.html#gaf5a36107d7ac577e62a88c3281538304" title="Return a generic stream which wraps another primary stream, delaying the &quot;opening&quot; of that stream unt...">svn_stream_lazyopen_create()</a></code>.  <a href="#ga13364f11af5666587fa9fd282812219e">More...</a><br/></td></tr>
<tr class="separator:ga13364f11af5666587fa9fd282812219e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gadc3e897290c9479c6b903876d18dc87c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gadc3e897290c9479c6b903876d18dc87c">svn_stream_create</a> (void *baton, apr_pool_t *pool)</td></tr>
<tr class="memdesc:gadc3e897290c9479c6b903876d18dc87c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a generic stream.  <a href="#gadc3e897290c9479c6b903876d18dc87c">More...</a><br/></td></tr>
<tr class="separator:gadc3e897290c9479c6b903876d18dc87c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ff601f7fb4a7c8c92770edd7376b052"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0ff601f7fb4a7c8c92770edd7376b052"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga0ff601f7fb4a7c8c92770edd7376b052">svn_stream_set_baton</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, void *baton)</td></tr>
<tr class="memdesc:ga0ff601f7fb4a7c8c92770edd7376b052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>stream's</em> baton to <em>baton</em>. <br/></td></tr>
<tr class="separator:ga0ff601f7fb4a7c8c92770edd7376b052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9ebdcf950b897d9c0cb89c331262aed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae9ebdcf950b897d9c0cb89c331262aed"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gae9ebdcf950b897d9c0cb89c331262aed">svn_stream_set_read</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, <a class="el" href="group__svn__io__byte__streams.html#ga9a8939b5258b070a48aa1e0cd154909a">svn_read_fn_t</a> read_fn)</td></tr>
<tr class="memdesc:gae9ebdcf950b897d9c0cb89c331262aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>stream's</em> read function to <em>read_fn</em>. <br/></td></tr>
<tr class="separator:gae9ebdcf950b897d9c0cb89c331262aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf834f41616e68fa7d0214814a56b81d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gaf834f41616e68fa7d0214814a56b81d4">svn_stream_set_skip</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, <a class="el" href="group__svn__io__byte__streams.html#ga2c0bc2f0ebff96271f427013fece2a39">svn_stream_skip_fn_t</a> skip_fn)</td></tr>
<tr class="memdesc:gaf834f41616e68fa7d0214814a56b81d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>stream's</em> skip function to <em>skip_fn</em>.  <a href="#gaf834f41616e68fa7d0214814a56b81d4">More...</a><br/></td></tr>
<tr class="separator:gaf834f41616e68fa7d0214814a56b81d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea19e182974e64a77d3f949a25f496a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaea19e182974e64a77d3f949a25f496a1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gaea19e182974e64a77d3f949a25f496a1">svn_stream_set_write</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, <a class="el" href="group__svn__io__byte__streams.html#gaa79398b116a9209eb3a79947a6066f54">svn_write_fn_t</a> write_fn)</td></tr>
<tr class="memdesc:gaea19e182974e64a77d3f949a25f496a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>stream's</em> write function to <em>write_fn</em>. <br/></td></tr>
<tr class="separator:gaea19e182974e64a77d3f949a25f496a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga090c93a72964b78a00de75fa10fc5078"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga090c93a72964b78a00de75fa10fc5078"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga090c93a72964b78a00de75fa10fc5078">svn_stream_set_close</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, <a class="el" href="group__svn__io__byte__streams.html#ga576facc62f51e98c14cb440df1e58cd9">svn_close_fn_t</a> close_fn)</td></tr>
<tr class="memdesc:ga090c93a72964b78a00de75fa10fc5078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>stream's</em> close function to <em>close_fn</em>. <br/></td></tr>
<tr class="separator:ga090c93a72964b78a00de75fa10fc5078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdce9efd65576fafecb4df5fd2960d13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gacdce9efd65576fafecb4df5fd2960d13">svn_stream_set_mark</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, <a class="el" href="group__svn__io__byte__streams.html#gaf811477b7cafa3c5c20cb3428976d0be">svn_stream_mark_fn_t</a> mark_fn)</td></tr>
<tr class="memdesc:gacdce9efd65576fafecb4df5fd2960d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>stream's</em> mark function to <em>mark_fn</em>.  <a href="#gacdce9efd65576fafecb4df5fd2960d13">More...</a><br/></td></tr>
<tr class="separator:gacdce9efd65576fafecb4df5fd2960d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96e94eff159f85a3c8c6b7936e5c908d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga96e94eff159f85a3c8c6b7936e5c908d">svn_stream_set_seek</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, <a class="el" href="group__svn__io__byte__streams.html#gaa5291159cc874084805155ccdfd68b4b">svn_stream_seek_fn_t</a> seek_fn)</td></tr>
<tr class="memdesc:ga96e94eff159f85a3c8c6b7936e5c908d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>stream's</em> seek function to <em>seek_fn</em>.  <a href="#ga96e94eff159f85a3c8c6b7936e5c908d">More...</a><br/></td></tr>
<tr class="separator:ga96e94eff159f85a3c8c6b7936e5c908d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f0acad4da18e90c1dc5250643af7049"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga9f0acad4da18e90c1dc5250643af7049">svn_stream_empty</a> (apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga9f0acad4da18e90c1dc5250643af7049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a stream that is empty for reading and infinite for writing.  <a href="#ga9f0acad4da18e90c1dc5250643af7049">More...</a><br/></td></tr>
<tr class="separator:ga9f0acad4da18e90c1dc5250643af7049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61c69116290c1f5e5fedd91ed7bed5ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga61c69116290c1f5e5fedd91ed7bed5ca">svn_stream_disown</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga61c69116290c1f5e5fedd91ed7bed5ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a stream allocated in <em>pool</em> which forwards all requests to <em>stream</em>.  <a href="#ga61c69116290c1f5e5fedd91ed7bed5ca">More...</a><br/></td></tr>
<tr class="separator:ga61c69116290c1f5e5fedd91ed7bed5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d03d151fe2d8fb4068dab914823d059"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga4d03d151fe2d8fb4068dab914823d059">svn_stream_open_readonly</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **stream, const char *path, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:ga4d03d151fe2d8fb4068dab914823d059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a stream to read the file at <em>path</em>.  <a href="#ga4d03d151fe2d8fb4068dab914823d059">More...</a><br/></td></tr>
<tr class="separator:ga4d03d151fe2d8fb4068dab914823d059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace8995769bb736796262450ef90f033e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gace8995769bb736796262450ef90f033e">svn_stream_open_writable</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **stream, const char *path, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:gace8995769bb736796262450ef90f033e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a stream to write a file at <em>path</em>.  <a href="#gace8995769bb736796262450ef90f033e">More...</a><br/></td></tr>
<tr class="separator:gace8995769bb736796262450ef90f033e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga821ab7add7a0216c86b1a7f94456fae9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga821ab7add7a0216c86b1a7f94456fae9">svn_stream_open_unique</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **stream, const char **temp_path, const char *dirpath, <a class="el" href="svn__io_8h.html#aa78fffc81af962281813070c753d7884">svn_io_file_del_t</a> delete_when, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:ga821ab7add7a0216c86b1a7f94456fae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a writable stream to a file in the directory <em>dirpath</em>.  <a href="#ga821ab7add7a0216c86b1a7f94456fae9">More...</a><br/></td></tr>
<tr class="separator:ga821ab7add7a0216c86b1a7f94456fae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf2971328919edf3fed5ef8353a90525"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gadf2971328919edf3fed5ef8353a90525">svn_stream_from_aprfile2</a> (apr_file_t *file, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> disown, apr_pool_t *pool)</td></tr>
<tr class="memdesc:gadf2971328919edf3fed5ef8353a90525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a stream from an APR file.  <a href="#gadf2971328919edf3fed5ef8353a90525">More...</a><br/></td></tr>
<tr class="separator:gadf2971328919edf3fed5ef8353a90525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad12a2e4cbc23bcf8ee3f650966b8c43b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gad12a2e4cbc23bcf8ee3f650966b8c43b">svn_stream_from_aprfile</a> (apr_file_t *file, apr_pool_t *pool)</td></tr>
<tr class="memdesc:gad12a2e4cbc23bcf8ee3f650966b8c43b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="group__svn__io__byte__streams.html#gadf2971328919edf3fed5ef8353a90525" title="Create a stream from an APR file. ">svn_stream_from_aprfile2()</a>, except that the file will always be disowned.  <a href="#gad12a2e4cbc23bcf8ee3f650966b8c43b">More...</a><br/></td></tr>
<tr class="separator:gad12a2e4cbc23bcf8ee3f650966b8c43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e8d5c7ca3a74393f3350540149e8e3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga2e8d5c7ca3a74393f3350540149e8e3d">svn_stream_for_stdin</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **in, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga2e8d5c7ca3a74393f3350540149e8e3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*in</em> to a generic stream connected to stdin, allocated in <em>pool</em>.  <a href="#ga2e8d5c7ca3a74393f3350540149e8e3d">More...</a><br/></td></tr>
<tr class="separator:ga2e8d5c7ca3a74393f3350540149e8e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa76703167b5bc9cc53a1f66e64c5f77a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gaa76703167b5bc9cc53a1f66e64c5f77a">svn_stream_for_stderr</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **err, apr_pool_t *pool)</td></tr>
<tr class="memdesc:gaa76703167b5bc9cc53a1f66e64c5f77a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*err</em> to a generic stream connected to stderr, allocated in <em>pool</em>.  <a href="#gaa76703167b5bc9cc53a1f66e64c5f77a">More...</a><br/></td></tr>
<tr class="separator:gaa76703167b5bc9cc53a1f66e64c5f77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64eca282d3b75b431a6f8ae5a6637fbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga64eca282d3b75b431a6f8ae5a6637fbb">svn_stream_for_stdout</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **out, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga64eca282d3b75b431a6f8ae5a6637fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*out</em> to a generic stream connected to stdout, allocated in <em>pool</em>.  <a href="#ga64eca282d3b75b431a6f8ae5a6637fbb">More...</a><br/></td></tr>
<tr class="separator:ga64eca282d3b75b431a6f8ae5a6637fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe260b52fa278bc63ba75ea695e54303"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gabe260b52fa278bc63ba75ea695e54303">svn_stream_from_stringbuf</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *str, apr_pool_t *pool)</td></tr>
<tr class="memdesc:gabe260b52fa278bc63ba75ea695e54303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a generic stream connected to stringbuf <em>str</em>.  <a href="#gabe260b52fa278bc63ba75ea695e54303">More...</a><br/></td></tr>
<tr class="separator:gabe260b52fa278bc63ba75ea695e54303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e85f7340b0f3471fb79c1bc501e4fea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga8e85f7340b0f3471fb79c1bc501e4fea">svn_stream_from_string</a> (const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *str, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga8e85f7340b0f3471fb79c1bc501e4fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a generic read-only stream connected to string <em>str</em>.  <a href="#ga8e85f7340b0f3471fb79c1bc501e4fea">More...</a><br/></td></tr>
<tr class="separator:ga8e85f7340b0f3471fb79c1bc501e4fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d37c4569b583fd76dde630be6ed68f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga8d37c4569b583fd76dde630be6ed68f7">svn_stream_buffered</a> (apr_pool_t *result_pool)</td></tr>
<tr class="memdesc:ga8d37c4569b583fd76dde630be6ed68f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a generic stream which implements buffered reads and writes.  <a href="#ga8d37c4569b583fd76dde630be6ed68f7">More...</a><br/></td></tr>
<tr class="separator:ga8d37c4569b583fd76dde630be6ed68f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10756ab562fd20d32fb880c859607b4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga10756ab562fd20d32fb880c859607b4c">svn_stream_compressed</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga10756ab562fd20d32fb880c859607b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a stream that decompresses all data read and compresses all data written.  <a href="#ga10756ab562fd20d32fb880c859607b4c">More...</a><br/></td></tr>
<tr class="separator:ga10756ab562fd20d32fb880c859607b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga823456ae87bbacf8b7022e8ea4c0d356"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga823456ae87bbacf8b7022e8ea4c0d356">svn_stream_checksummed2</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, <a class="el" href="structsvn__checksum__t.html">svn_checksum_t</a> **read_checksum, <a class="el" href="structsvn__checksum__t.html">svn_checksum_t</a> **write_checksum, <a class="el" href="svn__checksum_8h.html#a7a6c373d03d7e6ec6b832a039f5e0aa1">svn_checksum_kind_t</a> checksum_kind, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> read_all, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga823456ae87bbacf8b7022e8ea4c0d356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a stream that calculates checksums for all data read and written.  <a href="#ga823456ae87bbacf8b7022e8ea4c0d356">More...</a><br/></td></tr>
<tr class="separator:ga823456ae87bbacf8b7022e8ea4c0d356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadda74c8a8bf6d4dc64488979aa197afc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gadda74c8a8bf6d4dc64488979aa197afc">svn_stream_checksummed</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, const unsigned char **read_digest, const unsigned char **write_digest, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> read_all, apr_pool_t *pool)</td></tr>
<tr class="memdesc:gadda74c8a8bf6d4dc64488979aa197afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="group__svn__io__byte__streams.html#ga823456ae87bbacf8b7022e8ea4c0d356" title="Return a stream that calculates checksums for all data read and written. ">svn_stream_checksummed2()</a>, but always returning the MD5 checksum in <em>read_digest</em> and <em>write_digest</em>.  <a href="#gadda74c8a8bf6d4dc64488979aa197afc">More...</a><br/></td></tr>
<tr class="separator:gadda74c8a8bf6d4dc64488979aa197afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga241e8929f8f7631a629142bd749b25fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga241e8929f8f7631a629142bd749b25fc">svn_stream_read</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, char *buffer, apr_size_t *len)</td></tr>
<tr class="memdesc:ga241e8929f8f7631a629142bd749b25fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from a generic stream.  <a href="#ga241e8929f8f7631a629142bd749b25fc">More...</a><br/></td></tr>
<tr class="separator:ga241e8929f8f7631a629142bd749b25fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga139e177f2f8600c47f01319f12dc5d4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga139e177f2f8600c47f01319f12dc5d4a">svn_stream_skip</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, apr_size_t len)</td></tr>
<tr class="memdesc:ga139e177f2f8600c47f01319f12dc5d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip <em>len</em> bytes from a generic <em>stream</em>.  <a href="#ga139e177f2f8600c47f01319f12dc5d4a">More...</a><br/></td></tr>
<tr class="separator:ga139e177f2f8600c47f01319f12dc5d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0094764a89afdedecac79df9ad1ebccb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga0094764a89afdedecac79df9ad1ebccb">svn_stream_write</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, const char *data, apr_size_t *len)</td></tr>
<tr class="memdesc:ga0094764a89afdedecac79df9ad1ebccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to a generic stream.  <a href="#ga0094764a89afdedecac79df9ad1ebccb">More...</a><br/></td></tr>
<tr class="separator:ga0094764a89afdedecac79df9ad1ebccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d9cdab4d5d8707d59a1b1d3dab95bb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga7d9cdab4d5d8707d59a1b1d3dab95bb4">svn_stream_close</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream)</td></tr>
<tr class="memdesc:ga7d9cdab4d5d8707d59a1b1d3dab95bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a generic stream.  <a href="#ga7d9cdab4d5d8707d59a1b1d3dab95bb4">More...</a><br/></td></tr>
<tr class="separator:ga7d9cdab4d5d8707d59a1b1d3dab95bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7574ccd5c0f60779bdaef7f5b44febd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gac7574ccd5c0f60779bdaef7f5b44febd">svn_stream_reset</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream)</td></tr>
<tr class="memdesc:gac7574ccd5c0f60779bdaef7f5b44febd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset a generic stream back to its origin.  <a href="#gac7574ccd5c0f60779bdaef7f5b44febd">More...</a><br/></td></tr>
<tr class="separator:gac7574ccd5c0f60779bdaef7f5b44febd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5dc6f7105e2332ebda600b2d2300eb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gab5dc6f7105e2332ebda600b2d2300eb7">svn_stream_supports_mark</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream)</td></tr>
<tr class="memdesc:gab5dc6f7105e2332ebda600b2d2300eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>TRUE</code> if the generic <em>stream</em> supports <a class="el" href="group__svn__io__byte__streams.html#ga47c17fbf09effd084d6b426d18175942" title="Set a mark at the current position of a generic stream, which can later be sought back to using svn_s...">svn_stream_mark()</a>.  <a href="#gab5dc6f7105e2332ebda600b2d2300eb7">More...</a><br/></td></tr>
<tr class="separator:gab5dc6f7105e2332ebda600b2d2300eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47c17fbf09effd084d6b426d18175942"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga47c17fbf09effd084d6b426d18175942">svn_stream_mark</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, <a class="el" href="group__svn__io__byte__streams.html#gaca2f3b74a1215c13b5ae2ca3b99437b9">svn_stream_mark_t</a> **mark, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga47c17fbf09effd084d6b426d18175942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a <em>mark</em> at the current position of a generic <em>stream</em>, which can later be sought back to using <a class="el" href="group__svn__io__byte__streams.html#ga1cb32df4e14164a911490bae5e58e99e" title="Seek to a mark in a generic stream. ">svn_stream_seek()</a>.  <a href="#ga47c17fbf09effd084d6b426d18175942">More...</a><br/></td></tr>
<tr class="separator:ga47c17fbf09effd084d6b426d18175942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cb32df4e14164a911490bae5e58e99e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga1cb32df4e14164a911490bae5e58e99e">svn_stream_seek</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, const <a class="el" href="group__svn__io__byte__streams.html#gaca2f3b74a1215c13b5ae2ca3b99437b9">svn_stream_mark_t</a> *mark)</td></tr>
<tr class="memdesc:ga1cb32df4e14164a911490bae5e58e99e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek to a <em>mark</em> in a generic <em>stream</em>.  <a href="#ga1cb32df4e14164a911490bae5e58e99e">More...</a><br/></td></tr>
<tr class="separator:ga1cb32df4e14164a911490bae5e58e99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77fdb810198d9c7832610882fd57546b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga77fdb810198d9c7832610882fd57546b">svn_stream_tee</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *out1, <a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *out2, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga77fdb810198d9c7832610882fd57546b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable stream which, when written to, writes to both of the underlying streams.  <a href="#ga77fdb810198d9c7832610882fd57546b">More...</a><br/></td></tr>
<tr class="separator:ga77fdb810198d9c7832610882fd57546b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4233ad62178dd3379e6d1feee18b5fc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga4233ad62178dd3379e6d1feee18b5fc4">svn_stream_puts</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, const char *str)</td></tr>
<tr class="memdesc:ga4233ad62178dd3379e6d1feee18b5fc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write NULL-terminated string <em>str</em> to <em>stream</em>.  <a href="#ga4233ad62178dd3379e6d1feee18b5fc4">More...</a><br/></td></tr>
<tr class="separator:ga4233ad62178dd3379e6d1feee18b5fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8665c4828daad13a35fd7e670552d888"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8665c4828daad13a35fd7e670552d888"></a>
<a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga8665c4828daad13a35fd7e670552d888">svn_stream_printf</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, apr_pool_t *pool, const char *fmt,...)</td></tr>
<tr class="memdesc:ga8665c4828daad13a35fd7e670552d888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to <em>stream</em> using a printf-style <em>fmt</em> specifier, passed through apr_psprintf() using memory from <em>pool</em>. <br/></td></tr>
<tr class="separator:ga8665c4828daad13a35fd7e670552d888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfb10864df6c3a6fd6e5fc08ae8ef7e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gacfb10864df6c3a6fd6e5fc08ae8ef7e8">svn_stream_printf_from_utf8</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, const char *encoding, apr_pool_t *pool, const char *fmt,...)</td></tr>
<tr class="memdesc:gacfb10864df6c3a6fd6e5fc08ae8ef7e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to <em>stream</em> using a printf-style <em>fmt</em> specifier, passed through apr_psprintf() using memory from <em>pool</em>.  <a href="#gacfb10864df6c3a6fd6e5fc08ae8ef7e8">More...</a><br/></td></tr>
<tr class="separator:gacfb10864df6c3a6fd6e5fc08ae8ef7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccbf1cdff3857cad09096f8f01f37260"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gaccbf1cdff3857cad09096f8f01f37260">svn_stream_readline</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, <a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> **stringbuf, const char *eol, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *eof, apr_pool_t *pool)</td></tr>
<tr class="memdesc:gaccbf1cdff3857cad09096f8f01f37260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate <em>*stringbuf</em> in <em>pool</em>, and read into it one line (terminated by <em>eol</em>) from <em>stream</em>.  <a href="#gaccbf1cdff3857cad09096f8f01f37260">More...</a><br/></td></tr>
<tr class="separator:gaccbf1cdff3857cad09096f8f01f37260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga674a71b48f810dd21ad2db6fd611930d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga674a71b48f810dd21ad2db6fd611930d">svn_stream_copy3</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *from, <a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *to, <a class="el" href="svn__types_8h.html#addaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a> cancel_func, void *cancel_baton, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga674a71b48f810dd21ad2db6fd611930d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the contents of the readable stream <em>from</em> and write them to the writable stream <em>to</em> calling <em>cancel_func</em> before copying each chunk.  <a href="#ga674a71b48f810dd21ad2db6fd611930d">More...</a><br/></td></tr>
<tr class="separator:ga674a71b48f810dd21ad2db6fd611930d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1960de4b4eb0cf1a69a5ba5e11aaa6be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga1960de4b4eb0cf1a69a5ba5e11aaa6be">svn_stream_copy2</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *from, <a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *to, <a class="el" href="svn__types_8h.html#addaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a> cancel_func, void *cancel_baton, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga1960de4b4eb0cf1a69a5ba5e11aaa6be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="group__svn__io__byte__streams.html#ga674a71b48f810dd21ad2db6fd611930d" title="Read the contents of the readable stream from and write them to the writable stream to calling cancel...">svn_stream_copy3()</a> but the streams are not closed.  <a href="#ga1960de4b4eb0cf1a69a5ba5e11aaa6be">More...</a><br/></td></tr>
<tr class="separator:ga1960de4b4eb0cf1a69a5ba5e11aaa6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga444db383401ed714a240ff6ca5ca76b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga444db383401ed714a240ff6ca5ca76b3">svn_stream_copy</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *from, <a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *to, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga444db383401ed714a240ff6ca5ca76b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="group__svn__io__byte__streams.html#ga674a71b48f810dd21ad2db6fd611930d" title="Read the contents of the readable stream from and write them to the writable stream to calling cancel...">svn_stream_copy3()</a>, but without the cancellation function or stream closing.  <a href="#ga444db383401ed714a240ff6ca5ca76b3">More...</a><br/></td></tr>
<tr class="separator:ga444db383401ed714a240ff6ca5ca76b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a84c869ab835792b5e441b5eb426fd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga4a84c869ab835792b5e441b5eb426fd6">svn_stream_contents_same2</a> (<a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *same, <a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream1, <a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream2, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga4a84c869ab835792b5e441b5eb426fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*same</em> to TRUE if <em>stream1</em> and <em>stream2</em> have the same contents, else set it to FALSE.  <a href="#ga4a84c869ab835792b5e441b5eb426fd6">More...</a><br/></td></tr>
<tr class="separator:ga4a84c869ab835792b5e441b5eb426fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14b9375f4e0300888b853650e15a987a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga14b9375f4e0300888b853650e15a987a">svn_stream_contents_same</a> (<a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *same, <a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream1, <a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream2, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga14b9375f4e0300888b853650e15a987a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="group__svn__io__byte__streams.html#ga4a84c869ab835792b5e441b5eb426fd6" title="Set *same to TRUE if stream1 and stream2 have the same contents, else set it to FALSE. ">svn_stream_contents_same2()</a>, but the streams will not be closed.  <a href="#ga14b9375f4e0300888b853650e15a987a">More...</a><br/></td></tr>
<tr class="separator:ga14b9375f4e0300888b853650e15a987a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91b87b96c3f9a302d390263bd0d451a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga91b87b96c3f9a302d390263bd0d451a2">svn_string_from_stream</a> (<a class="el" href="structsvn__string__t.html">svn_string_t</a> **result, <a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:ga91b87b96c3f9a302d390263bd0d451a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the contents of <em>stream</em> into memory, returning the data in <em>result</em>.  <a href="#ga91b87b96c3f9a302d390263bd0d451a2">More...</a><br/></td></tr>
<tr class="separator:ga91b87b96c3f9a302d390263bd0d451a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5a36107d7ac577e62a88c3281538304"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gaf5a36107d7ac577e62a88c3281538304">svn_stream_lazyopen_create</a> (<a class="el" href="group__svn__io__byte__streams.html#ga13364f11af5666587fa9fd282812219e">svn_stream_lazyopen_func_t</a> open_func, void *open_baton, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> open_on_close, apr_pool_t *result_pool)</td></tr>
<tr class="memdesc:gaf5a36107d7ac577e62a88c3281538304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a generic stream which wraps another primary stream, delaying the "opening" of that stream until the first time the returned stream is accessed.  <a href="#gaf5a36107d7ac577e62a88c3281538304">More...</a><br/></td></tr>
<tr class="separator:gaf5a36107d7ac577e62a88c3281538304"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Generic byte-streams. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga576facc62f51e98c14cb440df1e58cd9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* svn_close_fn_t)(void *baton)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close handler function for a generic stream. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af" title="An abstract stream of byteseither incoming or outgoing or both. ">svn_stream_t</a>. </dd></dl>

<p>Definition at line <a class="el" href="svn__io_8h_source.html#l00838">838</a> of file <a class="el" href="svn__io_8h_source.html">svn_io.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga9a8939b5258b070a48aa1e0cd154909a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* svn_read_fn_t)(void *baton, char *buffer, apr_size_t *len)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read handler function for a generic stream. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af" title="An abstract stream of byteseither incoming or outgoing or both. ">svn_stream_t</a>. </dd></dl>

<p>Definition at line <a class="el" href="svn__io_8h_source.html#l00821">821</a> of file <a class="el" href="svn__io_8h_source.html">svn_io.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga13364f11af5666587fa9fd282812219e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* svn_stream_lazyopen_func_t)(<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **stream, void *baton, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function type provided for use as a callback from <code><a class="el" href="group__svn__io__byte__streams.html#gaf5a36107d7ac577e62a88c3281538304" title="Return a generic stream which wraps another primary stream, delaying the &quot;opening&quot; of that stream unt...">svn_stream_lazyopen_create()</a></code>. </p>
<p>The callback function shall open a new stream and set <em>*stream</em> to the stream object, allocated in <em>result_pool</em>. <em>baton</em> is the callback baton that was passed to <a class="el" href="group__svn__io__byte__streams.html#gaf5a36107d7ac577e62a88c3281538304" title="Return a generic stream which wraps another primary stream, delaying the &quot;opening&quot; of that stream unt...">svn_stream_lazyopen_create()</a>.</p>
<p><em>result_pool</em> is the result pool that was passed to <a class="el" href="group__svn__io__byte__streams.html#gaf5a36107d7ac577e62a88c3281538304" title="Return a generic stream which wraps another primary stream, delaying the &quot;opening&quot; of that stream unt...">svn_stream_lazyopen_create()</a>. The callback function may use <em>scratch_pool</em> for temporary allocations; the caller may clear or destroy <em>scratch_pool</em> any time after the function returns.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.8. </dd></dl>

<p>Definition at line <a class="el" href="svn__io_8h_source.html#l01390">1390</a> of file <a class="el" href="svn__io_8h_source.html">svn_io.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaf811477b7cafa3c5c20cb3428976d0be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* svn_stream_mark_fn_t)(void *baton, <a class="el" href="group__svn__io__byte__streams.html#gaca2f3b74a1215c13b5ae2ca3b99437b9">svn_stream_mark_t</a> **mark, apr_pool_t *pool)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark handler function for a generic stream. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af" title="An abstract stream of byteseither incoming or outgoing or both. ">svn_stream_t</a> and <a class="el" href="group__svn__io__byte__streams.html#ga47c17fbf09effd084d6b426d18175942" title="Set a mark at the current position of a generic stream, which can later be sought back to using svn_s...">svn_stream_mark()</a>.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

<p>Definition at line <a class="el" href="svn__io_8h_source.html#l00854">854</a> of file <a class="el" href="svn__io_8h_source.html">svn_io.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaca2f3b74a1215c13b5ae2ca3b99437b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__svn__io__byte__streams.html#gaca2f3b74a1215c13b5ae2ca3b99437b9">svn_stream_mark_t</a> <a class="el" href="group__svn__io__byte__streams.html#gaca2f3b74a1215c13b5ae2ca3b99437b9">svn_stream_mark_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An opaque type which represents a mark on a stream. </p>
<p>There is no concrete definition of this type, it is a named type for stream implementation specific baton pointers.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__svn__io__byte__streams.html#ga47c17fbf09effd084d6b426d18175942" title="Set a mark at the current position of a generic stream, which can later be sought back to using svn_s...">svn_stream_mark()</a>. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

<p>Definition at line <a class="el" href="svn__io_8h_source.html#l00847">847</a> of file <a class="el" href="svn__io_8h_source.html">svn_io.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaa5291159cc874084805155ccdfd68b4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* svn_stream_seek_fn_t)(void *baton, const <a class="el" href="group__svn__io__byte__streams.html#gaca2f3b74a1215c13b5ae2ca3b99437b9">svn_stream_mark_t</a> *mark)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seek handler function for a generic stream. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af" title="An abstract stream of byteseither incoming or outgoing or both. ">svn_stream_t</a> and <a class="el" href="group__svn__io__byte__streams.html#ga1cb32df4e14164a911490bae5e58e99e" title="Seek to a mark in a generic stream. ">svn_stream_seek()</a>.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

<p>Definition at line <a class="el" href="svn__io_8h_source.html#l00863">863</a> of file <a class="el" href="svn__io_8h_source.html">svn_io.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga2c0bc2f0ebff96271f427013fece2a39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* svn_stream_skip_fn_t)(void *baton, apr_size_t len)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Skip data handler function for a generic stream. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af" title="An abstract stream of byteseither incoming or outgoing or both. ">svn_stream_t</a> and <a class="el" href="group__svn__io__byte__streams.html#ga139e177f2f8600c47f01319f12dc5d4a" title="Skip len bytes from a generic stream. ">svn_stream_skip()</a>. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

<p>Definition at line <a class="el" href="svn__io_8h_source.html#l00829">829</a> of file <a class="el" href="svn__io_8h_source.html">svn_io.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga06d6291c397e63f895deb92a2c14e6af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> <a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An abstract stream of bytes&ndash;either incoming or outgoing or both. </p>
<p>The creator of a stream sets functions to handle read and write. Both of these handlers accept a baton whose value is determined at stream creation time; this baton can point to a structure containing data associated with the stream. If a caller attempts to invoke a handler which has not been set, it will generate a runtime assertion failure. The creator can also set a handler for close requests so that it can flush buffered data or whatever; if a close handler is not specified, a close request on the stream will simply be ignored. Note that <a class="el" href="group__svn__io__byte__streams.html#ga7d9cdab4d5d8707d59a1b1d3dab95bb4" title="Close a generic stream. ">svn_stream_close()</a> does not deallocate the memory used to allocate the stream structure; free the pool you created the stream in to free that memory.</p>
<p>The read and write handlers accept length arguments via pointer. On entry to the handler, the pointed-to value should be the amount of data which can be read or the amount of data to write. When the handler returns, the value is reset to the amount of data actually read or written. Handlers are obliged to complete a read or write to the maximum extent possible; thus, a short read with no associated error implies the end of the input stream, and a short write should never occur without an associated error.</p>
<p>In Subversion 1.7 reset support was added as an optional feature of streams. If a stream implements resetting it allows reading the data again after a successful call to <a class="el" href="group__svn__io__byte__streams.html#gac7574ccd5c0f60779bdaef7f5b44febd" title="Reset a generic stream back to its origin. ">svn_stream_reset()</a>. </p>

<p>Definition at line <a class="el" href="svn__io_8h_source.html#l00816">816</a> of file <a class="el" href="svn__io_8h_source.html">svn_io.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaa79398b116a9209eb3a79947a6066f54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* svn_write_fn_t)(void *baton, const char *data, apr_size_t *len)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write handler function for a generic stream. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af" title="An abstract stream of byteseither incoming or outgoing or both. ">svn_stream_t</a>. </dd></dl>

<p>Definition at line <a class="el" href="svn__io_8h_source.html#l00833">833</a> of file <a class="el" href="svn__io_8h_source.html">svn_io.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga8d37c4569b583fd76dde630be6ed68f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>* svn_stream_buffered </td>
          <td>(</td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a generic stream which implements buffered reads and writes. </p>
<p>The stream will preferentially store data in-memory, but may use disk storage as backup if the amount of data is large. Allocate the stream in <em>result_pool</em> </p>
<dl class="section since"><dt>Since</dt><dd>New in 1.8. </dd></dl>

</div>
</div>
<a class="anchor" id="gadda74c8a8bf6d4dc64488979aa197afc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>* svn_stream_checksummed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char **&#160;</td>
          <td class="paramname"><em>read_digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char **&#160;</td>
          <td class="paramname"><em>write_digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>read_all</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="group__svn__io__byte__streams.html#ga823456ae87bbacf8b7022e8ea4c0d356" title="Return a stream that calculates checksums for all data read and written. ">svn_stream_checksummed2()</a>, but always returning the MD5 checksum in <em>read_digest</em> and <em>write_digest</em>. </p>
<dl class="section since"><dt>Since</dt><dd>New in 1.4. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000217">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.5 API. </dd></dl>

</div>
</div>
<a class="anchor" id="ga823456ae87bbacf8b7022e8ea4c0d356"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>* svn_stream_checksummed2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsvn__checksum__t.html">svn_checksum_t</a> **&#160;</td>
          <td class="paramname"><em>read_checksum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsvn__checksum__t.html">svn_checksum_t</a> **&#160;</td>
          <td class="paramname"><em>write_checksum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__checksum_8h.html#a7a6c373d03d7e6ec6b832a039f5e0aa1">svn_checksum_kind_t</a>&#160;</td>
          <td class="paramname"><em>checksum_kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>read_all</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a stream that calculates checksums for all data read and written. </p>
<p>The stream <em>stream</em> is used to read and write all data. The stream and the resulting digests are allocated in <em>pool</em>.</p>
<p>When the stream is closed, <em>*read_checksum</em> and <em>*write_checksum</em> are set to point to the resulting checksums, of type <em>read_checksum_kind</em> and <em>write_checksum_kind</em>, respectively.</p>
<p>Both <em>read_checksum</em> and <em>write_checksum</em> can be <code>NULL</code>, in which case the respective checksum isn't calculated.</p>
<p>If <em>read_all</em> is TRUE, make sure that all data available on <em>stream</em> is read (and checksummed) when the stream is closed.</p>
<p>Read and write operations can be mixed without interfering.</p>
<p>The <em>stream</em> passed into this function is closed when the created stream is closed.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7d9cdab4d5d8707d59a1b1d3dab95bb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a generic stream. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af" title="An abstract stream of byteseither incoming or outgoing or both. ">svn_stream_t</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga10756ab562fd20d32fb880c859607b4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>* svn_stream_compressed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a stream that decompresses all data read and compresses all data written. </p>
<p>The stream <em>stream</em> is used to read and write all compressed data. All compression data structures are allocated on <em>pool</em>. If compression support is not compiled in then <a class="el" href="group__svn__io__byte__streams.html#ga10756ab562fd20d32fb880c859607b4c" title="Return a stream that decompresses all data read and compresses all data written. ">svn_stream_compressed()</a> returns <em>stream</em> unmodified. Make sure you call <a class="el" href="group__svn__io__byte__streams.html#ga7d9cdab4d5d8707d59a1b1d3dab95bb4" title="Close a generic stream. ">svn_stream_close()</a> on the stream returned by this function, so that all data are flushed and cleaned up.</p>
<dl class="section note"><dt>Note</dt><dd>From 1.4, compression support is always compiled in. </dd></dl>

</div>
</div>
<a class="anchor" id="ga14b9375f4e0300888b853650e15a987a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_contents_same </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *&#160;</td>
          <td class="paramname"><em>same</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="group__svn__io__byte__streams.html#ga4a84c869ab835792b5e441b5eb426fd6" title="Set *same to TRUE if stream1 and stream2 have the same contents, else set it to FALSE. ">svn_stream_contents_same2()</a>, but the streams will not be closed. </p>
<dl class="section since"><dt>Since</dt><dd>New in 1.4. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000220">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.6 API. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4a84c869ab835792b5e441b5eb426fd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_contents_same2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *&#160;</td>
          <td class="paramname"><em>same</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>*same</em> to TRUE if <em>stream1</em> and <em>stream2</em> have the same contents, else set it to FALSE. </p>
<p>Both streams will be closed before this function returns (regardless of the result, or any possible error).</p>
<p>Use <em>scratch_pool</em> for temporary allocations.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="ga444db383401ed714a240ff6ca5ca76b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="group__svn__io__byte__streams.html#ga674a71b48f810dd21ad2db6fd611930d" title="Read the contents of the readable stream from and write them to the writable stream to calling cancel...">svn_stream_copy3()</a>, but without the cancellation function or stream closing. </p>
<dl class="section since"><dt>Since</dt><dd>New in 1.1. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000219">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.4 API. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1960de4b4eb0cf1a69a5ba5e11aaa6be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_copy2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#addaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a>&#160;</td>
          <td class="paramname"><em>cancel_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cancel_baton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="group__svn__io__byte__streams.html#ga674a71b48f810dd21ad2db6fd611930d" title="Read the contents of the readable stream from and write them to the writable stream to calling cancel...">svn_stream_copy3()</a> but the streams are not closed. </p>
<dl class="section since"><dt>Since</dt><dd>New in 1.5. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000218">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.5 API. </dd></dl>

</div>
</div>
<a class="anchor" id="ga674a71b48f810dd21ad2db6fd611930d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_copy3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#addaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a>&#160;</td>
          <td class="paramname"><em>cancel_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cancel_baton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the contents of the readable stream <em>from</em> and write them to the writable stream <em>to</em> calling <em>cancel_func</em> before copying each chunk. </p>
<p><em>cancel_func</em> may be <code>NULL</code>.</p>
<dl class="section note"><dt>Note</dt><dd>both <em>from</em> and <em>to</em> will be closed upon successful completion of the copy (but an error may still be returned, based on trying to close the two streams). If the closure is not desired, then you can use <a class="el" href="group__svn__io__byte__streams.html#ga61c69116290c1f5e5fedd91ed7bed5ca" title="Return a stream allocated in pool which forwards all requests to stream. ">svn_stream_disown()</a> to protect either or both of the streams from being closed.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a class="anchor" id="gadc3e897290c9479c6b903876d18dc87c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>* svn_stream_create </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>baton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a generic stream. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af" title="An abstract stream of byteseither incoming or outgoing or both. ">svn_stream_t</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga61c69116290c1f5e5fedd91ed7bed5ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>* svn_stream_disown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a stream allocated in <em>pool</em> which forwards all requests to <em>stream</em>. </p>
<p>Destruction is explicitly excluded from forwarding.</p>
<dl class="section see"><dt>See Also</dt><dd><a href="http://subversion.apache.org/docs/community-guide/conventions.html#destruction-of-stacked-resources">http://subversion.apache.org/docs/community-guide/conventions.html#destruction-of-stacked-resources</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.4. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9f0acad4da18e90c1dc5250643af7049"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>* svn_stream_empty </td>
          <td>(</td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a stream that is empty for reading and infinite for writing. </p>

</div>
</div>
<a class="anchor" id="gaa76703167b5bc9cc53a1f66e64c5f77a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_for_stderr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **&#160;</td>
          <td class="paramname"><em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>*err</em> to a generic stream connected to stderr, allocated in <em>pool</em>. </p>
<p>The stream and its underlying APR handle will be closed when <em>pool</em> is cleared or destroyed.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2e8d5c7ca3a74393f3350540149e8e3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_for_stdin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>*in</em> to a generic stream connected to stdin, allocated in <em>pool</em>. </p>
<p>The stream and its underlying APR handle will be closed when <em>pool</em> is cleared or destroyed.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="ga64eca282d3b75b431a6f8ae5a6637fbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_for_stdout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>*out</em> to a generic stream connected to stdout, allocated in <em>pool</em>. </p>
<p>The stream and its underlying APR handle will be closed when <em>pool</em> is cleared or destroyed. </p>

</div>
</div>
<a class="anchor" id="gad12a2e4cbc23bcf8ee3f650966b8c43b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>* svn_stream_from_aprfile </td>
          <td>(</td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="group__svn__io__byte__streams.html#gadf2971328919edf3fed5ef8353a90525" title="Create a stream from an APR file. ">svn_stream_from_aprfile2()</a>, except that the file will always be disowned. </p>
<dl class="section note"><dt>Note</dt><dd>The stream returned is not considered to "own" the underlying file, meaning that <a class="el" href="group__svn__io__byte__streams.html#ga7d9cdab4d5d8707d59a1b1d3dab95bb4" title="Close a generic stream. ">svn_stream_close()</a> on the stream will not close the file.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000216">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.3 API. </dd></dl>

</div>
</div>
<a class="anchor" id="gadf2971328919edf3fed5ef8353a90525"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>* svn_stream_from_aprfile2 </td>
          <td>(</td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>disown</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a stream from an APR file. </p>
<p>For convenience, if <em>file</em> is <code>NULL</code>, an empty stream created by <a class="el" href="group__svn__io__byte__streams.html#ga9f0acad4da18e90c1dc5250643af7049" title="Create a stream that is empty for reading and infinite for writing. ">svn_stream_empty()</a> is returned.</p>
<p>This function should normally be called with <em>disown</em> set to FALSE, in which case closing the stream will also close the underlying file.</p>
<p>If <em>disown</em> is TRUE, the stream will disown the underlying file, meaning that <a class="el" href="group__svn__io__byte__streams.html#ga7d9cdab4d5d8707d59a1b1d3dab95bb4" title="Close a generic stream. ">svn_stream_close()</a> will not close the file.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.4. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8e85f7340b0f3471fb79c1bc501e4fea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>* svn_stream_from_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a generic read-only stream connected to string <em>str</em>. </p>
<p>Allocate the stream in <em>pool</em>. </p>

</div>
</div>
<a class="anchor" id="gabe260b52fa278bc63ba75ea695e54303"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>* svn_stream_from_stringbuf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a generic stream connected to stringbuf <em>str</em>. </p>
<p>Allocate the stream in <em>pool</em>. </p>

</div>
</div>
<a class="anchor" id="gaf5a36107d7ac577e62a88c3281538304"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>* svn_stream_lazyopen_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga13364f11af5666587fa9fd282812219e">svn_stream_lazyopen_func_t</a>&#160;</td>
          <td class="paramname"><em>open_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>open_baton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>open_on_close</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a generic stream which wraps another primary stream, delaying the "opening" of that stream until the first time the returned stream is accessed. </p>
<p><em>open_func</em> and <em>open_baton</em> are a callback function/baton pair which will be invoked upon the first access of the returned stream (read, write, mark, seek, skip, or possibly close). The callback shall open the primary stream.</p>
<p>If the only "access" the returned stream gets is to close it then <em>open_func</em> will only be called if <em>open_on_close</em> is TRUE.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.8. </dd></dl>

</div>
</div>
<a class="anchor" id="ga47c17fbf09effd084d6b426d18175942"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_mark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#gaca2f3b74a1215c13b5ae2ca3b99437b9">svn_stream_mark_t</a> **&#160;</td>
          <td class="paramname"><em>mark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a <em>mark</em> at the current position of a generic <em>stream</em>, which can later be sought back to using <a class="el" href="group__svn__io__byte__streams.html#ga1cb32df4e14164a911490bae5e58e99e" title="Seek to a mark in a generic stream. ">svn_stream_seek()</a>. </p>
<p>The <em>mark</em> is allocated in <em>pool</em>.</p>
<p>This function returns the <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660a4cb4098e25ea204783c9063a54142098" title="&quot;Stream doesn&#39;t support seeking&quot; ">SVN_ERR_STREAM_SEEK_NOT_SUPPORTED</a> error if the stream doesn't implement seeking.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__svn__io__byte__streams.html#ga1cb32df4e14164a911490bae5e58e99e" title="Seek to a mark in a generic stream. ">svn_stream_seek()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4d03d151fe2d8fb4068dab914823d059"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_open_readonly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a stream to read the file at <em>path</em>. </p>
<p>It will be opened using the APR_BUFFERED and APR_BINARY flag, and APR_OS_DEFAULT for the perms. If you'd like to use different values, then open the file yourself, and use the <a class="el" href="group__svn__io__byte__streams.html#gadf2971328919edf3fed5ef8353a90525" title="Create a stream from an APR file. ">svn_stream_from_aprfile2()</a> interface.</p>
<p>The stream will be returned in <em>stream</em>, and allocated from <em>result_pool</em>. Temporary allocations will be performed in <em>scratch_pool</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6 </dd></dl>

</div>
</div>
<a class="anchor" id="ga821ab7add7a0216c86b1a7f94456fae9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_open_unique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>temp_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dirpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__io_8h.html#aa78fffc81af962281813070c753d7884">svn_io_file_del_t</a>&#160;</td>
          <td class="paramname"><em>delete_when</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a writable stream to a file in the directory <em>dirpath</em>. </p>
<p>The file will have an arbitrary and unique name, and the full path will be returned in <em>temp_path</em>. The stream will be returned in <em>stream</em>. Both will be allocated from <em>result_pool</em>.</p>
<p>If <em>dirpath</em> is <code>NULL</code>, use the path returned from <a class="el" href="svn__io_8h.html#afbb4b86585411439008e934ede6f8b39" title="Set *dir to a directory path (allocated in pool) deemed usable for the creation of temporary files an...">svn_io_temp_dir()</a>. (Note that when using the system-provided temp directory, it may not be possible to atomically rename the resulting file due to cross-device issues.)</p>
<p>The file will be deleted according to <em>delete_when</em>. If that is <a class="el" href="svn__io_8h.html#aa78fffc81af962281813070c753d7884a0f89c57067b563673ea1ec5605c908bd" title="Remove when the associated pool is cleared. ">svn_io_file_del_on_pool_cleanup</a>, it refers to <em>result_pool</em>.</p>
<p>Temporary allocations will be performed in <em>scratch_pool</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6 </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="svn__io_8h.html#ad1a7a7299bfe130c25becdd56ff0e870" title="Create a writable file, with an arbitrary and unique name, in the directory dirpath. ">svn_io_open_unique_file3()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gace8995769bb736796262450ef90f033e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_open_writable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a stream to write a file at <em>path</em>. </p>
<p>The file will be <em>created</em> using the APR_BUFFERED and APR_BINARY flag, and APR_OS_DEFAULT for the perms. The file will be created "exclusively", so if it already exists, then an error will be thrown. If you'd like to use different values, or open an existing file, then open the file yourself, and use the <a class="el" href="group__svn__io__byte__streams.html#gadf2971328919edf3fed5ef8353a90525" title="Create a stream from an APR file. ">svn_stream_from_aprfile2()</a> interface.</p>
<p>The stream will be returned in <em>stream</em>, and allocated from <em>result_pool</em>. Temporary allocations will be performed in <em>scratch_pool</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6 </dd></dl>

</div>
</div>
<a class="anchor" id="gacfb10864df6c3a6fd6e5fc08ae8ef7e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_printf_from_utf8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>encoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write to <em>stream</em> using a printf-style <em>fmt</em> specifier, passed through apr_psprintf() using memory from <em>pool</em>. </p>
<p>The resulting string will be translated to <em>encoding</em> before it is sent to <em>stream</em>.</p>
<dl class="section note"><dt>Note</dt><dd>Use <code>APR_LOCALE_CHARSET</code> to translate to the encoding of the current locale.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.3. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4233ad62178dd3379e6d1feee18b5fc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_puts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write NULL-terminated string <em>str</em> to <em>stream</em>. </p>
<dl class="section since"><dt>Since</dt><dd>New in 1.8. </dd></dl>

</div>
</div>
<a class="anchor" id="ga241e8929f8f7631a629142bd749b25fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read from a generic stream. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af" title="An abstract stream of byteseither incoming or outgoing or both. ">svn_stream_t</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaccbf1cdff3857cad09096f8f01f37260"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_readline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> **&#160;</td>
          <td class="paramname"><em>stringbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>eol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *&#160;</td>
          <td class="paramname"><em>eof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate <em>*stringbuf</em> in <em>pool</em>, and read into it one line (terminated by <em>eol</em>) from <em>stream</em>. </p>
<p>The line-terminator is read from the stream, but is not added to the end of the stringbuf. Instead, the stringbuf ends with a usual '\0'.</p>
<p>If <em>stream</em> runs out of bytes before encountering a line-terminator, then set <em>*eof</em> to <code>TRUE</code>, otherwise set <em>*eof</em> to FALSE. </p>

</div>
</div>
<a class="anchor" id="gac7574ccd5c0f60779bdaef7f5b44febd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset a generic stream back to its origin. </p>
<p>(E.g. On a file this would be implemented as a seek to position 0). This function returns a <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660a4cb4098e25ea204783c9063a54142098" title="&quot;Stream doesn&#39;t support seeking&quot; ">SVN_ERR_STREAM_SEEK_NOT_SUPPORTED</a> error when the stream doesn't implement resetting.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1cb32df4e14164a911490bae5e58e99e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_seek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__svn__io__byte__streams.html#gaca2f3b74a1215c13b5ae2ca3b99437b9">svn_stream_mark_t</a> *&#160;</td>
          <td class="paramname"><em>mark</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seek to a <em>mark</em> in a generic <em>stream</em>. </p>
<p>This function returns the <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660a4cb4098e25ea204783c9063a54142098" title="&quot;Stream doesn&#39;t support seeking&quot; ">SVN_ERR_STREAM_SEEK_NOT_SUPPORTED</a> error if the stream doesn't implement seeking. Passing NULL as <em>mark</em>, seeks to the start of the stream.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__svn__io__byte__streams.html#ga47c17fbf09effd084d6b426d18175942" title="Set a mark at the current position of a generic stream, which can later be sought back to using svn_s...">svn_stream_mark()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="gacdce9efd65576fafecb4df5fd2960d13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_stream_set_mark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#gaf811477b7cafa3c5c20cb3428976d0be">svn_stream_mark_fn_t</a>&#160;</td>
          <td class="paramname"><em>mark_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>stream's</em> mark function to <em>mark_fn</em>. </p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="ga96e94eff159f85a3c8c6b7936e5c908d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_stream_set_seek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#gaa5291159cc874084805155ccdfd68b4b">svn_stream_seek_fn_t</a>&#160;</td>
          <td class="paramname"><em>seek_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>stream's</em> seek function to <em>seek_fn</em>. </p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf834f41616e68fa7d0214814a56b81d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_stream_set_skip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga2c0bc2f0ebff96271f427013fece2a39">svn_stream_skip_fn_t</a>&#160;</td>
          <td class="paramname"><em>skip_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>stream's</em> skip function to <em>skip_fn</em>. </p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7 </dd></dl>

</div>
</div>
<a class="anchor" id="ga139e177f2f8600c47f01319f12dc5d4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_skip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Skip <em>len</em> bytes from a generic <em>stream</em>. </p>
<p>If the stream is exhausted before <em>len</em> bytes have been read, return an error.</p>
<dl class="section note"><dt>Note</dt><dd>No assumption can be made on the semantics of this function other than that the stream read pointer will be advanced by *len bytes. Depending on the capabilities of the underlying stream implementation, this may for instance be translated into a sequence of reads or a simple seek operation. If the stream implementation has not provided a skip function, this will read from the stream and discard the data.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="gab5dc6f7105e2332ebda600b2d2300eb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> svn_stream_supports_mark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>TRUE</code> if the generic <em>stream</em> supports <a class="el" href="group__svn__io__byte__streams.html#ga47c17fbf09effd084d6b426d18175942" title="Set a mark at the current position of a generic stream, which can later be sought back to using svn_s...">svn_stream_mark()</a>. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__svn__io__byte__streams.html#ga47c17fbf09effd084d6b426d18175942" title="Set a mark at the current position of a generic stream, which can later be sought back to using svn_s...">svn_stream_mark()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="ga77fdb810198d9c7832610882fd57546b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>* svn_stream_tee </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>out1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>out2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a writable stream which, when written to, writes to both of the underlying streams. </p>
<p>Both of these streams will be closed upon closure of the returned stream; use <a class="el" href="group__svn__io__byte__streams.html#ga61c69116290c1f5e5fedd91ed7bed5ca" title="Return a stream allocated in pool which forwards all requests to stream. ">svn_stream_disown()</a> if this is not the desired behavior. One or both of <em>out1</em> and <em>out2</em> may be <code>NULL</code>. If both are <code>NULL</code>, <code>NULL</code> is returned.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0094764a89afdedecac79df9ad1ebccb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write to a generic stream. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af" title="An abstract stream of byteseither incoming or outgoing or both. ">svn_stream_t</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga91b87b96c3f9a302d390263bd0d451a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_string_from_stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__string__t.html">svn_string_t</a> **&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the contents of <em>stream</em> into memory, returning the data in <em>result</em>. </p>
<p>The stream will be closed when it has been successfully and completely read.</p>
<p>The returned memory is allocated in <em>result_pool</em>, and any temporary allocations are performed in <em>scratch_pool</em>.</p>
<dl class="section note"><dt>Note</dt><dd>due to memory pseudo-reallocation behavior (due to pools), this can be a memory-intensive operation for large files.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.6 </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Aug 19 2015 09:37:24 for Subversion by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
