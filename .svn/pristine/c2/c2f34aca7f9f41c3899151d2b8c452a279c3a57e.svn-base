<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Subversion: svn_path.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Subversion
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_c37f7789c49aa9e5999234152b1ef6ed.html">subversion</a></li><li class="navelem"><a class="el" href="dir_334478eea8dba5ae935f94af9469978f.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">svn_path.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A path manipulation library.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;apr.h&gt;</code><br/>
<code>#include &lt;apr_pools.h&gt;</code><br/>
<code>#include &lt;apr_tables.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="svn__types_8h_source.html">svn_types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="svn__string_8h_source.html">svn_string.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="svn__dirent__uri_8h_source.html">svn_dirent_uri.h</a>&quot;</code><br/>
</div>
<p><a href="svn__path_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9b002c8492b3f42010ce194bc4fe9674"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#a9b002c8492b3f42010ce194bc4fe9674">svn_path_internal_style</a> (const char *path, apr_pool_t *pool)</td></tr>
<tr class="memdesc:a9b002c8492b3f42010ce194bc4fe9674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <em>path</em> from the local style to the canonical internal style.  <a href="#a9b002c8492b3f42010ce194bc4fe9674">More...</a><br/></td></tr>
<tr class="separator:a9b002c8492b3f42010ce194bc4fe9674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c6078657e62c3fa5a7c27c842f533e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#a12c6078657e62c3fa5a7c27c842f533e">svn_path_local_style</a> (const char *path, apr_pool_t *pool)</td></tr>
<tr class="memdesc:a12c6078657e62c3fa5a7c27c842f533e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <em>path</em> from the canonical internal style to the local style.  <a href="#a12c6078657e62c3fa5a7c27c842f533e">More...</a><br/></td></tr>
<tr class="separator:a12c6078657e62c3fa5a7c27c842f533e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d6c1ad05e2e71d91981b63a313a9d9"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#aa2d6c1ad05e2e71d91981b63a313a9d9">svn_path_join</a> (const char *base, const char *component, apr_pool_t *pool)</td></tr>
<tr class="memdesc:aa2d6c1ad05e2e71d91981b63a313a9d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a base path (<em>base</em>) with a component (<em>component</em>), allocating the result in <em>pool</em>.  <a href="#aa2d6c1ad05e2e71d91981b63a313a9d9">More...</a><br/></td></tr>
<tr class="separator:aa2d6c1ad05e2e71d91981b63a313a9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b124175ae26b1a3b04964cb3b4fce47"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#a8b124175ae26b1a3b04964cb3b4fce47">svn_path_join_many</a> (apr_pool_t *pool, const char *base,...)</td></tr>
<tr class="memdesc:a8b124175ae26b1a3b04964cb3b4fce47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join multiple components onto a <em>base</em> path, allocated in <em>pool</em>.  <a href="#a8b124175ae26b1a3b04964cb3b4fce47">More...</a><br/></td></tr>
<tr class="separator:a8b124175ae26b1a3b04964cb3b4fce47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f92b0550594a647cb1aa2bf459905a0"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#a5f92b0550594a647cb1aa2bf459905a0">svn_path_basename</a> (const char *path, apr_pool_t *pool)</td></tr>
<tr class="memdesc:a5f92b0550594a647cb1aa2bf459905a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the basename of the specified canonicalized <em>path</em>.  <a href="#a5f92b0550594a647cb1aa2bf459905a0">More...</a><br/></td></tr>
<tr class="separator:a5f92b0550594a647cb1aa2bf459905a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b1486db97591805fb513a1c73014c3"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#a27b1486db97591805fb513a1c73014c3">svn_path_dirname</a> (const char *path, apr_pool_t *pool)</td></tr>
<tr class="memdesc:a27b1486db97591805fb513a1c73014c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dirname of the specified canonicalized <em>path</em>, defined as the path with its basename removed.  <a href="#a27b1486db97591805fb513a1c73014c3">More...</a><br/></td></tr>
<tr class="separator:a27b1486db97591805fb513a1c73014c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9213e8c2c819ef1e78376bdeece0610f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#a9213e8c2c819ef1e78376bdeece0610f">svn_path_splitext</a> (const char **path_root, const char **path_ext, const char *path, apr_pool_t *pool)</td></tr>
<tr class="memdesc:a9213e8c2c819ef1e78376bdeece0610f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split <em>path</em> into a root portion and an extension such that the root + the extension = the original path, and where the extension contains no period (.) characters.  <a href="#a9213e8c2c819ef1e78376bdeece0610f">More...</a><br/></td></tr>
<tr class="separator:a9213e8c2c819ef1e78376bdeece0610f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae917e0db36f1e329e210ef3192b4deaf"><td class="memItemLeft" align="right" valign="top">apr_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#ae917e0db36f1e329e210ef3192b4deaf">svn_path_component_count</a> (const char *path)</td></tr>
<tr class="memdesc:ae917e0db36f1e329e210ef3192b4deaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of components in the canonicalized <em>path</em>.  <a href="#ae917e0db36f1e329e210ef3192b4deaf">More...</a><br/></td></tr>
<tr class="separator:ae917e0db36f1e329e210ef3192b4deaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9aa1a5c802b9adaeffdf7cfb742350f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#af9aa1a5c802b9adaeffdf7cfb742350f">svn_path_add_component</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *path, const char *component)</td></tr>
<tr class="memdesc:af9aa1a5c802b9adaeffdf7cfb742350f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a <em>component</em> (a NULL-terminated C-string) to the canonicalized <em>path</em>.  <a href="#af9aa1a5c802b9adaeffdf7cfb742350f">More...</a><br/></td></tr>
<tr class="separator:af9aa1a5c802b9adaeffdf7cfb742350f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cd686d60f29900e6f2400650c9b65d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#aa8cd686d60f29900e6f2400650c9b65d">svn_path_remove_component</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *path)</td></tr>
<tr class="memdesc:aa8cd686d60f29900e6f2400650c9b65d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove one component off the end of the canonicalized <em>path</em>.  <a href="#aa8cd686d60f29900e6f2400650c9b65d">More...</a><br/></td></tr>
<tr class="separator:aa8cd686d60f29900e6f2400650c9b65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeabdc440c35448dc47d540a0fe71a12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#adeabdc440c35448dc47d540a0fe71a12">svn_path_remove_components</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *path, apr_size_t n)</td></tr>
<tr class="memdesc:adeabdc440c35448dc47d540a0fe71a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove <em>n</em> components off the end of the canonicalized <em>path</em>.  <a href="#adeabdc440c35448dc47d540a0fe71a12">More...</a><br/></td></tr>
<tr class="separator:adeabdc440c35448dc47d540a0fe71a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc6d306f3c26daa29a689ce0c8173aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#a0bc6d306f3c26daa29a689ce0c8173aa">svn_path_split</a> (const char *path, const char **dirpath, const char **base_name, apr_pool_t *pool)</td></tr>
<tr class="memdesc:a0bc6d306f3c26daa29a689ce0c8173aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide the canonicalized <em>path</em> into <em>*dirpath</em> and <em>*base_name</em>, allocated in <em>pool</em>.  <a href="#a0bc6d306f3c26daa29a689ce0c8173aa">More...</a><br/></td></tr>
<tr class="separator:a0bc6d306f3c26daa29a689ce0c8173aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86520f916cb63f8923af5aa40f43e091"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86520f916cb63f8923af5aa40f43e091"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#a86520f916cb63f8923af5aa40f43e091">svn_path_is_empty</a> (const char *path)</td></tr>
<tr class="memdesc:a86520f916cb63f8923af5aa40f43e091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return non-zero iff <em>path</em> is empty ("") or represents the current directory &ndash; that is, if prepending it as a component to an existing path would result in no meaningful change. <br/></td></tr>
<tr class="separator:a86520f916cb63f8923af5aa40f43e091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d5716a18e04df175633a65ddac7809"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#a71d5716a18e04df175633a65ddac7809">svn_path_canonicalize</a> (const char *path, apr_pool_t *pool)</td></tr>
<tr class="memdesc:a71d5716a18e04df175633a65ddac7809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new path (or URL) like <em>path</em>, but transformed such that some types of path specification redundancies are removed.  <a href="#a71d5716a18e04df175633a65ddac7809">More...</a><br/></td></tr>
<tr class="separator:a71d5716a18e04df175633a65ddac7809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee225e4d7950ad37dc1d2aad8f8411ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#aee225e4d7950ad37dc1d2aad8f8411ef">svn_path_is_canonical</a> (const char *path, apr_pool_t *pool)</td></tr>
<tr class="memdesc:aee225e4d7950ad37dc1d2aad8f8411ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>TRUE</code> iff path is canonical.  <a href="#aee225e4d7950ad37dc1d2aad8f8411ef">More...</a><br/></td></tr>
<tr class="separator:aee225e4d7950ad37dc1d2aad8f8411ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b511c3c7ba94ab18090effbb5b8714"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#a64b511c3c7ba94ab18090effbb5b8714">svn_path_compare_paths</a> (const char *path1, const char *path2)</td></tr>
<tr class="memdesc:a64b511c3c7ba94ab18090effbb5b8714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an integer greater than, equal to, or less than 0, according as <em>path1</em> is greater than, equal to, or less than <em>path2</em>.  <a href="#a64b511c3c7ba94ab18090effbb5b8714">More...</a><br/></td></tr>
<tr class="separator:a64b511c3c7ba94ab18090effbb5b8714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8d6c6604ebbe04537a5cfe0405138e"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#afc8d6c6604ebbe04537a5cfe0405138e">svn_path_get_longest_ancestor</a> (const char *path1, const char *path2, apr_pool_t *pool)</td></tr>
<tr class="memdesc:afc8d6c6604ebbe04537a5cfe0405138e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the longest common path shared by two canonicalized paths, <em>path1</em> and <em>path2</em>.  <a href="#afc8d6c6604ebbe04537a5cfe0405138e">More...</a><br/></td></tr>
<tr class="separator:afc8d6c6604ebbe04537a5cfe0405138e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad485d86ddbb7f8b07857a4992e243aae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#ad485d86ddbb7f8b07857a4992e243aae">svn_path_get_absolute</a> (const char **pabsolute, const char *relative, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ad485d86ddbb7f8b07857a4992e243aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <em>relative</em> canonicalized path to an absolute path and return the results in <em>*pabsolute</em>, allocated in <em>pool</em>.  <a href="#ad485d86ddbb7f8b07857a4992e243aae">More...</a><br/></td></tr>
<tr class="separator:ad485d86ddbb7f8b07857a4992e243aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116fa3935551000e0ad1a478fdb42057"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#a116fa3935551000e0ad1a478fdb42057">svn_path_split_if_file</a> (const char *path, const char **pdirectory, const char **pfile, apr_pool_t *pool)</td></tr>
<tr class="memdesc:a116fa3935551000e0ad1a478fdb42057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the path part of the canonicalized <em>path</em> in <em>*pdirectory</em>, and the file part in <em>*pfile</em>.  <a href="#a116fa3935551000e0ad1a478fdb42057">More...</a><br/></td></tr>
<tr class="separator:a116fa3935551000e0ad1a478fdb42057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336e77861107b3b14ac3e42c356727ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#a336e77861107b3b14ac3e42c356727ab">svn_path_condense_targets</a> (const char **pcommon, apr_array_header_t **pcondensed_targets, const apr_array_header_t *targets, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> remove_redundancies, apr_pool_t *pool)</td></tr>
<tr class="memdesc:a336e77861107b3b14ac3e42c356727ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the common prefix of the canonicalized paths in <em>targets</em> (an array of <code>const char *</code>'s), and remove redundant paths if <em>remove_redundancies</em> is TRUE.  <a href="#a336e77861107b3b14ac3e42c356727ab">More...</a><br/></td></tr>
<tr class="separator:a336e77861107b3b14ac3e42c356727ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa349ae99101a8be8fec7c2b514e3d8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#afa349ae99101a8be8fec7c2b514e3d8f">svn_path_remove_redundancies</a> (apr_array_header_t **pcondensed_targets, const apr_array_header_t *targets, apr_pool_t *pool)</td></tr>
<tr class="memdesc:afa349ae99101a8be8fec7c2b514e3d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a list of canonicalized <em>targets</em>, one at a time, into <em>pcondensed_targets</em>, omitting any targets that are found earlier in the list, or whose ancestor is found earlier in the list.  <a href="#afa349ae99101a8be8fec7c2b514e3d8f">More...</a><br/></td></tr>
<tr class="separator:afa349ae99101a8be8fec7c2b514e3d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed307c7a409271407b44c6edc50a4313"><td class="memItemLeft" align="right" valign="top">apr_array_header_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#aed307c7a409271407b44c6edc50a4313">svn_path_decompose</a> (const char *path, apr_pool_t *pool)</td></tr>
<tr class="memdesc:aed307c7a409271407b44c6edc50a4313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose the canonicalized <em>path</em> into an array of <code>const char *</code> components, allocated in <em>pool</em>.  <a href="#aed307c7a409271407b44c6edc50a4313">More...</a><br/></td></tr>
<tr class="separator:aed307c7a409271407b44c6edc50a4313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2280945af53502c92180e12cb23365"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#a2c2280945af53502c92180e12cb23365">svn_path_compose</a> (const apr_array_header_t *components, apr_pool_t *pool)</td></tr>
<tr class="memdesc:a2c2280945af53502c92180e12cb23365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join an array of <code>const char *</code> components into a '/' separated path, allocated in <em>pool</em>.  <a href="#a2c2280945af53502c92180e12cb23365">More...</a><br/></td></tr>
<tr class="separator:a2c2280945af53502c92180e12cb23365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fba1793cc2fd35254b86dbfdfd5bd10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#a0fba1793cc2fd35254b86dbfdfd5bd10">svn_path_is_single_path_component</a> (const char *name)</td></tr>
<tr class="memdesc:a0fba1793cc2fd35254b86dbfdfd5bd10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that <em>name</em> is a single path component, that is:  <a href="#a0fba1793cc2fd35254b86dbfdfd5bd10">More...</a><br/></td></tr>
<tr class="separator:a0fba1793cc2fd35254b86dbfdfd5bd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e27f0f689e3cd85f023b43c2a02158d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#a2e27f0f689e3cd85f023b43c2a02158d">svn_path_is_backpath_present</a> (const char *path)</td></tr>
<tr class="memdesc:a2e27f0f689e3cd85f023b43c2a02158d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test to see if a backpath, i.e.  <a href="#a2e27f0f689e3cd85f023b43c2a02158d">More...</a><br/></td></tr>
<tr class="separator:a2e27f0f689e3cd85f023b43c2a02158d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71d1b797d1a3f22577ed1f2136c9e80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#ab71d1b797d1a3f22577ed1f2136c9e80">svn_path_is_dotpath_present</a> (const char *path)</td></tr>
<tr class="memdesc:ab71d1b797d1a3f22577ed1f2136c9e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test to see if a dotpath, i.e.  <a href="#ab71d1b797d1a3f22577ed1f2136c9e80">More...</a><br/></td></tr>
<tr class="separator:ab71d1b797d1a3f22577ed1f2136c9e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723fa9b91b516a3f4057877396f17c85"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#a723fa9b91b516a3f4057877396f17c85">svn_path_is_child</a> (const char *path1, const char *path2, apr_pool_t *pool)</td></tr>
<tr class="memdesc:a723fa9b91b516a3f4057877396f17c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if <em>path2</em> is a child of <em>path1</em>.  <a href="#a723fa9b91b516a3f4057877396f17c85">More...</a><br/></td></tr>
<tr class="separator:a723fa9b91b516a3f4057877396f17c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f82e432465ad05ea28dcb9ab3d231e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#aa3f82e432465ad05ea28dcb9ab3d231e">svn_path_is_ancestor</a> (const char *path1, const char *path2)</td></tr>
<tr class="memdesc:aa3f82e432465ad05ea28dcb9ab3d231e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return TRUE if <em>path1</em> is an ancestor of <em>path2</em> or the paths are equal and FALSE otherwise.  <a href="#aa3f82e432465ad05ea28dcb9ab3d231e">More...</a><br/></td></tr>
<tr class="separator:aa3f82e432465ad05ea28dcb9ab3d231e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66126b95ddaa72ad601b2262c6cd2f6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#a66126b95ddaa72ad601b2262c6cd2f6c">svn_path_check_valid</a> (const char *path, apr_pool_t *pool)</td></tr>
<tr class="memdesc:a66126b95ddaa72ad601b2262c6cd2f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether <em>path</em> is a valid Subversion path.  <a href="#a66126b95ddaa72ad601b2262c6cd2f6c">More...</a><br/></td></tr>
<tr class="separator:a66126b95ddaa72ad601b2262c6cd2f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc3807ba2b493fcbfcf21d783ea916c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__path__uri__stuff.html#gadc3807ba2b493fcbfcf21d783ea916c0">svn_path_is_url</a> (const char *path)</td></tr>
<tr class="memdesc:gadc3807ba2b493fcbfcf21d783ea916c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return TRUE iff <em>path</em> looks like a valid absolute URL.  <a href="group__svn__path__uri__stuff.html#gadc3807ba2b493fcbfcf21d783ea916c0">More...</a><br/></td></tr>
<tr class="separator:gadc3807ba2b493fcbfcf21d783ea916c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cf332a76cc511b00ef847b9b59633ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__path__uri__stuff.html#ga4cf332a76cc511b00ef847b9b59633ee">svn_path_is_uri_safe</a> (const char *path)</td></tr>
<tr class="memdesc:ga4cf332a76cc511b00ef847b9b59633ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>TRUE</code> iff <em>path</em> is URI-safe, <code>FALSE</code> otherwise.  <a href="group__svn__path__uri__stuff.html#ga4cf332a76cc511b00ef847b9b59633ee">More...</a><br/></td></tr>
<tr class="separator:ga4cf332a76cc511b00ef847b9b59633ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f2ce01ef7e239a37baad42b40d556e5"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__path__uri__stuff.html#ga1f2ce01ef7e239a37baad42b40d556e5">svn_path_uri_encode</a> (const char *path, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga1f2ce01ef7e239a37baad42b40d556e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a URI-encoded copy of <em>path</em>, allocated in <em>pool</em>.  <a href="group__svn__path__uri__stuff.html#ga1f2ce01ef7e239a37baad42b40d556e5">More...</a><br/></td></tr>
<tr class="separator:ga1f2ce01ef7e239a37baad42b40d556e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7cd4fc1524784c72709fd55f1d79c88"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__path__uri__stuff.html#gae7cd4fc1524784c72709fd55f1d79c88">svn_path_uri_decode</a> (const char *path, apr_pool_t *pool)</td></tr>
<tr class="memdesc:gae7cd4fc1524784c72709fd55f1d79c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a URI-decoded copy of <em>path</em>, allocated in <em>pool</em>.  <a href="group__svn__path__uri__stuff.html#gae7cd4fc1524784c72709fd55f1d79c88">More...</a><br/></td></tr>
<tr class="separator:gae7cd4fc1524784c72709fd55f1d79c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73c12d675f3769a1a5edf57d1641be2c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__path__uri__stuff.html#ga73c12d675f3769a1a5edf57d1641be2c">svn_path_url_add_component2</a> (const char *url, const char *component, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga73c12d675f3769a1a5edf57d1641be2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend <em>url</em> by <em>component</em>, URI-encoding that <em>component</em> before adding it to the <em>url</em>; return the new <em>url</em>, allocated in <em>pool</em>.  <a href="group__svn__path__uri__stuff.html#ga73c12d675f3769a1a5edf57d1641be2c">More...</a><br/></td></tr>
<tr class="separator:ga73c12d675f3769a1a5edf57d1641be2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1522f308378a4a74c3d53565f627145f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__path__uri__stuff.html#ga1522f308378a4a74c3d53565f627145f">svn_path_url_add_component</a> (const char *url, const char *component, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga1522f308378a4a74c3d53565f627145f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="group__svn__path__uri__stuff.html#ga73c12d675f3769a1a5edf57d1641be2c" title="Extend url by component, URI-encoding that component before adding it to the url; return the new url...">svn_path_url_add_component2()</a>, but allows path components that end with a trailing '/'.  <a href="group__svn__path__uri__stuff.html#ga1522f308378a4a74c3d53565f627145f">More...</a><br/></td></tr>
<tr class="separator:ga1522f308378a4a74c3d53565f627145f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c2ae9dba439035b284799fd1f5f1395"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__path__uri__stuff.html#ga4c2ae9dba439035b284799fd1f5f1395">svn_path_uri_from_iri</a> (const char *iri, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga4c2ae9dba439035b284799fd1f5f1395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <em>iri</em> (Internationalized URI) to an URI.  <a href="group__svn__path__uri__stuff.html#ga4c2ae9dba439035b284799fd1f5f1395">More...</a><br/></td></tr>
<tr class="separator:ga4c2ae9dba439035b284799fd1f5f1395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd52658595e60c5b6a7d989e8f92ecef"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__path__uri__stuff.html#gacd52658595e60c5b6a7d989e8f92ecef">svn_path_uri_autoescape</a> (const char *uri, apr_pool_t *pool)</td></tr>
<tr class="memdesc:gacd52658595e60c5b6a7d989e8f92ecef"><td class="mdescLeft">&#160;</td><td class="mdescRight">URI-encode certain characters in <em>uri</em> that are not valid in an URI, but doesn't have any special meaning in <em>uri</em> at their positions.  <a href="group__svn__path__uri__stuff.html#gacd52658595e60c5b6a7d989e8f92ecef">More...</a><br/></td></tr>
<tr class="separator:gacd52658595e60c5b6a7d989e8f92ecef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1188b3d68c589e2ef820d785627813e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__path__charset__stuff.html#ga1188b3d68c589e2ef820d785627813e3">svn_path_cstring_from_utf8</a> (const char **path_apr, const char *path_utf8, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga1188b3d68c589e2ef820d785627813e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <em>path_utf8</em> from UTF-8 to the internal encoding used by APR.  <a href="group__svn__path__charset__stuff.html#ga1188b3d68c589e2ef820d785627813e3">More...</a><br/></td></tr>
<tr class="separator:ga1188b3d68c589e2ef820d785627813e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga624b2bd834e1dcbd4d7c05b348f5e5f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__path__charset__stuff.html#ga624b2bd834e1dcbd4d7c05b348f5e5f6">svn_path_cstring_to_utf8</a> (const char **path_utf8, const char *path_apr, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga624b2bd834e1dcbd4d7c05b348f5e5f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <em>path_apr</em> from the internal encoding used by APR to UTF-8.  <a href="group__svn__path__charset__stuff.html#ga624b2bd834e1dcbd4d7c05b348f5e5f6">More...</a><br/></td></tr>
<tr class="separator:ga624b2bd834e1dcbd4d7c05b348f5e5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga727fce68b9b2006cd5b7f77912be3299"><td class="memItemLeft" align="right" valign="top"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__path__repos__relative__urls.html#ga727fce68b9b2006cd5b7f77912be3299">svn_path_is_repos_relative_url</a> (const char *path)</td></tr>
<tr class="memdesc:ga727fce68b9b2006cd5b7f77912be3299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>TRUE</code> iff <em>path</em> is a repository-relative URL: specifically that it starts with the characters "^/".  <a href="group__svn__path__repos__relative__urls.html#ga727fce68b9b2006cd5b7f77912be3299">More...</a><br/></td></tr>
<tr class="separator:ga727fce68b9b2006cd5b7f77912be3299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3e5fa50ecb293ab8757dbe79445f835"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__path__repos__relative__urls.html#gae3e5fa50ecb293ab8757dbe79445f835">svn_path_resolve_repos_relative_url</a> (const char **absolute_url, const char *relative_url, const char *repos_root_url, apr_pool_t *pool)</td></tr>
<tr class="memdesc:gae3e5fa50ecb293ab8757dbe79445f835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>absolute_url</em> to the absolute URL represented by <em>relative_url</em> relative to <em>repos_root_url</em>, preserving any peg revision specifier present in <em>relative_url</em>.  <a href="group__svn__path__repos__relative__urls.html#gae3e5fa50ecb293ab8757dbe79445f835">More...</a><br/></td></tr>
<tr class="separator:gae3e5fa50ecb293ab8757dbe79445f835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8678fa9b36a5725f20acd5d371f7c18"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac8678fa9b36a5725f20acd5d371f7c18"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>svn_path_illegal_path_escape</b> (const char *path, apr_pool_t *pool)</td></tr>
<tr class="separator:gac8678fa9b36a5725f20acd5d371f7c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A path manipulation library. </p>
<p>All incoming and outgoing paths are non-NULL and in UTF-8, unless otherwise documented.</p>
<p>No result path ever ends with a separator, no matter whether the path is a file or directory, because we always canonicalize() it.</p>
<p>Nearly all the <code>svn_path_xxx</code> functions expect paths passed into them to be in canonical form as defined by the Subversion path library itself. The only functions which do <em>not</em> have such expectations are:</p>
<ul>
<li><code><a class="el" href="svn__path_8h.html#a71d5716a18e04df175633a65ddac7809" title="Return a new path (or URL) like path, but transformed such that some types of path specification redu...">svn_path_canonicalize()</a></code> </li>
<li><code><a class="el" href="svn__path_8h.html#aee225e4d7950ad37dc1d2aad8f8411ef" title="Return TRUE iff path is canonical. ">svn_path_is_canonical()</a></code> </li>
<li><code><a class="el" href="svn__path_8h.html#a9b002c8492b3f42010ce194bc4fe9674" title="Convert path from the local style to the canonical internal style. ">svn_path_internal_style()</a></code> </li>
<li><code><a class="el" href="group__svn__path__uri__stuff.html#ga1f2ce01ef7e239a37baad42b40d556e5" title="Return a URI-encoded copy of path, allocated in pool. ">svn_path_uri_encode()</a></code> </li>
</ul>
<p>For the most part, we mean what most anyone would mean when talking about canonical paths, but to be on the safe side, you must run your paths through <code><a class="el" href="svn__path_8h.html#a71d5716a18e04df175633a65ddac7809" title="Return a new path (or URL) like path, but transformed such that some types of path specification redu...">svn_path_canonicalize()</a></code> before passing them to other functions in this API. </p>

<p>Definition in file <a class="el" href="svn__path_8h_source.html">svn_path.h</a>.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="af9aa1a5c802b9adaeffdf7cfb742350f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_path_add_component </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a <em>component</em> (a NULL-terminated C-string) to the canonicalized <em>path</em>. </p>
<p><em>component</em> is allowed to contain directory separators.</p>
<p>If <em>path</em> is non-empty, append the appropriate directory separator character, and then <em>component</em>. If <em>path</em> is empty, simply set it to <em>component</em>; don't add any separator character.</p>
<p>If the result ends in a separator character, then remove the separator. </p>

</div>
</div>
<a class="anchor" id="a5f92b0550594a647cb1aa2bf459905a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* svn_path_basename </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the basename of the specified canonicalized <em>path</em>. </p>
<p>The basename is defined as the last component of the path (ignoring any trailing slashes). If the <em>path</em> is root ("/"), then that is returned. Otherwise, the returned value will have no slashes in it.</p>
<p>Example: svn_path_basename("/foo/bar") -&gt; "bar"</p>
<p>The returned basename will be allocated in <em>pool</em>.</p>
<dl class="section note"><dt>Note</dt><dd>If an empty string is passed, then an empty string will be returned.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000265">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.6 API. New code should use <a class="el" href="svn__dirent__uri_8h.html#abd1989277bd046113f5a4a04eea47969" title="Gets the name of the specified canonicalized dirent as it is known within its parent directory...">svn_dirent_basename()</a>, <a class="el" href="svn__dirent__uri_8h.html#aaff6a95bb7cb4b01f509a3a20068203b" title="Get the (URI-decoded) basename of the specified canonicalized uri. ">svn_uri_basename()</a>, <a class="el" href="svn__dirent__uri_8h.html#a87096512213d2540a40f62c66f52f4c5" title="Get the basename of the specified canonicalized relpath. ">svn_relpath_basename()</a> or svn_fspath__basename(). </dd></dl>

</div>
</div>
<a class="anchor" id="a71d5716a18e04df175633a65ddac7809"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* svn_path_canonicalize </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new path (or URL) like <em>path</em>, but transformed such that some types of path specification redundancies are removed. </p>
<p>This involves collapsing redundant "/./" elements, removing multiple adjacent separator characters, removing trailing separator characters, and possibly other semantically inoperative transformations.</p>
<p>Convert the scheme and hostname to lowercase (see issue #2475)</p>
<p>The returned path may be statically allocated, equal to <em>path</em>, or allocated from <em>pool</em>.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000268">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.6 API. New code should use <a class="el" href="svn__dirent__uri_8h.html#a43bc9669a9cd5c241aacd3e120134154" title="Return a new dirent like dirent, but transformed such that some types of dirent specification redunda...">svn_dirent_canonicalize()</a>, <a class="el" href="svn__dirent__uri_8h.html#a624e026e7bdd426d063435b87db2b103" title="Return a new uri like uri, but transformed such that some types of uri specification redundancies are...">svn_uri_canonicalize()</a>, <a class="el" href="svn__dirent__uri_8h.html#a6fd34d4c169df9722f03dd6e499a07ea" title="Return a new relpath like relpath, but transformed such that some types of relpath specification redu...">svn_relpath_canonicalize()</a> or svn_fspath__canonicalize(). </dd></dl>

</div>
</div>
<a class="anchor" id="a66126b95ddaa72ad601b2262c6cd2f6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_path_check_valid </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether <em>path</em> is a valid Subversion path. </p>
<p>A valid Subversion pathname is a UTF-8 string without control characters. "Valid" means Subversion can store the pathname in a repository. There may be other, OS-specific, limitations on what paths can be represented in a working copy.</p>
<p>ASSUMPTION: <em>path</em> is a valid UTF-8 string. This function does not check UTF-8 validity.</p>
<p>Return <code>SVN_NO_ERROR</code> if valid and <code>SVN_ERR_FS_PATH_SYNTAX</code> if invalid.</p>
<dl class="section note"><dt>Note</dt><dd>Despite returning an <code>SVN_ERR_FS_*</code> error, this function has nothing to do with the versioned filesystem's concept of validity.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.2. </dd></dl>

</div>
</div>
<a class="anchor" id="a64b511c3c7ba94ab18090effbb5b8714"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int svn_path_compare_paths </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an integer greater than, equal to, or less than 0, according as <em>path1</em> is greater than, equal to, or less than <em>path2</em>. </p>
<p>This function works like strcmp() except that it orders children in subdirectories directly after their parents. This allows using the given ordering for a depth first walk. </p>

</div>
</div>
<a class="anchor" id="ae917e0db36f1e329e210ef3192b4deaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_size_t svn_path_component_count </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of components in the canonicalized <em>path</em>. </p>
<dl class="section since"><dt>Since</dt><dd>New in 1.1. </dd></dl>

</div>
</div>
<a class="anchor" id="a2c2280945af53502c92180e12cb23365"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* svn_path_compose </td>
          <td>(</td>
          <td class="paramtype">const apr_array_header_t *&#160;</td>
          <td class="paramname"><em>components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join an array of <code>const char *</code> components into a '/' separated path, allocated in <em>pool</em>. </p>
<p>The joined path is absolute if the first component is a lone dir separator.</p>
<p>Calling <a class="el" href="svn__path_8h.html#a2c2280945af53502c92180e12cb23365" title="Join an array of const char * components into a &#39;/&#39; separated path, allocated in pool. ">svn_path_compose()</a> on the output of <a class="el" href="svn__path_8h.html#aed307c7a409271407b44c6edc50a4313" title="Decompose the canonicalized path into an array of const char * components, allocated in pool...">svn_path_decompose()</a> will return the exact same path.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="a336e77861107b3b14ac3e42c356727ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_path_condense_targets </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>pcommon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_array_header_t **&#160;</td>
          <td class="paramname"><em>pcondensed_targets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const apr_array_header_t *&#160;</td>
          <td class="paramname"><em>targets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>remove_redundancies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the common prefix of the canonicalized paths in <em>targets</em> (an array of <code>const char *</code>'s), and remove redundant paths if <em>remove_redundancies</em> is TRUE. </p>
<ul>
<li>Set <em>*pcommon</em> to the absolute path of the path or URL common to all of the targets. If the targets have no common prefix, or are a mix of URLs and local paths, set <em>*pcommon</em> to the empty string.</li>
<li>If <em>pcondensed_targets</em> is non-NULL, set <em>*pcondensed_targets</em> to an array of targets relative to <em>*pcommon</em>, and if <em>remove_redundancies</em> is TRUE, omit any paths/URLs that are descendants of another path/URL in <em>targets</em>. If *pcommon is empty, <em>*pcondensed_targets</em> will contain full URLs and/or absolute paths; redundancies can still be removed (from both URLs and paths). If <em>pcondensed_targets</em> is NULL, leave it alone.</li>
</ul>
<p>Else if there is exactly one target, then</p>
<ul>
<li>Set <em>*pcommon</em> to that target, and</li>
<li>If <em>pcondensed_targets</em> is non-NULL, set <em>*pcondensed_targets</em> to an array containing zero elements. Else if <em>pcondensed_targets</em> is NULL, leave it alone.</li>
</ul>
<p>If there are no items in <em>targets</em>, set <em>*pcommon</em> and (if applicable) <em>*pcondensed_targets</em> to <code>NULL</code>.</p>
<dl class="section note"><dt>Note</dt><dd>There is no guarantee that <em>*pcommon</em> is within a working copy.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000273">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.6 API. New code should use <a class="el" href="svn__dirent__uri_8h.html#a8f44342f4caf7ad7abd74ab1a0c9c213" title="Find the common prefix of the canonicalized dirents in targets (an array of const char *&#39;s)...">svn_dirent_condense_targets()</a> or <a class="el" href="svn__dirent__uri_8h.html#a1b41445fe57a14f5866d6c040536f931" title="Find the common prefix of the canonicalized uris in targets (an array of const char *&#39;s)...">svn_uri_condense_targets()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aed307c7a409271407b44c6edc50a4313"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_array_header_t* svn_path_decompose </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decompose the canonicalized <em>path</em> into an array of <code>const char *</code> components, allocated in <em>pool</em>. </p>
<p>If <em>path</em> is absolute, the first component will be a lone dir separator (the root directory). </p>

</div>
</div>
<a class="anchor" id="a27b1486db97591805fb513a1c73014c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* svn_path_dirname </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the dirname of the specified canonicalized <em>path</em>, defined as the path with its basename removed. </p>
<p>If <em>path</em> is root ("/"), it is returned unchanged.</p>
<p>The returned dirname will be allocated in <em>pool</em>.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000266">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.6 API. New code should use <a class="el" href="svn__dirent__uri_8h.html#a6642420c9f437098834a4f7151aa3332" title="Get the dirname of the specified canonicalized dirent, defined as the dirent with its basename remove...">svn_dirent_dirname()</a>, <a class="el" href="svn__dirent__uri_8h.html#a6afeca29c5c55e1dafb6640d89505533" title="Get the dirname of the specified canonicalized uri, defined as the uri with its basename removed...">svn_uri_dirname()</a>, <a class="el" href="svn__dirent__uri_8h.html#ab66fa16ca5787b158939e9e8e9f171cc" title="Get the dirname of the specified canonicalized relpath, defined as the relpath with its basename remo...">svn_relpath_dirname()</a> or svn_fspath__dirname(). </dd></dl>

</div>
</div>
<a class="anchor" id="ad485d86ddbb7f8b07857a4992e243aae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_path_get_absolute </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>pabsolute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>relative</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert <em>relative</em> canonicalized path to an absolute path and return the results in <em>*pabsolute</em>, allocated in <em>pool</em>. </p>
<p><em>relative</em> may be a URL, in which case no attempt is made to convert it, and a copy of the URL is returned.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000271">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.6 API. New code should use <a class="el" href="svn__dirent__uri_8h.html#af2c00a9fd200c14f8768a01e9ffbecf1" title="Convert relative canonicalized dirent to an absolute dirent and return the results in *pabsolute...">svn_dirent_get_absolute()</a> on a non-URL input. </dd></dl>

</div>
</div>
<a class="anchor" id="afc8d6c6604ebbe04537a5cfe0405138e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* svn_path_get_longest_ancestor </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the longest common path shared by two canonicalized paths, <em>path1</em> and <em>path2</em>. </p>
<p>If there's no common ancestor, return the empty path.</p>
<p><em>path1</em> and <em>path2</em> may be URLs. In order for two URLs to have a common ancestor, they must (a) have the same protocol (since two URLs with the same path but different protocols may point at completely different resources), and (b) share a common ancestor in their path component, i.e. 'protocol://' is not a sufficient ancestor.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000270">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.6 API. New code should use <a class="el" href="svn__dirent__uri_8h.html#a53391740b3d8664cb3865f210821b659" title="Return the longest common dirent shared by two canonicalized dirents, dirent1 and dirent2...">svn_dirent_get_longest_ancestor()</a>, <a class="el" href="svn__dirent__uri_8h.html#a223335146fbf57d59114466bf686132d" title="Return the longest common path shared by two canonicalized uris, uri1 and uri2. ">svn_uri_get_longest_ancestor()</a>, <a class="el" href="svn__dirent__uri_8h.html#ae8480880f4d8de50c24baf434f076b83" title="Return the longest common path shared by two relative paths, relpath1 and relpath2. ">svn_relpath_get_longest_ancestor()</a> or svn_fspath__get_longest_ancestor(). </dd></dl>

</div>
</div>
<a class="anchor" id="a9b002c8492b3f42010ce194bc4fe9674"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* svn_path_internal_style </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert <em>path</em> from the local style to the canonical internal style. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000261">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.6 API. New code should use <a class="el" href="svn__dirent__uri_8h.html#a675354133cf6e25d3e1cbe6a0f7069e9" title="Convert dirent from the local style to the canonical internal style. ">svn_dirent_internal_style()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aa3f82e432465ad05ea28dcb9ab3d231e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> svn_path_is_ancestor </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return TRUE if <em>path1</em> is an ancestor of <em>path2</em> or the paths are equal and FALSE otherwise. </p>
<dl class="section since"><dt>Since</dt><dd>New in 1.3.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000275">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.6 API. For replacement functionality, see <a class="el" href="svn__dirent__uri_8h.html#a43120221527224b1e161e70f6608f746" title="Return the relative path part of child_dirent that is below parent_dirent, or just &quot;&quot; if parent_diren...">svn_dirent_skip_ancestor()</a>, <a class="el" href="svn__dirent__uri_8h.html#a2f060989ec00f710dce15f9668c5d6db" title="Return the URI-decoded relative path of child_uri that is below parent_uri, or just &quot;&quot; if parent_uri ...">svn_uri_skip_ancestor()</a>, and <a class="el" href="svn__dirent__uri_8h.html#a38f246ac90c84c2d2ad68f9a473d2b46" title="Return the relative path part of child_relpath that is below parent_relpath, or just &quot;&quot; if parent_rel...">svn_relpath_skip_ancestor()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a2e27f0f689e3cd85f023b43c2a02158d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> svn_path_is_backpath_present </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test to see if a backpath, i.e. </p>
<p>'..', is present in <em>path</em>. If not, return <code>FALSE</code>. If so, return <code>TRUE</code>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.1. </dd></dl>

</div>
</div>
<a class="anchor" id="aee225e4d7950ad37dc1d2aad8f8411ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> svn_path_is_canonical </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>TRUE</code> iff path is canonical. </p>
<p>Use <em>pool</em> for temporary allocations.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.5. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000269">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.6 API. New code should use <a class="el" href="svn__dirent__uri_8h.html#a401b8232b2fe7173cb62f2fbdf06c56e" title="Return TRUE iff dirent is canonical. ">svn_dirent_is_canonical()</a>, <a class="el" href="svn__dirent__uri_8h.html#a82bfff97a7826720fdb864edd96d8012" title="Return TRUE iff uri is canonical. ">svn_uri_is_canonical()</a>, <a class="el" href="svn__dirent__uri_8h.html#ac552be30e9f2c8a500d1685be8898f2f" title="Return TRUE iff relpath is canonical. ">svn_relpath_is_canonical()</a> or svn_fspath__is_canonical(). </dd></dl>

</div>
</div>
<a class="anchor" id="a723fa9b91b516a3f4057877396f17c85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* svn_path_is_child </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if <em>path2</em> is a child of <em>path1</em>. </p>
<p>If not, return <code>NULL</code>. If so, return a copy of the remainder path, allocated in <em>pool</em>. (The remainder is the component which, added to <em>path1</em>, yields <em>path2</em>. The remainder does not begin with a dir separator.)</p>
<p>Both paths must be in canonical form, and must either be absolute, or contain no ".." components.</p>
<p>If <em>path2</em> is the same as <em>path1</em>, it is not considered a child, so the result is <code>NULL</code>; an empty string is never returned.</p>
<dl class="section note"><dt>Note</dt><dd>In 1.5 this function has been extended to allow a <code>NULL</code> <em>pool</em> in which case a pointer into <em>path2</em> will be returned to identify the remainder path.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000274">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.6 API. For replacement functionality, see <a class="el" href="svn__dirent__uri_8h.html#a43120221527224b1e161e70f6608f746" title="Return the relative path part of child_dirent that is below parent_dirent, or just &quot;&quot; if parent_diren...">svn_dirent_skip_ancestor()</a>, <a class="el" href="svn__dirent__uri_8h.html#af12399fefc5245c9b729d0a2f4fbe981" title="Similar to svn_dirent_skip_ancestor(), except that if child_dirent is the same as parent_dirent...">svn_dirent_is_child()</a>, <a class="el" href="svn__dirent__uri_8h.html#a2f060989ec00f710dce15f9668c5d6db" title="Return the URI-decoded relative path of child_uri that is below parent_uri, or just &quot;&quot; if parent_uri ...">svn_uri_skip_ancestor()</a>, and <a class="el" href="svn__dirent__uri_8h.html#a38f246ac90c84c2d2ad68f9a473d2b46" title="Return the relative path part of child_relpath that is below parent_relpath, or just &quot;&quot; if parent_rel...">svn_relpath_skip_ancestor()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ab71d1b797d1a3f22577ed1f2136c9e80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> svn_path_is_dotpath_present </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test to see if a dotpath, i.e. </p>
<p>'.', is present in <em>path</em>. If not, return <code>FALSE</code>. If so, return <code>TRUE</code>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a class="anchor" id="a0fba1793cc2fd35254b86dbfdfd5bd10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> svn_path_is_single_path_component </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test that <em>name</em> is a single path component, that is: </p>
<ul>
<li>not <code>NULL</code> or empty.</li>
<li>not a `/'-separated directory path</li>
<li>not empty or `..' </li>
</ul>

</div>
</div>
<a class="anchor" id="aa2d6c1ad05e2e71d91981b63a313a9d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* svn_path_join </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join a base path (<em>base</em>) with a component (<em>component</em>), allocating the result in <em>pool</em>. </p>
<p><em>component</em> need not be a single component: it can be any path, absolute or relative to <em>base</em>.</p>
<p>If either <em>base</em> or <em>component</em> is the empty path, then the other argument will be copied and returned. If both are the empty path the empty path is returned.</p>
<p>If the <em>component</em> is an absolute path, then it is copied and returned. Exactly one slash character ('/') is used to join the components, accounting for any trailing slash in <em>base</em>.</p>
<p>Note that the contents of <em>base</em> are not examined, so it is possible to use this function for constructing URLs, or for relative URLs or repository paths.</p>
<p>This function is NOT appropriate for native (local) file paths. Only for "internal" canonicalized paths, since it uses '/' for the separator. Further, an absolute path (for <em>component</em>) is based on a leading '/' character. Thus, an "absolute URI" for the <em>component</em> won't be detected. An absolute URI can only be used for the base.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000263">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.6 API. New code should use <a class="el" href="svn__dirent__uri_8h.html#aa0ad2bf82642cff7d65c8310868be834" title="Join a base dirent (base) with a component (component). ">svn_dirent_join()</a>, <a class="el" href="svn__dirent__uri_8h.html#a8ea93c789655a35d683bf3b2e29d626c" title="Join a base relpath (base) with a component (component). ">svn_relpath_join()</a> or svn_fspath__join(). </dd></dl>

</div>
</div>
<a class="anchor" id="a8b124175ae26b1a3b04964cb3b4fce47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* svn_path_join_many </td>
          <td>(</td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join multiple components onto a <em>base</em> path, allocated in <em>pool</em>. </p>
<p>The components are terminated by a <code>NULL</code>.</p>
<p>If any component is the empty string, it will be ignored.</p>
<p>If any component is an absolute path, then it resets the base and further components will be appended to it.</p>
<p>This function does not support URLs.</p>
<p>See <a class="el" href="svn__path_8h.html#aa2d6c1ad05e2e71d91981b63a313a9d9" title="Join a base path (base) with a component (component), allocating the result in pool. ">svn_path_join()</a> for further notes about joining paths.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000264">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.6 API. For new code, consider using <a class="el" href="svn__dirent__uri_8h.html#a9cc91f8e99a171e7ec4becffdc023901" title="Join multiple components onto a base dirent. ">svn_dirent_join_many()</a> or a sequence of calls to one of the *_join() functions. </dd></dl>

</div>
</div>
<a class="anchor" id="a12c6078657e62c3fa5a7c27c842f533e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* svn_path_local_style </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert <em>path</em> from the canonical internal style to the local style. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000262">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.6 API. New code should use <a class="el" href="svn__dirent__uri_8h.html#ace26b3b96a2cb6e56fed9a7a288d2b20" title="Convert dirent from the internal style to the local style. ">svn_dirent_local_style()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aa8cd686d60f29900e6f2400650c9b65d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_path_remove_component </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove one component off the end of the canonicalized <em>path</em>. </p>

</div>
</div>
<a class="anchor" id="adeabdc440c35448dc47d540a0fe71a12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_path_remove_components </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove <em>n</em> components off the end of the canonicalized <em>path</em>. </p>
<p>Equivalent to calling <a class="el" href="svn__path_8h.html#aa8cd686d60f29900e6f2400650c9b65d" title="Remove one component off the end of the canonicalized path. ">svn_path_remove_component()</a> <em>n</em> times.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.1. </dd></dl>

</div>
</div>
<a class="anchor" id="afa349ae99101a8be8fec7c2b514e3d8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_path_remove_redundancies </td>
          <td>(</td>
          <td class="paramtype">apr_array_header_t **&#160;</td>
          <td class="paramname"><em>pcondensed_targets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const apr_array_header_t *&#160;</td>
          <td class="paramname"><em>targets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a list of canonicalized <em>targets</em>, one at a time, into <em>pcondensed_targets</em>, omitting any targets that are found earlier in the list, or whose ancestor is found earlier in the list. </p>
<p>Ordering of targets in the original list is preserved in the condensed list of targets. Use <em>pool</em> for any allocations.</p>
<p>How does this differ in functionality from <a class="el" href="svn__path_8h.html#a336e77861107b3b14ac3e42c356727ab" title="Find the common prefix of the canonicalized paths in targets (an array of const char *&#39;s)...">svn_path_condense_targets()</a>?</p>
<p>Here's the short version:</p>
<ol type="1">
<li>Disclaimer: if you wish to debate the following, talk to Karl. :-) Order matters for updates because a multi-arg update is not atomic, and CVS users are used to, when doing 'cvs up targetA targetB' seeing targetA get updated, then targetB. I think the idea is that if you're in a time-sensitive or flaky-network situation, a user can say, "I really <em>need</em> to update wc/A/D/G/tau, but I might as well update my whole working copy if I can." So that user will do 'svn up wc/A/D/G/tau wc', and if something dies in the middles of the 'wc' update, at least the user has 'tau' up-to-date.</li>
<li>Also, we have this notion of an anchor and a target for updates (the anchor is where the update editor is rooted, the target is the actual thing we want to update). I needed a function that would NOT screw with my input paths so that I could tell the difference between someone being in A/D and saying 'svn up G' and being in A/D/G and saying 'svn up .' &ndash; believe it or not, these two things don't mean the same thing. <a class="el" href="svn__path_8h.html#a336e77861107b3b14ac3e42c356727ab" title="Find the common prefix of the canonicalized paths in targets (an array of const char *&#39;s)...">svn_path_condense_targets()</a> plays with absolute paths (which is fine, so does <a class="el" href="svn__path_8h.html#afa349ae99101a8be8fec7c2b514e3d8f" title="Copy a list of canonicalized targets, one at a time, into pcondensed_targets, omitting any targets th...">svn_path_remove_redundancies()</a>), but the difference is that it actually tweaks those targets to be relative to the "grandfather
    path" common to all the targets. Updates don't require a "grandfather path" at all, and even if it did, the whole conversion to an absolute path drops the crucial difference between saying "i'm in foo, update bar" and "i'm in foo/bar,
    update '.'" </li>
</ol>

</div>
</div>
<a class="anchor" id="a0bc6d306f3c26daa29a689ce0c8173aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_path_split </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>dirpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>base_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divide the canonicalized <em>path</em> into <em>*dirpath</em> and <em>*base_name</em>, allocated in <em>pool</em>. </p>
<p>If <em>dirpath</em> or <em>base_name</em> is NULL, then don't set that one.</p>
<p>Either <em>dirpath</em> or <em>base_name</em> may be <em>path's</em> own address, but they may not both be the same address, or the results are undefined.</p>
<p>If <em>path</em> has two or more components, the separator between <em>dirpath</em> and <em>base_name</em> is not included in either of the new names.</p>
<p>examples:</p>
<ul>
<li><pre>"/foo/bar/baz"  ==&gt;  "/foo/bar" and "baz"</pre></li>
<li><pre>"/bar"          ==&gt;  "/"  and "bar"</pre></li>
<li><pre>"/"             ==&gt;  "/"  and "/"</pre></li>
<li><pre>"X:/"           ==&gt;  "X:/" and "X:/"</pre></li>
<li><pre>"bar"           ==&gt;  ""   and "bar"</pre></li>
<li><pre>""              ==&gt;  ""   and ""</pre></li>
</ul>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000267">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.6 API. New code should use <a class="el" href="svn__dirent__uri_8h.html#aa953a9310560da25358de9ef3621545c" title="Divide the canonicalized dirent into *dirpath and *base_name. ">svn_dirent_split()</a>, <a class="el" href="svn__dirent__uri_8h.html#a1738f95947423b71ec6b304cbfaf5417" title="Divide the canonicalized uri into a uri *dirpath and a (URI-decoded) relpath *base_name. ">svn_uri_split()</a>, <a class="el" href="svn__dirent__uri_8h.html#ae785b4fb4290096d50a2dc9323a97aa4" title="Divide the canonicalized relpath into *dirpath and *base_name. ">svn_relpath_split()</a> or svn_fspath__split(). </dd></dl>

</div>
</div>
<a class="anchor" id="a116fa3935551000e0ad1a478fdb42057"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_path_split_if_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>pdirectory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>pfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the path part of the canonicalized <em>path</em> in <em>*pdirectory</em>, and the file part in <em>*pfile</em>. </p>
<p>If <em>path</em> is a directory, set <em>*pdirectory</em> to <em>path</em>, and <em>*pfile</em> to the empty string. If <em>path</em> does not exist it is treated as if it is a file, since directories do not normally vanish.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000272">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.6 API. New code should implement the required logic directly; no direct replacement is provided. </dd></dl>

</div>
</div>
<a class="anchor" id="a9213e8c2c819ef1e78376bdeece0610f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_path_splitext </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>path_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>path_ext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split <em>path</em> into a root portion and an extension such that the root + the extension = the original path, and where the extension contains no period (.) characters. </p>
<p>If not <code>NULL</code>, set <em>*path_root</em> to the root portion. If not <code>NULL</code>, set <em>*path_ext</em> to the extension (or "" if there is no extension found). Allocate both <em>*path_root</em> and <em>*path_ext</em> in <em>pool</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.5. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Aug 19 2015 09:37:23 for Subversion by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
