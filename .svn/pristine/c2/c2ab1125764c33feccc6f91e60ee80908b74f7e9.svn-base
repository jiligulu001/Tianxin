<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Subversion: svn_stringbuf_t functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Subversion
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">svn_stringbuf_t functions<div class="ingroups"><a class="el" href="group__svn__string.html">String handling</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8601f093a616a8e02037dc8e8a90f91a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8601f093a616a8e02037dc8e8a90f91a"></a>
<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__string__svn__stringbuf__t.html#ga8601f093a616a8e02037dc8e8a90f91a">svn_stringbuf_create</a> (const char *cstring, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga8601f093a616a8e02037dc8e8a90f91a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new stringbuf copied from the null-terminated C string <em>cstring</em>. <br/></td></tr>
<tr class="separator:ga8601f093a616a8e02037dc8e8a90f91a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52aff4fcf51690403e493bb35ac87991"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__string__svn__stringbuf__t.html#ga52aff4fcf51690403e493bb35ac87991">svn_stringbuf_ncreate</a> (const char *bytes, apr_size_t size, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga52aff4fcf51690403e493bb35ac87991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new stringbuf copied from the generic string of bytes, <em>bytes</em>, of length <em>size</em> bytes.  <a href="#ga52aff4fcf51690403e493bb35ac87991">More...</a><br/></td></tr>
<tr class="separator:ga52aff4fcf51690403e493bb35ac87991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69de2af20dc203f258335dfc475cf1ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__string__svn__stringbuf__t.html#ga69de2af20dc203f258335dfc475cf1ad">svn_stringbuf_create_empty</a> (apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga69de2af20dc203f258335dfc475cf1ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new, empty stringbuf.  <a href="#ga69de2af20dc203f258335dfc475cf1ad">More...</a><br/></td></tr>
<tr class="separator:ga69de2af20dc203f258335dfc475cf1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75ce9fc03e6382cd7a259042834355b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__string__svn__stringbuf__t.html#ga75ce9fc03e6382cd7a259042834355b3">svn_stringbuf_create_ensure</a> (apr_size_t minimum_size, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga75ce9fc03e6382cd7a259042834355b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new, empty stringbuf with at least <em>minimum_size</em> bytes of space available in the memory block.  <a href="#ga75ce9fc03e6382cd7a259042834355b3">More...</a><br/></td></tr>
<tr class="separator:ga75ce9fc03e6382cd7a259042834355b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7d76a0ae1245b7695b290b91cda4947"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa7d76a0ae1245b7695b290b91cda4947"></a>
<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__string__svn__stringbuf__t.html#gaa7d76a0ae1245b7695b290b91cda4947">svn_stringbuf_create_from_string</a> (const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *str, apr_pool_t *pool)</td></tr>
<tr class="memdesc:gaa7d76a0ae1245b7695b290b91cda4947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new stringbuf copied from the string <em>str</em>. <br/></td></tr>
<tr class="separator:gaa7d76a0ae1245b7695b290b91cda4947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9593514bf4b6f220d498a1bcad1cb63f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__string__svn__stringbuf__t.html#ga9593514bf4b6f220d498a1bcad1cb63f">svn_stringbuf_create_wrap</a> (char *str, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga9593514bf4b6f220d498a1bcad1cb63f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new stringbuf using the given <em>str</em> as initial buffer.  <a href="#ga9593514bf4b6f220d498a1bcad1cb63f">More...</a><br/></td></tr>
<tr class="separator:ga9593514bf4b6f220d498a1bcad1cb63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebc36db5adf759c66508d23e3cb195c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> <br class="typebreak"/>
*<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__string__svn__stringbuf__t.html#gaebc36db5adf759c66508d23e3cb195c2">svn_stringbuf_ensure</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *str, apr_size_t minimum_size)</td></tr>
<tr class="memdesc:gaebc36db5adf759c66508d23e3cb195c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new stringbuf by printf-style formatting using <em>fmt</em> and the variable arguments, which are as appropriate for apr_psprintf().  <a href="#gaebc36db5adf759c66508d23e3cb195c2">More...</a><br/></td></tr>
<tr class="separator:gaebc36db5adf759c66508d23e3cb195c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga026d3c9d0850c9b3131dcb37400de532"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__string__svn__stringbuf__t.html#ga026d3c9d0850c9b3131dcb37400de532">svn_stringbuf_set</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *str, const char *value)</td></tr>
<tr class="memdesc:ga026d3c9d0850c9b3131dcb37400de532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>str</em> to a copy of the null-terminated C string <em>value</em>.  <a href="#ga026d3c9d0850c9b3131dcb37400de532">More...</a><br/></td></tr>
<tr class="separator:ga026d3c9d0850c9b3131dcb37400de532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab83a676f045b8661689f04a59e0efce9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__string__svn__stringbuf__t.html#gab83a676f045b8661689f04a59e0efce9">svn_stringbuf_setempty</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *str)</td></tr>
<tr class="memdesc:gab83a676f045b8661689f04a59e0efce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>str</em> to empty (zero length).  <a href="#gab83a676f045b8661689f04a59e0efce9">More...</a><br/></td></tr>
<tr class="separator:gab83a676f045b8661689f04a59e0efce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40f3e623c857983b4b56e603431a00fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__string__svn__stringbuf__t.html#ga40f3e623c857983b4b56e603431a00fa">svn_stringbuf_isempty</a> (const <a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *str)</td></tr>
<tr class="memdesc:ga40f3e623c857983b4b56e603431a00fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>TRUE</code> if <em>str</em> is empty (has length zero).  <a href="#ga40f3e623c857983b4b56e603431a00fa">More...</a><br/></td></tr>
<tr class="separator:ga40f3e623c857983b4b56e603431a00fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49dc0be31e13c8264575723cf4695c68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__string__svn__stringbuf__t.html#ga49dc0be31e13c8264575723cf4695c68">svn_stringbuf_chop</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *str, apr_size_t nbytes)</td></tr>
<tr class="memdesc:ga49dc0be31e13c8264575723cf4695c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chop <em>nbytes</em> bytes off end of <em>str</em>, but not more than <em>str-&gt;len</em>.  <a href="#ga49dc0be31e13c8264575723cf4695c68">More...</a><br/></td></tr>
<tr class="separator:ga49dc0be31e13c8264575723cf4695c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4373bb2fae064fb648344f49f24fc96c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__string__svn__stringbuf__t.html#ga4373bb2fae064fb648344f49f24fc96c">svn_stringbuf_fillchar</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *str, unsigned char c)</td></tr>
<tr class="memdesc:ga4373bb2fae064fb648344f49f24fc96c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill <em>str</em> with character <em>c</em>.  <a href="#ga4373bb2fae064fb648344f49f24fc96c">More...</a><br/></td></tr>
<tr class="separator:ga4373bb2fae064fb648344f49f24fc96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac364c08a63485f28ee5b3ee99e941f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__string__svn__stringbuf__t.html#gaac364c08a63485f28ee5b3ee99e941f4">svn_stringbuf_appendbyte</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *targetstr, char byte)</td></tr>
<tr class="memdesc:gaac364c08a63485f28ee5b3ee99e941f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the single character <em>byte</em> onto <em>targetstr</em>.  <a href="#gaac364c08a63485f28ee5b3ee99e941f4">More...</a><br/></td></tr>
<tr class="separator:gaac364c08a63485f28ee5b3ee99e941f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c60f08eaa9f01d244072291f4cf42d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__string__svn__stringbuf__t.html#ga1c60f08eaa9f01d244072291f4cf42d0">svn_stringbuf_appendbytes</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *targetstr, const char *bytes, apr_size_t count)</td></tr>
<tr class="memdesc:ga1c60f08eaa9f01d244072291f4cf42d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the array of bytes <em>bytes</em> of length <em>count</em> onto <em>targetstr</em>.  <a href="#ga1c60f08eaa9f01d244072291f4cf42d0">More...</a><br/></td></tr>
<tr class="separator:ga1c60f08eaa9f01d244072291f4cf42d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cc195ace8501ac3f8748a5a9f23ece7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__string__svn__stringbuf__t.html#ga5cc195ace8501ac3f8748a5a9f23ece7">svn_stringbuf_appendfill</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *targetstr, char byte, apr_size_t count)</td></tr>
<tr class="memdesc:ga5cc195ace8501ac3f8748a5a9f23ece7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append <em>byte</em> <em>count</em> times onto <em>targetstr</em>.  <a href="#ga5cc195ace8501ac3f8748a5a9f23ece7">More...</a><br/></td></tr>
<tr class="separator:ga5cc195ace8501ac3f8748a5a9f23ece7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga670edcdb88bcbfc421f06b58683a5efb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__string__svn__stringbuf__t.html#ga670edcdb88bcbfc421f06b58683a5efb">svn_stringbuf_appendstr</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *targetstr, const <a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *appendstr)</td></tr>
<tr class="memdesc:ga670edcdb88bcbfc421f06b58683a5efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the stringbuf <code>appendstr</code> onto <em>targetstr</em>.  <a href="#ga670edcdb88bcbfc421f06b58683a5efb">More...</a><br/></td></tr>
<tr class="separator:ga670edcdb88bcbfc421f06b58683a5efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21e883d584131b35082f23d27fe877ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__string__svn__stringbuf__t.html#ga21e883d584131b35082f23d27fe877ea">svn_stringbuf_appendcstr</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *targetstr, const char *cstr)</td></tr>
<tr class="memdesc:ga21e883d584131b35082f23d27fe877ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the C string <em>cstr</em> onto <em>targetstr</em>.  <a href="#ga21e883d584131b35082f23d27fe877ea">More...</a><br/></td></tr>
<tr class="separator:ga21e883d584131b35082f23d27fe877ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59fe19732799703addf0c20a7f45133f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__string__svn__stringbuf__t.html#ga59fe19732799703addf0c20a7f45133f">svn_stringbuf_insert</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *str, apr_size_t pos, const char *bytes, apr_size_t count)</td></tr>
<tr class="memdesc:ga59fe19732799703addf0c20a7f45133f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert into <em>str</em> at position <em>pos</em> an array of bytes <em>bytes</em> which is <em>count</em> bytes long.  <a href="#ga59fe19732799703addf0c20a7f45133f">More...</a><br/></td></tr>
<tr class="separator:ga59fe19732799703addf0c20a7f45133f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95328e1824649b300eff3b3f9b07f85f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__string__svn__stringbuf__t.html#ga95328e1824649b300eff3b3f9b07f85f">svn_stringbuf_remove</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *str, apr_size_t pos, apr_size_t count)</td></tr>
<tr class="memdesc:ga95328e1824649b300eff3b3f9b07f85f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove <em>count</em> bytes from <em>str</em>, starting at position <em>pos</em>.  <a href="#ga95328e1824649b300eff3b3f9b07f85f">More...</a><br/></td></tr>
<tr class="separator:ga95328e1824649b300eff3b3f9b07f85f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaceb4e369123b0bc333d0bf3014fb9d51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__string__svn__stringbuf__t.html#gaceb4e369123b0bc333d0bf3014fb9d51">svn_stringbuf_replace</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *str, apr_size_t pos, apr_size_t old_count, const char *bytes, apr_size_t new_count)</td></tr>
<tr class="memdesc:gaceb4e369123b0bc333d0bf3014fb9d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace in <em>str</em> the substring which starts at <em>pos</em> and is <em>old_count</em> bytes long with a new substring <em>bytes</em> which is <em>new_count</em> bytes long.  <a href="#gaceb4e369123b0bc333d0bf3014fb9d51">More...</a><br/></td></tr>
<tr class="separator:gaceb4e369123b0bc333d0bf3014fb9d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad96ee402d1430439779f7e19159ecd78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__string__svn__stringbuf__t.html#gad96ee402d1430439779f7e19159ecd78">svn_stringbuf_dup</a> (const <a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *original_string, apr_pool_t *pool)</td></tr>
<tr class="memdesc:gad96ee402d1430439779f7e19159ecd78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a duplicate of <em>original_string</em>.  <a href="#gad96ee402d1430439779f7e19159ecd78">More...</a><br/></td></tr>
<tr class="separator:gad96ee402d1430439779f7e19159ecd78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58bf192fb1bab3755a3cb9699ab472c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__string__svn__stringbuf__t.html#ga58bf192fb1bab3755a3cb9699ab472c4">svn_stringbuf_compare</a> (const <a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *str1, const <a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *str2)</td></tr>
<tr class="memdesc:ga58bf192fb1bab3755a3cb9699ab472c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>TRUE</code> iff <em>str1</em> and <em>str2</em> have identical length and data.  <a href="#ga58bf192fb1bab3755a3cb9699ab472c4">More...</a><br/></td></tr>
<tr class="separator:ga58bf192fb1bab3755a3cb9699ab472c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fc22d2b21e2e8d4bcd1d71f3ed662e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4fc22d2b21e2e8d4bcd1d71f3ed662e8"></a>
apr_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__string__svn__stringbuf__t.html#ga4fc22d2b21e2e8d4bcd1d71f3ed662e8">svn_stringbuf_first_non_whitespace</a> (const <a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *str)</td></tr>
<tr class="memdesc:ga4fc22d2b21e2e8d4bcd1d71f3ed662e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return offset of first non-whitespace character in <em>str</em>, or return <em>str-&gt;len</em> if none. <br/></td></tr>
<tr class="separator:ga4fc22d2b21e2e8d4bcd1d71f3ed662e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6509ce58676a3f404250ea8653034a20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__string__svn__stringbuf__t.html#ga6509ce58676a3f404250ea8653034a20">svn_stringbuf_strip_whitespace</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *str)</td></tr>
<tr class="memdesc:ga6509ce58676a3f404250ea8653034a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strip whitespace from both sides of <em>str</em> (modified in place).  <a href="#ga6509ce58676a3f404250ea8653034a20">More...</a><br/></td></tr>
<tr class="separator:ga6509ce58676a3f404250ea8653034a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa277b724082d592ac403a3c14a1f8636"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa277b724082d592ac403a3c14a1f8636"></a>
apr_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__string__svn__stringbuf__t.html#gaa277b724082d592ac403a3c14a1f8636">svn_stringbuf_find_char_backward</a> (const <a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *str, char ch)</td></tr>
<tr class="memdesc:gaa277b724082d592ac403a3c14a1f8636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return position of last occurrence of <em>ch</em> in <em>str</em>, or return <em>str-&gt;len</em> if no occurrence. <br/></td></tr>
<tr class="separator:gaa277b724082d592ac403a3c14a1f8636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fd0407b0fd66e903255e2b8ad61a9cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__string__svn__stringbuf__t.html#ga7fd0407b0fd66e903255e2b8ad61a9cc">svn_string_compare_stringbuf</a> (const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *str1, const <a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *str2)</td></tr>
<tr class="memdesc:ga7fd0407b0fd66e903255e2b8ad61a9cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>TRUE</code> iff <em>str1</em> and <em>str2</em> have identical length and data.  <a href="#ga7fd0407b0fd66e903255e2b8ad61a9cc">More...</a><br/></td></tr>
<tr class="separator:ga7fd0407b0fd66e903255e2b8ad61a9cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga7fd0407b0fd66e903255e2b8ad61a9cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> svn_string_compare_stringbuf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>TRUE</code> iff <em>str1</em> and <em>str2</em> have identical length and data. </p>

</div>
</div>
<a class="anchor" id="gaac364c08a63485f28ee5b3ee99e941f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_stringbuf_appendbyte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&#160;</td>
          <td class="paramname"><em>targetstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>byte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append the single character <em>byte</em> onto <em>targetstr</em>. </p>
<p>This is an optimized version of <a class="el" href="group__svn__string__svn__stringbuf__t.html#ga1c60f08eaa9f01d244072291f4cf42d0" title="Append the array of bytes bytes of length count onto targetstr. ">svn_stringbuf_appendbytes()</a> that is much faster to call and execute. Gains vary with the ABI. The advantages extend beyond the actual call because the reduced register pressure allows for more optimization within the caller.</p>
<p>Reallocs if necessary. <em>targetstr</em> is affected, nothing else is. </p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1c60f08eaa9f01d244072291f4cf42d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_stringbuf_appendbytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&#160;</td>
          <td class="paramname"><em>targetstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append the array of bytes <em>bytes</em> of length <em>count</em> onto <em>targetstr</em>. </p>
<p>Reallocs if necessary. <em>targetstr</em> is affected, nothing else is.</p>
<dl class="section since"><dt>Since</dt><dd>1.9 <em>bytes</em> can be NULL if <em>count</em> is zero. </dd></dl>

</div>
</div>
<a class="anchor" id="ga21e883d584131b35082f23d27fe877ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_stringbuf_appendcstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&#160;</td>
          <td class="paramname"><em>targetstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cstr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append the C string <em>cstr</em> onto <em>targetstr</em>. </p>
<p>Reallocs if necessary. <em>targetstr</em> is affected, nothing else is. </p>

</div>
</div>
<a class="anchor" id="ga5cc195ace8501ac3f8748a5a9f23ece7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_stringbuf_appendfill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&#160;</td>
          <td class="paramname"><em>targetstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>byte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append <em>byte</em> <em>count</em> times onto <em>targetstr</em>. </p>
<p>Reallocs if necessary. <em>targetstr</em> is affected, nothing else is. </p>
<dl class="section since"><dt>Since</dt><dd>New in 1.9. </dd></dl>

</div>
</div>
<a class="anchor" id="ga670edcdb88bcbfc421f06b58683a5efb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_stringbuf_appendstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&#160;</td>
          <td class="paramname"><em>targetstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&#160;</td>
          <td class="paramname"><em>appendstr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append the stringbuf <code>appendstr</code> onto <em>targetstr</em>. </p>
<p>Reallocs if necessary. <em>targetstr</em> is affected, nothing else is. </p>

</div>
</div>
<a class="anchor" id="ga49dc0be31e13c8264575723cf4695c68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_stringbuf_chop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>nbytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chop <em>nbytes</em> bytes off end of <em>str</em>, but not more than <em>str-&gt;len</em>. </p>

</div>
</div>
<a class="anchor" id="ga58bf192fb1bab3755a3cb9699ab472c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> svn_stringbuf_compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>TRUE</code> iff <em>str1</em> and <em>str2</em> have identical length and data. </p>

</div>
</div>
<a class="anchor" id="ga69de2af20dc203f258335dfc475cf1ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a>* svn_stringbuf_create_empty </td>
          <td>(</td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new, empty stringbuf. </p>
<dl class="section since"><dt>Since</dt><dd>New in 1.8. </dd></dl>

</div>
</div>
<a class="anchor" id="ga75ce9fc03e6382cd7a259042834355b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a>* svn_stringbuf_create_ensure </td>
          <td>(</td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>minimum_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new, empty stringbuf with at least <em>minimum_size</em> bytes of space available in the memory block. </p>
<p>The allocated string buffer will be at least one byte larger than <em>minimum_size</em> to account for a final '\0'.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9593514bf4b6f220d498a1bcad1cb63f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a>* svn_stringbuf_create_wrap </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new stringbuf using the given <em>str</em> as initial buffer. </p>
<p>Allocate the result in <em>pool</em>. In contrast to <a class="el" href="group__svn__string__svn__stringbuf__t.html#ga8601f093a616a8e02037dc8e8a90f91a" title="Create a new stringbuf copied from the null-terminated C string cstring. ">svn_stringbuf_create</a>, the contents of <em>str</em> may change when the stringbuf gets modified.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.9 </dd></dl>

</div>
</div>
<a class="anchor" id="gad96ee402d1430439779f7e19159ecd78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a>* svn_stringbuf_dup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&#160;</td>
          <td class="paramname"><em>original_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a duplicate of <em>original_string</em>. </p>

</div>
</div>
<a class="anchor" id="gaebc36db5adf759c66508d23e3cb195c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a>* <a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a>* void svn_stringbuf_ensure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>minimum_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new stringbuf by printf-style formatting using <em>fmt</em> and the variable arguments, which are as appropriate for apr_psprintf(). </p>
<p>Create a new stringbuf by printf-style formatting using <code>fmt</code> and <em>ap</em>. This is the same as svn_stringbuf_createf() except for the different way of passing the variable arguments. Make sure that <em>str</em> has at least <em>minimum_size</em> bytes of space available in the memory block.</p>
<p>The allocated string buffer will be at least one byte larger than <em>minimum_size</em> to account for a final '\0'.</p>
<dl class="section note"><dt>Note</dt><dd>: Before Subversion 1.8 this function did not ensure space for one byte more than <em>minimum_size</em>. If compatibility with pre-1.8 behaviour is required callers must assume space for only <em>minimum_size-1</em> data bytes plus a final '\0'. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4373bb2fae064fb648344f49f24fc96c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_stringbuf_fillchar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill <em>str</em> with character <em>c</em>. </p>

</div>
</div>
<a class="anchor" id="ga59fe19732799703addf0c20a7f45133f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_stringbuf_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert into <em>str</em> at position <em>pos</em> an array of bytes <em>bytes</em> which is <em>count</em> bytes long. </p>
<p>The resulting string will be <code>count+str-&gt;len</code> bytes long. If <em>pos</em> is larger than or equal to <code>str-&gt;len</code>, simply append <em>bytes</em>.</p>
<p>Reallocs if necessary. <em>str</em> is affected, nothing else is.</p>
<dl class="section note"><dt>Note</dt><dd>The inserted string may be a sub-range of <em>str</em>.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.8.</dd>
<dd>
Since 1.9, <em>bytes</em> can be NULL if <em>count</em> is zero. </dd></dl>

</div>
</div>
<a class="anchor" id="ga40f3e623c857983b4b56e603431a00fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> svn_stringbuf_isempty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>TRUE</code> if <em>str</em> is empty (has length zero). </p>

</div>
</div>
<a class="anchor" id="ga52aff4fcf51690403e493bb35ac87991"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a>* svn_stringbuf_ncreate </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new stringbuf copied from the generic string of bytes, <em>bytes</em>, of length <em>size</em> bytes. </p>
<p><em>bytes</em> is NOT assumed to be null-terminated, but the new stringbuf will be.</p>
<dl class="section since"><dt>Since</dt><dd>Since 1.9, <em>bytes</em> can be NULL if <em>size</em> is zero. </dd></dl>

</div>
</div>
<a class="anchor" id="ga95328e1824649b300eff3b3f9b07f85f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_stringbuf_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove <em>count</em> bytes from <em>str</em>, starting at position <em>pos</em>. </p>
<p>If that range exceeds the current string data, truncate <em>str</em> at <em>pos</em>. If <em>pos</em> is larger than or equal to <code>str-&gt;len</code>, this will be a no-op. Otherwise, the resulting string will be <code>str-&gt;len-count</code> bytes long.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.8. </dd></dl>

</div>
</div>
<a class="anchor" id="gaceb4e369123b0bc333d0bf3014fb9d51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_stringbuf_replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>old_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>new_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace in <em>str</em> the substring which starts at <em>pos</em> and is <em>old_count</em> bytes long with a new substring <em>bytes</em> which is <em>new_count</em> bytes long. </p>
<p>This is faster but functionally equivalent to the following sequence: </p>
<div class="fragment"><div class="line">    <a class="code" href="group__svn__string__svn__stringbuf__t.html#ga95328e1824649b300eff3b3f9b07f85f">svn_stringbuf_remove</a>(str, pos, old_count);</div>
<div class="line">    <a class="code" href="group__svn__string__svn__stringbuf__t.html#ga59fe19732799703addf0c20a7f45133f">svn_stringbuf_insert</a>(str, pos, bytes, new_count);</div>
<div class="line">* </div>
</div><!-- fragment --><dl class="section since"><dt>Since</dt><dd>New in 1.8.</dd>
<dd>
Since 1.9, <em>bytes</em> can be NULL if <em>new_count</em> is zero. </dd></dl>

</div>
</div>
<a class="anchor" id="ga026d3c9d0850c9b3131dcb37400de532"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_stringbuf_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>str</em> to a copy of the null-terminated C string <em>value</em>. </p>

</div>
</div>
<a class="anchor" id="gab83a676f045b8661689f04a59e0efce9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_stringbuf_setempty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>str</em> to empty (zero length). </p>

</div>
</div>
<a class="anchor" id="ga6509ce58676a3f404250ea8653034a20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_stringbuf_strip_whitespace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Strip whitespace from both sides of <em>str</em> (modified in place). </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Aug 19 2015 09:17:28 for Subversion by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
