<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Subversion: Filesystem locks</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Subversion
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Filesystem locks<div class="ingroups"><a class="el" href="group__fs__handling.html">Filesystem interaction subsystem</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf6abb5b038118c1b56efbea45eb58b30"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__svn__fs__locks.html#gaf6abb5b038118c1b56efbea45eb58b30">svn_fs_lock_target_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__locks.html#gaf6abb5b038118c1b56efbea45eb58b30">svn_fs_lock_target_t</a></td></tr>
<tr class="memdesc:gaf6abb5b038118c1b56efbea45eb58b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lock represents one user's exclusive right to modify a path in a filesystem.  <a href="#gaf6abb5b038118c1b56efbea45eb58b30">More...</a><br/></td></tr>
<tr class="separator:gaf6abb5b038118c1b56efbea45eb58b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga464d0d801ccb2a5216d024f258589074"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__locks.html#ga464d0d801ccb2a5216d024f258589074">svn_fs_lock_callback_t</a> )(void *baton, const char *path, const <a class="el" href="structsvn__lock__t.html">svn_lock_t</a> *lock, <a class="el" href="structsvn__error__t.html">svn_error_t</a> *fs_err, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:ga464d0d801ccb2a5216d024f258589074"><td class="mdescLeft">&#160;</td><td class="mdescRight">The callback invoked by <a class="el" href="group__svn__fs__locks.html#ga17e9fc43db869cc40fa9a6f29df7e59b" title="Lock the paths in lock_targets in fs. ">svn_fs_lock_many()</a> and <a class="el" href="group__svn__fs__locks.html#gae806d1e7fb9270086be85e0b162759ab" title="Remove the locks on the paths in unlock_targets in fs. ">svn_fs_unlock_many()</a>.  <a href="#ga464d0d801ccb2a5216d024f258589074">More...</a><br/></td></tr>
<tr class="separator:ga464d0d801ccb2a5216d024f258589074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga668d3961d6663956afaa1747353ce543"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__locks.html#ga668d3961d6663956afaa1747353ce543">svn_fs_get_locks_callback_t</a> )(void *baton, <a class="el" href="structsvn__lock__t.html">svn_lock_t</a> *lock, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga668d3961d6663956afaa1747353ce543"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a lock discovery callback function.  <a href="#ga668d3961d6663956afaa1747353ce543">More...</a><br/></td></tr>
<tr class="separator:ga668d3961d6663956afaa1747353ce543"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaee083177f853f0c0de9e457ff8b7a146"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__svn__fs__locks.html#gaf6abb5b038118c1b56efbea45eb58b30">svn_fs_lock_target_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__locks.html#gaee083177f853f0c0de9e457ff8b7a146">svn_fs_lock_target_create</a> (const char *token, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> current_rev, apr_pool_t *result_pool)</td></tr>
<tr class="memdesc:gaee083177f853f0c0de9e457ff8b7a146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <code>svn_fs_lock_target_t</code> allocated in <em>result_pool</em>.  <a href="#gaee083177f853f0c0de9e457ff8b7a146">More...</a><br/></td></tr>
<tr class="separator:gaee083177f853f0c0de9e457ff8b7a146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9151d6c69d52c241e686a573276c5d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__locks.html#gae9151d6c69d52c241e686a573276c5d8">svn_fs_lock_target_set_token</a> (<a class="el" href="group__svn__fs__locks.html#gaf6abb5b038118c1b56efbea45eb58b30">svn_fs_lock_target_t</a> *target, const char *token)</td></tr>
<tr class="memdesc:gae9151d6c69d52c241e686a573276c5d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update <em>target</em> changing the token to <em>token</em>, <em>token</em> can be NULL.  <a href="#gae9151d6c69d52c241e686a573276c5d8">More...</a><br/></td></tr>
<tr class="separator:gae9151d6c69d52c241e686a573276c5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17e9fc43db869cc40fa9a6f29df7e59b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__locks.html#ga17e9fc43db869cc40fa9a6f29df7e59b">svn_fs_lock_many</a> (<a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, apr_hash_t *lock_targets, const char *comment, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> is_dav_comment, apr_time_t expiration_date, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> steal_lock, <a class="el" href="group__svn__fs__locks.html#ga464d0d801ccb2a5216d024f258589074">svn_fs_lock_callback_t</a> lock_callback, void *lock_baton, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:ga17e9fc43db869cc40fa9a6f29df7e59b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the paths in <em>lock_targets</em> in <em>fs</em>.  <a href="#ga17e9fc43db869cc40fa9a6f29df7e59b">More...</a><br/></td></tr>
<tr class="separator:ga17e9fc43db869cc40fa9a6f29df7e59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae552c755f0b7d2f390f3ccf844e8ad37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__locks.html#gae552c755f0b7d2f390f3ccf844e8ad37">svn_fs_lock</a> (<a class="el" href="structsvn__lock__t.html">svn_lock_t</a> **lock, <a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, const char *path, const char *token, const char *comment, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> is_dav_comment, apr_time_t expiration_date, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> current_rev, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> steal_lock, apr_pool_t *pool)</td></tr>
<tr class="memdesc:gae552c755f0b7d2f390f3ccf844e8ad37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="group__svn__fs__locks.html#ga17e9fc43db869cc40fa9a6f29df7e59b" title="Lock the paths in lock_targets in fs. ">svn_fs_lock_many()</a> but locks only a single <em>path</em> and returns the lock in <em>*lock</em>, allocated in <em>pool</em>, or an error.  <a href="#gae552c755f0b7d2f390f3ccf844e8ad37">More...</a><br/></td></tr>
<tr class="separator:gae552c755f0b7d2f390f3ccf844e8ad37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2caf8e8ad52cf830d17626f7805bc42e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__locks.html#ga2caf8e8ad52cf830d17626f7805bc42e">svn_fs_generate_lock_token</a> (const char **token, <a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga2caf8e8ad52cf830d17626f7805bc42e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a unique lock-token using <em>fs</em>.  <a href="#ga2caf8e8ad52cf830d17626f7805bc42e">More...</a><br/></td></tr>
<tr class="separator:ga2caf8e8ad52cf830d17626f7805bc42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae806d1e7fb9270086be85e0b162759ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__locks.html#gae806d1e7fb9270086be85e0b162759ab">svn_fs_unlock_many</a> (<a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, apr_hash_t *unlock_targets, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> break_lock, <a class="el" href="group__svn__fs__locks.html#ga464d0d801ccb2a5216d024f258589074">svn_fs_lock_callback_t</a> lock_callback, void *lock_baton, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:gae806d1e7fb9270086be85e0b162759ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the locks on the paths in <em>unlock_targets</em> in <em>fs</em>.  <a href="#gae806d1e7fb9270086be85e0b162759ab">More...</a><br/></td></tr>
<tr class="separator:gae806d1e7fb9270086be85e0b162759ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07bff914fc145098d02d354608abfbc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__locks.html#ga07bff914fc145098d02d354608abfbc8">svn_fs_unlock</a> (<a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, const char *path, const char *token, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> break_lock, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga07bff914fc145098d02d354608abfbc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="group__svn__fs__locks.html#gae806d1e7fb9270086be85e0b162759ab" title="Remove the locks on the paths in unlock_targets in fs. ">svn_fs_unlock_many()</a> but only unlocks a single path.  <a href="#ga07bff914fc145098d02d354608abfbc8">More...</a><br/></td></tr>
<tr class="separator:ga07bff914fc145098d02d354608abfbc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f4e9e1f28d46d6a23a1e12e7877ebc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__locks.html#ga1f4e9e1f28d46d6a23a1e12e7877ebc9">svn_fs_get_lock</a> (<a class="el" href="structsvn__lock__t.html">svn_lock_t</a> **lock, <a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, const char *path, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga1f4e9e1f28d46d6a23a1e12e7877ebc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <em>path</em> is locked in <em>fs</em>, set <em>*lock</em> to an <a class="el" href="structsvn__lock__t.html" title="A lock object, for client &amp; server to share. ">svn_lock_t</a> which represents the lock, allocated in <em>pool</em>.  <a href="#ga1f4e9e1f28d46d6a23a1e12e7877ebc9">More...</a><br/></td></tr>
<tr class="separator:ga1f4e9e1f28d46d6a23a1e12e7877ebc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ee19c1699b8244ef2e56e1d78241e63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__locks.html#ga3ee19c1699b8244ef2e56e1d78241e63">svn_fs_get_locks2</a> (<a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, const char *path, <a class="el" href="svn__types_8h.html#a21dd8b080111fa6fb5d59156299f3a2c">svn_depth_t</a> depth, <a class="el" href="group__svn__fs__locks.html#ga668d3961d6663956afaa1747353ce543">svn_fs_get_locks_callback_t</a> get_locks_func, void *get_locks_baton, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga3ee19c1699b8244ef2e56e1d78241e63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report locks on or below <em>path</em> in <em>fs</em> using the <em>get_locks_func</em> / <em>get_locks_baton</em>.  <a href="#ga3ee19c1699b8244ef2e56e1d78241e63">More...</a><br/></td></tr>
<tr class="separator:ga3ee19c1699b8244ef2e56e1d78241e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c0fdad9e95f6d0c1f4deb711d860e01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__locks.html#ga5c0fdad9e95f6d0c1f4deb711d860e01">svn_fs_get_locks</a> (<a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, const char *path, <a class="el" href="group__svn__fs__locks.html#ga668d3961d6663956afaa1747353ce543">svn_fs_get_locks_callback_t</a> get_locks_func, void *get_locks_baton, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga5c0fdad9e95f6d0c1f4deb711d860e01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="group__svn__fs__locks.html#ga3ee19c1699b8244ef2e56e1d78241e63" title="Report locks on or below path in fs using the get_locks_func / get_locks_baton. ">svn_fs_get_locks2()</a>, but with <em>depth</em> always passed as svn_depth_infinity, and with the following known problem (which is not present in <a class="el" href="group__svn__fs__locks.html#ga3ee19c1699b8244ef2e56e1d78241e63" title="Report locks on or below path in fs using the get_locks_func / get_locks_baton. ">svn_fs_get_locks2()</a>):  <a href="#ga5c0fdad9e95f6d0c1f4deb711d860e01">More...</a><br/></td></tr>
<tr class="separator:ga5c0fdad9e95f6d0c1f4deb711d860e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<dl class="section since"><dt>Since</dt><dd>New in 1.2. </dd></dl>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga668d3961d6663956afaa1747353ce543"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* svn_fs_get_locks_callback_t)(void *baton, <a class="el" href="structsvn__lock__t.html">svn_lock_t</a> *lock, apr_pool_t *pool)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of a lock discovery callback function. </p>
<p><em>baton</em> is the value specified in the call to <a class="el" href="group__svn__fs__locks.html#ga5c0fdad9e95f6d0c1f4deb711d860e01" title="Similar to svn_fs_get_locks2(), but with depth always passed as svn_depth_infinity, and with the following known problem (which is not present in svn_fs_get_locks2()): ">svn_fs_get_locks()</a>; the filesystem passes it through to the callback. <em>lock</em> is a lock structure. <em>pool</em> is a temporary subpool for use by the callback implementation &ndash; it is cleared after invocation of the callback. </p>

<p>Definition at line <a class="el" href="svn__fs_8h_source.html#l02881">2881</a> of file <a class="el" href="svn__fs_8h_source.html">svn_fs.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga464d0d801ccb2a5216d024f258589074"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* svn_fs_lock_callback_t)(void *baton, const char *path, const <a class="el" href="structsvn__lock__t.html">svn_lock_t</a> *lock, <a class="el" href="structsvn__error__t.html">svn_error_t</a> *fs_err, apr_pool_t *scratch_pool)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The callback invoked by <a class="el" href="group__svn__fs__locks.html#ga17e9fc43db869cc40fa9a6f29df7e59b" title="Lock the paths in lock_targets in fs. ">svn_fs_lock_many()</a> and <a class="el" href="group__svn__fs__locks.html#gae806d1e7fb9270086be85e0b162759ab" title="Remove the locks on the paths in unlock_targets in fs. ">svn_fs_unlock_many()</a>. </p>
<p><em>path</em> and <em>lock</em> are allocated in the result_pool passed to svn_fs_lock_many/svn_fs_unlock_many and so will persist beyond the callback invocation. <em>fs_err</em> will be cleared after the callback returns, use <a class="el" href="group__svn__error__error__creation__destroy.html#ga8ad51ea34a25e1ef607a7f95494319ea" title="Create a new error that is a deep copy of err and return it. ">svn_error_dup()</a> to preserve the error.</p>
<p>If the callback returns an error no further callbacks will be made and svn_fs_lock_many/svn_fs_unlock_many will return an error. The caller cannot rely on any particular order for these callbacks and cannot rely on interrupting the underlying operation by returning an error. Returning an error stops the callbacks but any locks that would have been reported in further callbacks may, or may not, still be created/released.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.9. </dd></dl>

<p>Definition at line <a class="el" href="svn__fs_8h_source.html#l02706">2706</a> of file <a class="el" href="svn__fs_8h_source.html">svn_fs.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaf6abb5b038118c1b56efbea45eb58b30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__svn__fs__locks.html#gaf6abb5b038118c1b56efbea45eb58b30">svn_fs_lock_target_t</a> <a class="el" href="group__svn__fs__locks.html#gaf6abb5b038118c1b56efbea45eb58b30">svn_fs_lock_target_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A lock represents one user's exclusive right to modify a path in a filesystem. </p>
<p>In order to create or destroy a lock, a username must be associated with the filesystem's access context (see <a class="el" href="group__svn__fs__access__ctx.html#ga7fe2e31558e4e2e764fb33c0065704eb" title="An opaque object representing temporary user data. ">svn_fs_access_t</a>).</p>
<p>When a lock is created, a 'lock-token' is returned. The lock-token is a unique URI that represents the lock (treated as an opaque string by the client), and is required to make further use of the lock (including removal of the lock.) A lock-token can also be queried to return a <a class="el" href="structsvn__lock__t.html" title="A lock object, for client &amp; server to share. ">svn_lock_t</a> structure that describes the details of the lock. lock-tokens must not contain any newline character, mainly due to the serialization for tokens for pre-commit hook.</p>
<p>Locks are not secret; anyone can view existing locks in a filesystem. Locks are not omnipotent: they can be broken and stolen by people who don't "own" the lock. (Though admins can tailor a custom break/steal policy via libsvn_repos pre-lock hook script.)</p>
<p>Locks can be created with an optional expiration date. If a lock has an expiration date, then the act of fetching/reading it might cause it to automatically expire, returning either nothing or an expiration error (depending on the API). Lock information for use with <a class="el" href="group__svn__fs__locks.html#ga17e9fc43db869cc40fa9a6f29df7e59b" title="Lock the paths in lock_targets in fs. ">svn_fs_lock_many()</a> [and svn_repos_fs_...].</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__svn__fs__locks.html#gaee083177f853f0c0de9e457ff8b7a146" title="Create an svn_fs_lock_target_t allocated in result_pool. ">svn_fs_lock_target_create</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.9. </dd></dl>

<p>Definition at line <a class="el" href="svn__fs_8h_source.html#l02665">2665</a> of file <a class="el" href="svn__fs_8h_source.html">svn_fs.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga2caf8e8ad52cf830d17626f7805bc42e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_generate_lock_token </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a unique lock-token using <em>fs</em>. </p>
<p>Return in <em>*token</em>, allocated in <em>pool</em>.</p>
<p>This can be used in to populate lock-&gt;token before calling svn_fs_attach_lock(). </p>

</div>
</div>
<a class="anchor" id="ga1f4e9e1f28d46d6a23a1e12e7877ebc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_get_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__lock__t.html">svn_lock_t</a> **&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <em>path</em> is locked in <em>fs</em>, set <em>*lock</em> to an <a class="el" href="structsvn__lock__t.html" title="A lock object, for client &amp; server to share. ">svn_lock_t</a> which represents the lock, allocated in <em>pool</em>. </p>
<p>If <em>path</em> is not locked or does not exist in HEAD, set <em>*lock</em> to NULL. </p>

</div>
</div>
<a class="anchor" id="ga5c0fdad9e95f6d0c1f4deb711d860e01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_get_locks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__locks.html#ga668d3961d6663956afaa1747353ce543">svn_fs_get_locks_callback_t</a>&#160;</td>
          <td class="paramname"><em>get_locks_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>get_locks_baton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="group__svn__fs__locks.html#ga3ee19c1699b8244ef2e56e1d78241e63" title="Report locks on or below path in fs using the get_locks_func / get_locks_baton. ">svn_fs_get_locks2()</a>, but with <em>depth</em> always passed as svn_depth_infinity, and with the following known problem (which is not present in <a class="el" href="group__svn__fs__locks.html#ga3ee19c1699b8244ef2e56e1d78241e63" title="Report locks on or below path in fs using the get_locks_func / get_locks_baton. ">svn_fs_get_locks2()</a>): </p>
<dl class="section note"><dt>Note</dt><dd>On Berkeley-DB-backed filesystems in Subversion 1.6 and prior, the <em>get_locks_func</em> callback will be invoked from within a Berkeley-DB transaction trail. Implementors of the callback are, as a result, forbidden from calling any svn_fs API functions which might themselves attempt to start a new Berkeley DB transaction (which is most of this svn_fs API). Yes, this is a nasty implementation detail to have to be aware of.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000240">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.6 API. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3ee19c1699b8244ef2e56e1d78241e63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_get_locks2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a21dd8b080111fa6fb5d59156299f3a2c">svn_depth_t</a>&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__locks.html#ga668d3961d6663956afaa1747353ce543">svn_fs_get_locks_callback_t</a>&#160;</td>
          <td class="paramname"><em>get_locks_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>get_locks_baton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report locks on or below <em>path</em> in <em>fs</em> using the <em>get_locks_func</em> / <em>get_locks_baton</em>. </p>
<p>Use <em>pool</em> for necessary allocations.</p>
<p><em>depth</em> limits the reported locks to those associated with paths within the specified depth of <em>path</em>, and must be one of the following values: <a class="el" href="svn__types_8h.html#a21dd8b080111fa6fb5d59156299f3a2ca8783254e886077b74a05341491fc353c" title="Just the named directory D, no entries. ">svn_depth_empty</a>, <a class="el" href="svn__types_8h.html#a21dd8b080111fa6fb5d59156299f3a2ca0c4df7073a6d268f0e26bbf961f35345" title="D + its file children, but not subdirs. ">svn_depth_files</a>, <a class="el" href="svn__types_8h.html#a21dd8b080111fa6fb5d59156299f3a2ca68873e015456e384e4f63f3bbd515c8a" title="D + immediate children (D and its entries). ">svn_depth_immediates</a>, or <a class="el" href="svn__types_8h.html#a21dd8b080111fa6fb5d59156299f3a2ca9c9a00ca9d05799d0d2a7646d4f0cbf2" title="D + all descendants (full recursion from D). ">svn_depth_infinity</a>.</p>
<p>If the <em>get_locks_func</em> callback implementation returns an error, lock iteration will terminate and that error will be returned by this function.</p>
<dl class="section note"><dt>Note</dt><dd>Over the course of this function's invocation, locks might be added, removed, or modified by concurrent processes. Callers need to anticipate and gracefully handle the transience of this information.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="gae552c755f0b7d2f390f3ccf844e8ad37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__lock__t.html">svn_lock_t</a> **&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>comment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>is_dav_comment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_time_t&#160;</td>
          <td class="paramname"><em>expiration_date</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a>&#160;</td>
          <td class="paramname"><em>current_rev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>steal_lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="group__svn__fs__locks.html#ga17e9fc43db869cc40fa9a6f29df7e59b" title="Lock the paths in lock_targets in fs. ">svn_fs_lock_many()</a> but locks only a single <em>path</em> and returns the lock in <em>*lock</em>, allocated in <em>pool</em>, or an error. </p>
<dl class="section since"><dt>Since</dt><dd>New in 1.2. </dd></dl>

</div>
</div>
<a class="anchor" id="ga17e9fc43db869cc40fa9a6f29df7e59b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_lock_many </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_hash_t *&#160;</td>
          <td class="paramname"><em>lock_targets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>comment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>is_dav_comment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_time_t&#160;</td>
          <td class="paramname"><em>expiration_date</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>steal_lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__locks.html#ga464d0d801ccb2a5216d024f258589074">svn_fs_lock_callback_t</a>&#160;</td>
          <td class="paramname"><em>lock_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>lock_baton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock the paths in <em>lock_targets</em> in <em>fs</em>. </p>
<p><em>fs</em> must have a username associated with it (see <a class="el" href="group__svn__fs__access__ctx.html#ga7fe2e31558e4e2e764fb33c0065704eb" title="An opaque object representing temporary user data. ">svn_fs_access_t</a>), else return <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660abea66f3bd37729675246ba64e69f7127" title="&quot;No user associated with filesystem&quot; ">SVN_ERR_FS_NO_USER</a>. Set the 'owner' field in each new lock to the fs username.</p>
<p><em>comment</em> is optional: it's either an xml-escapable UTF8 string which describes the lock, or it is <code>NULL</code>.</p>
<p><em>is_dav_comment</em> describes whether the comment was created by a generic DAV client; only mod_dav_svn's autoversioning feature needs to use it. If in doubt, pass 0.</p>
<p>The paths to be locked are passed as the <code>const char *</code> keys of the <em>lock_targets</em> hash. The hash values are <code>svn_fs_lock_target_t *</code> and provide the token and <em>current_rev</em> for each path. The token is a lock token such as can be generated using <a class="el" href="group__svn__fs__locks.html#ga2caf8e8ad52cf830d17626f7805bc42e" title="Generate a unique lock-token using fs. ">svn_fs_generate_lock_token()</a> (indicating that the caller wants to dictate the lock token used), or it is <code>NULL</code> (indicating that the caller wishes to have a new token generated by this function). If the token is not <code>NULL</code>, and represents an existing lock, then the path must match the path associated with that existing lock. If <em>current_rev</em> is a valid revnum, then do an out-of-dateness check. If the revnum is less than the last-changed-revision of the path (or if the path doesn't exist in HEAD), yield an <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660a10d4f300327447395ef61f11c81ed4d7" title="&quot;Item is out of date&quot; ">SVN_ERR_FS_OUT_OF_DATE</a> error for this path.</p>
<p>If a path is already locked, then yield <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660a021a707e691a57f931765899c963b12c" title="&quot;Path is already locked&quot; ">SVN_ERR_FS_PATH_ALREADY_LOCKED</a>, unless <em>steal_lock</em> is TRUE, in which case "steal" the existing lock, even if the FS access-context's username does not match the current lock's owner: delete the existing lock on the path, and create a new one.</p>
<p>If <em>expiration_date</em> is zero, then create a non-expiring lock. Else, the lock will expire at <em>expiration_date</em>.</p>
<p>For each path in <em>lock_targets</em> <em>lock_callback</em> will be invoked passing <em>lock_baton</em> and the lock and error that apply to path. <em>lock_callback</em> can be NULL in which case it is not called and any errors that would have been passed to the callback are not reported.</p>
<p>The lock and path passed to <em>lock_callback</em> will be allocated in <em>result_pool</em>. Use <em>scratch_pool</em> for temporary allocations.</p>
<dl class="section note"><dt>Note</dt><dd>At this time, only files can be locked.</dd>
<dd>
This function is not atomic. If it returns an error, some targets may remain unlocked while others may have been locked.</dd>
<dd>
You probably don't want to use this directly. Take a look at <a class="el" href="group__svn__repos__fs__locks.html#ga306701087d3f3c7a5caa3f18d156b071" title="Like svn_fs_lock_many(), but invoke the repos&#39;s pre- and post-lock hooks before and after the locking...">svn_repos_fs_lock_many()</a> instead.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.9. </dd></dl>

</div>
</div>
<a class="anchor" id="gaee083177f853f0c0de9e457ff8b7a146"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__svn__fs__locks.html#gaf6abb5b038118c1b56efbea45eb58b30">svn_fs_lock_target_t</a>* svn_fs_lock_target_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a>&#160;</td>
          <td class="paramname"><em>current_rev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <code>svn_fs_lock_target_t</code> allocated in <em>result_pool</em>. </p>
<p><em>token</em> can be NULL and <em>current_rev</em> can be SVN_INVALID_REVNUM.</p>
<p>The <em>token</em> is not duplicated and so must have a lifetime at least as long as the returned target object.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.9. </dd></dl>

</div>
</div>
<a class="anchor" id="gae9151d6c69d52c241e686a573276c5d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_fs_lock_target_set_token </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__fs__locks.html#gaf6abb5b038118c1b56efbea45eb58b30">svn_fs_lock_target_t</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update <em>target</em> changing the token to <em>token</em>, <em>token</em> can be NULL. </p>
<p>The <em>token</em> is not duplicated and so must have a lifetime at least as long as <em>target</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.9. </dd></dl>

</div>
</div>
<a class="anchor" id="ga07bff914fc145098d02d354608abfbc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>break_lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="group__svn__fs__locks.html#gae806d1e7fb9270086be85e0b162759ab" title="Remove the locks on the paths in unlock_targets in fs. ">svn_fs_unlock_many()</a> but only unlocks a single path. </p>
<dl class="section since"><dt>Since</dt><dd>New in 1.2. </dd></dl>

</div>
</div>
<a class="anchor" id="gae806d1e7fb9270086be85e0b162759ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_unlock_many </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_hash_t *&#160;</td>
          <td class="paramname"><em>unlock_targets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>break_lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__locks.html#ga464d0d801ccb2a5216d024f258589074">svn_fs_lock_callback_t</a>&#160;</td>
          <td class="paramname"><em>lock_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>lock_baton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the locks on the paths in <em>unlock_targets</em> in <em>fs</em>. </p>
<p>The paths to be unlocked are passed as <code>const char *</code> keys of the <em>unlock_targets</em> hash with the corresponding lock tokens as <code>const char *</code> values. If the token doesn't point to a lock, yield an <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660a9a37c53ba6c0f1169d9188bd95dd6f82" title="&quot;Lock token is incorrect&quot; ">SVN_ERR_FS_BAD_LOCK_TOKEN</a> error for this path. If the token points to an expired lock, yield an <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660a3cad60a7c1da32cb52e2c88371f9ea63" title="&quot;Lock has expired&quot; ">SVN_ERR_FS_LOCK_EXPIRED</a> error for this path. If <em>fs</em> has no username associated with it, yield an <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660abea66f3bd37729675246ba64e69f7127" title="&quot;No user associated with filesystem&quot; ">SVN_ERR_FS_NO_USER</a> unless <em>break_lock</em> is specified.</p>
<p>If the token points to a lock, but the username of <em>fs's</em> access context doesn't match the lock's owner, yield an <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660afe27e62e4a25a191b8833c3de054e9a1" title="&quot;Username does not match lock owner&quot; ">SVN_ERR_FS_LOCK_OWNER_MISMATCH</a>. If <em>break_lock</em> is TRUE, however, don't return error; allow the lock to be "broken" in any case. In the latter case, the token shall be <code>NULL</code>.</p>
<p>For each path in <em>unlock_targets</em> <em>lock_callback</em> will be invoked passing <em>lock_baton</em> and error that apply to path. The <em>lock</em> passed to the callback will be NULL. <em>lock_callback</em> can be NULL in which case it is not called and any errors that would have been passed to the callback are not reported.</p>
<p>The path passed to lock_callback will be allocated in <em>result_pool</em>. Use <em>scratch_pool</em> for temporary allocations.</p>
<dl class="section note"><dt>Note</dt><dd>This function is not atomic. If it returns an error, some targets may remain locked while others may have been unlocked.</dd>
<dd>
You probably don't want to use this directly. Take a look at <a class="el" href="group__svn__repos__fs__locks.html#ga7dbe8ff1f775e23ebfd5f3babb51110b" title="Like svn_fs_unlock_many(), but invoke the repos&#39;s pre- and post-unlock hooks before and after the unl...">svn_repos_fs_unlock_many()</a> instead.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.9. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Aug 19 2015 09:17:27 for Subversion by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
