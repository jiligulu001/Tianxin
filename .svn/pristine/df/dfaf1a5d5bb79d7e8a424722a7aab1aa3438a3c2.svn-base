<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Subversion: svn_subst.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Subversion
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_c37f7789c49aa9e5999234152b1ef6ed.html">subversion</a></li><li class="navelem"><a class="el" href="dir_334478eea8dba5ae935f94af9469978f.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">svn_subst.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Data substitution (keywords and EOL style)  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;apr_pools.h&gt;</code><br/>
<code>#include &lt;apr_hash.h&gt;</code><br/>
<code>#include &lt;apr_time.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="svn__types_8h_source.html">svn_types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="svn__string_8h_source.html">svn_string.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="svn__io_8h_source.html">svn_io.h</a>&quot;</code><br/>
</div>
<p><a href="svn__subst_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__subst__keywords__t.html">svn_subst_keywords_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values used in keyword expansion.  <a href="structsvn__subst__keywords__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a2b96491e8354387681b06b54d317b10f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b96491e8354387681b06b54d317b10f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#a2b96491e8354387681b06b54d317b10f">SVN_SUBST_NATIVE_EOL_STR</a>&#160;&#160;&#160;&quot;\n&quot;</td></tr>
<tr class="memdesc:a2b96491e8354387681b06b54d317b10f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The EOL used in the Repository for "native" files. <br/></td></tr>
<tr class="separator:a2b96491e8354387681b06b54d317b10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a82d6196808784a7a73e098f8d8534edb"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="svn__subst_8h.html#a160543c34edb8318de8cbe4543bbca28">svn_subst_eol_style</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#a82d6196808784a7a73e098f8d8534edb">svn_subst_eol_style_t</a></td></tr>
<tr class="memdesc:a82d6196808784a7a73e098f8d8534edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Valid states for 'svn:eol-style' property.  <a href="#a82d6196808784a7a73e098f8d8534edb">More...</a><br/></td></tr>
<tr class="separator:a82d6196808784a7a73e098f8d8534edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f86ade6d1361383d284d423bd333ce"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structsvn__subst__keywords__t.html">svn_subst_keywords_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#a23f86ade6d1361383d284d423bd333ce">svn_subst_keywords_t</a></td></tr>
<tr class="memdesc:a23f86ade6d1361383d284d423bd333ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values used in keyword expansion.  <a href="#a23f86ade6d1361383d284d423bd333ce">More...</a><br/></td></tr>
<tr class="separator:a23f86ade6d1361383d284d423bd333ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a160543c34edb8318de8cbe4543bbca28"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#a160543c34edb8318de8cbe4543bbca28">svn_subst_eol_style</a> { <br/>
&#160;&#160;<a class="el" href="svn__subst_8h.html#a160543c34edb8318de8cbe4543bbca28a6e1bf631a8574e3cf1e52b6599785fdf">svn_subst_eol_style_unknown</a>, 
<br/>
&#160;&#160;<a class="el" href="svn__subst_8h.html#a160543c34edb8318de8cbe4543bbca28ac33cc2b19c97a910b90d4efef275043f">svn_subst_eol_style_none</a>, 
<br/>
&#160;&#160;<a class="el" href="svn__subst_8h.html#a160543c34edb8318de8cbe4543bbca28a2fdd9ef5ba015f6ecc6d59458df5c055">svn_subst_eol_style_native</a>, 
<br/>
&#160;&#160;<a class="el" href="svn__subst_8h.html#a160543c34edb8318de8cbe4543bbca28a6e778790cbc23c4028f73aaaf5524069">svn_subst_eol_style_fixed</a>
<br/>
 }</td></tr>
<tr class="memdesc:a160543c34edb8318de8cbe4543bbca28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Valid states for 'svn:eol-style' property.  <a href="svn__subst_8h.html#a160543c34edb8318de8cbe4543bbca28">More...</a><br/></td></tr>
<tr class="separator:a160543c34edb8318de8cbe4543bbca28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:adee8f25af905f8a450092b61ba79ea5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#adee8f25af905f8a450092b61ba79ea5c">svn_subst_eol_style_from_value</a> (<a class="el" href="svn__subst_8h.html#a82d6196808784a7a73e098f8d8534edb">svn_subst_eol_style_t</a> *style, const char **eol, const char *value)</td></tr>
<tr class="memdesc:adee8f25af905f8a450092b61ba79ea5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*style</em> to the appropriate <code>svn_subst_eol_style_t</code> and <em>*eol</em> to the appropriate cstring for a given svn:eol-style property value.  <a href="#adee8f25af905f8a450092b61ba79ea5c">More...</a><br/></td></tr>
<tr class="separator:adee8f25af905f8a450092b61ba79ea5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8655a649e193b8eb96ba8ea59433a6b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#a8655a649e193b8eb96ba8ea59433a6b3">svn_subst_translation_required</a> (<a class="el" href="svn__subst_8h.html#a82d6196808784a7a73e098f8d8534edb">svn_subst_eol_style_t</a> style, const char *eol, apr_hash_t *keywords, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> special, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> force_eol_check)</td></tr>
<tr class="memdesc:a8655a649e193b8eb96ba8ea59433a6b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the working copy and normalized versions of a file with the given the parameters differ.  <a href="#a8655a649e193b8eb96ba8ea59433a6b3">More...</a><br/></td></tr>
<tr class="separator:a8655a649e193b8eb96ba8ea59433a6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3887317efcb79a36c06da495b30136fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#a3887317efcb79a36c06da495b30136fd">svn_subst_build_keywords3</a> (apr_hash_t **kw, const char *keywords_string, const char *rev, const char *url, const char *repos_root_url, apr_time_t date, const char *author, apr_pool_t *pool)</td></tr>
<tr class="memdesc:a3887317efcb79a36c06da495b30136fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*kw</em> to a new keywords hash filled with the appropriate contents given a <em>keywords_string</em> (the contents of the svn:keywords property for the file in question), the revision <em>rev</em>, the <em>url</em>, the <em>date</em> the file was committed on, the <em>author</em> of the last commit, and the URL of the repository root <em>repos_root_url</em>.  <a href="#a3887317efcb79a36c06da495b30136fd">More...</a><br/></td></tr>
<tr class="separator:a3887317efcb79a36c06da495b30136fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f73d2001ac889b1d9883c5601e55f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#a42f73d2001ac889b1d9883c5601e55f8">svn_subst_build_keywords2</a> (apr_hash_t **kw, const char *keywords_string, const char *rev, const char *url, apr_time_t date, const char *author, apr_pool_t *pool)</td></tr>
<tr class="memdesc:a42f73d2001ac889b1d9883c5601e55f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="svn__subst_8h.html#a3887317efcb79a36c06da495b30136fd" title="Set *kw to a new keywords hash filled with the appropriate contents given a keywords_string (the cont...">svn_subst_build_keywords3()</a> except that it does not accept the <em>repos_root_url</em> parameter and hence supports less substitutions, and also does not support custom keyword definitions.  <a href="#a42f73d2001ac889b1d9883c5601e55f8">More...</a><br/></td></tr>
<tr class="separator:a42f73d2001ac889b1d9883c5601e55f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab004042c7b9a26349d68d625128041c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#ab004042c7b9a26349d68d625128041c8">svn_subst_build_keywords</a> (<a class="el" href="structsvn__subst__keywords__t.html">svn_subst_keywords_t</a> *kw, const char *keywords_string, const char *rev, const char *url, apr_time_t date, const char *author, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ab004042c7b9a26349d68d625128041c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="svn__subst_8h.html#a42f73d2001ac889b1d9883c5601e55f8" title="Similar to svn_subst_build_keywords3() except that it does not accept the repos_root_url parameter an...">svn_subst_build_keywords2()</a> except that it populates an existing structure <em>*kw</em> instead of creating a keywords hash.  <a href="#ab004042c7b9a26349d68d625128041c8">More...</a><br/></td></tr>
<tr class="separator:ab004042c7b9a26349d68d625128041c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1bd03f2381659cd0358dd74e7f882e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#ac1bd03f2381659cd0358dd74e7f882e5">svn_subst_keywords_differ2</a> (apr_hash_t *a, apr_hash_t *b, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> compare_values, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ac1bd03f2381659cd0358dd74e7f882e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>TRUE</code> if <em>a</em> and <em>b</em> do not hold the same keywords.  <a href="#ac1bd03f2381659cd0358dd74e7f882e5">More...</a><br/></td></tr>
<tr class="separator:ac1bd03f2381659cd0358dd74e7f882e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598cb9236b80298a904c4b8d7b5ab113"><td class="memItemLeft" align="right" valign="top"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#a598cb9236b80298a904c4b8d7b5ab113">svn_subst_keywords_differ</a> (const <a class="el" href="structsvn__subst__keywords__t.html">svn_subst_keywords_t</a> *a, const <a class="el" href="structsvn__subst__keywords__t.html">svn_subst_keywords_t</a> *b, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> compare_values)</td></tr>
<tr class="memdesc:a598cb9236b80298a904c4b8d7b5ab113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="svn__subst_8h.html#ac1bd03f2381659cd0358dd74e7f882e5" title="Return TRUE if a and b do not hold the same keywords. ">svn_subst_keywords_differ2()</a> except that it compares two <code><a class="el" href="structsvn__subst__keywords__t.html" title="Values used in keyword expansion. ">svn_subst_keywords_t</a></code> structs instead of keyword hashes.  <a href="#a598cb9236b80298a904c4b8d7b5ab113">More...</a><br/></td></tr>
<tr class="separator:a598cb9236b80298a904c4b8d7b5ab113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8055c67113fea26360d05820e91de8b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#a8055c67113fea26360d05820e91de8b1">svn_subst_translate_stream3</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *src_stream, <a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *dst_stream, const char *eol_str, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> repair, apr_hash_t *keywords, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> expand, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:a8055c67113fea26360d05820e91de8b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy and translate the data in <em>src_stream</em> into <em>dst_stream</em>.  <a href="#a8055c67113fea26360d05820e91de8b1">More...</a><br/></td></tr>
<tr class="separator:a8055c67113fea26360d05820e91de8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2918175c4dbeef269a8537aa33c5bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#a4b2918175c4dbeef269a8537aa33c5bb">svn_subst_translate_stream2</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *src_stream, <a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *dst_stream, const char *eol_str, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> repair, const <a class="el" href="structsvn__subst__keywords__t.html">svn_subst_keywords_t</a> *keywords, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> expand, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:a4b2918175c4dbeef269a8537aa33c5bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="svn__subst_8h.html#a8055c67113fea26360d05820e91de8b1" title="Copy and translate the data in src_stream into dst_stream. ">svn_subst_translate_stream3()</a> except relies upon a <code><a class="el" href="structsvn__subst__keywords__t.html" title="Values used in keyword expansion. ">svn_subst_keywords_t</a></code> struct instead of a hash for the keywords.  <a href="#a4b2918175c4dbeef269a8537aa33c5bb">More...</a><br/></td></tr>
<tr class="separator:a4b2918175c4dbeef269a8537aa33c5bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b349bf8cb380a0421327013e00d626"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#a81b349bf8cb380a0421327013e00d626">svn_subst_translate_stream</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *src_stream, <a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *dst_stream, const char *eol_str, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> repair, const <a class="el" href="structsvn__subst__keywords__t.html">svn_subst_keywords_t</a> *keywords, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> expand)</td></tr>
<tr class="memdesc:a81b349bf8cb380a0421327013e00d626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="svn__subst_8h.html#a4b2918175c4dbeef269a8537aa33c5bb" title="Similar to svn_subst_translate_stream3() except relies upon a svn_subst_keywords_t struct instead of ...">svn_subst_translate_stream2()</a>, but does not take a <em>pool</em> argument, instead creates a temporary subpool of the global pool, and destroys it before returning.  <a href="#a81b349bf8cb380a0421327013e00d626">More...</a><br/></td></tr>
<tr class="separator:a81b349bf8cb380a0421327013e00d626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dff1f4ae902e9d96a648b647545c559"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#a5dff1f4ae902e9d96a648b647545c559">svn_subst_stream_translated</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, const char *eol_str, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> repair, apr_hash_t *keywords, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> expand, apr_pool_t *result_pool)</td></tr>
<tr class="memdesc:a5dff1f4ae902e9d96a648b647545c559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a stream which performs eol translation and keyword expansion when read from or written to.  <a href="#a5dff1f4ae902e9d96a648b647545c559">More...</a><br/></td></tr>
<tr class="separator:a5dff1f4ae902e9d96a648b647545c559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f47ae70ef1b063543924891f3fb71d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#a4f47ae70ef1b063543924891f3fb71d6">svn_subst_stream_translated_to_normal_form</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **stream, <a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *source, <a class="el" href="svn__subst_8h.html#a82d6196808784a7a73e098f8d8534edb">svn_subst_eol_style_t</a> eol_style, const char *eol_str, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> always_repair_eols, apr_hash_t *keywords, apr_pool_t *pool)</td></tr>
<tr class="memdesc:a4f47ae70ef1b063543924891f3fb71d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*stream</em> to a stream which performs eol translation and keyword expansion when read from or written to.  <a href="#a4f47ae70ef1b063543924891f3fb71d6">More...</a><br/></td></tr>
<tr class="separator:a4f47ae70ef1b063543924891f3fb71d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e764bcb9bebd55a9679308d439cf35f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#a8e764bcb9bebd55a9679308d439cf35f">svn_subst_read_specialfile</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **stream, const char *path, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:a8e764bcb9bebd55a9679308d439cf35f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*stream</em> to a readable stream containing the "normal form" of the special file located at <em>path</em>.  <a href="#a8e764bcb9bebd55a9679308d439cf35f">More...</a><br/></td></tr>
<tr class="separator:a8e764bcb9bebd55a9679308d439cf35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc53c6941cb7760a87dc86e87dbe5741"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#adc53c6941cb7760a87dc86e87dbe5741">svn_subst_create_specialfile</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **stream, const char *path, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:adc53c6941cb7760a87dc86e87dbe5741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*stream</em> to a writable stream that accepts content in the "normal form" for a special file, to be located at <em>path</em>, and will create that file when the stream is closed.  <a href="#adc53c6941cb7760a87dc86e87dbe5741">More...</a><br/></td></tr>
<tr class="separator:adc53c6941cb7760a87dc86e87dbe5741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e5f664140910fecfce37994ba949dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#ae4e5f664140910fecfce37994ba949dc">svn_subst_stream_from_specialfile</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **stream, const char *path, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ae4e5f664140910fecfce37994ba949dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*stream</em> to a stream which translates the special file at <em>path</em> to the internal representation for special files when read from.  <a href="#ae4e5f664140910fecfce37994ba949dc">More...</a><br/></td></tr>
<tr class="separator:ae4e5f664140910fecfce37994ba949dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae011aa19ef5cae54c604b61ca40a16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#a8ae011aa19ef5cae54c604b61ca40a16">svn_subst_copy_and_translate4</a> (const char *src, const char *dst, const char *eol_str, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> repair, apr_hash_t *keywords, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> expand, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> special, <a class="el" href="svn__types_8h.html#addaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a> cancel_func, void *cancel_baton, apr_pool_t *pool)</td></tr>
<tr class="memdesc:a8ae011aa19ef5cae54c604b61ca40a16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of file-path <em>src</em> to file-path <em>dst</em> atomically, either creating <em>dst</em> or overwriting <em>dst</em> if it exists, possibly performing line ending and keyword translations.  <a href="#a8ae011aa19ef5cae54c604b61ca40a16">More...</a><br/></td></tr>
<tr class="separator:a8ae011aa19ef5cae54c604b61ca40a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18dbb80be4ef26b2a978454716539d0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#a18dbb80be4ef26b2a978454716539d0c">svn_subst_copy_and_translate3</a> (const char *src, const char *dst, const char *eol_str, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> repair, apr_hash_t *keywords, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> expand, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> special, apr_pool_t *pool)</td></tr>
<tr class="memdesc:a18dbb80be4ef26b2a978454716539d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="svn__subst_8h.html#a8ae011aa19ef5cae54c604b61ca40a16" title="Copy the contents of file-path src to file-path dst atomically, either creating dst or overwriting ds...">svn_subst_copy_and_translate4()</a> but without a cancellation function and baton.  <a href="#a18dbb80be4ef26b2a978454716539d0c">More...</a><br/></td></tr>
<tr class="separator:a18dbb80be4ef26b2a978454716539d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bbccf6a71c3e07a112e1e44f9ecec98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#a9bbccf6a71c3e07a112e1e44f9ecec98">svn_subst_copy_and_translate2</a> (const char *src, const char *dst, const char *eol_str, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> repair, const <a class="el" href="structsvn__subst__keywords__t.html">svn_subst_keywords_t</a> *keywords, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> expand, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> special, apr_pool_t *pool)</td></tr>
<tr class="memdesc:a9bbccf6a71c3e07a112e1e44f9ecec98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="svn__subst_8h.html#a18dbb80be4ef26b2a978454716539d0c" title="Similar to svn_subst_copy_and_translate4() but without a cancellation function and baton...">svn_subst_copy_and_translate3()</a> except that <em>keywords</em> is a <code><a class="el" href="structsvn__subst__keywords__t.html" title="Values used in keyword expansion. ">svn_subst_keywords_t</a></code> struct instead of a keywords hash.  <a href="#a9bbccf6a71c3e07a112e1e44f9ecec98">More...</a><br/></td></tr>
<tr class="separator:a9bbccf6a71c3e07a112e1e44f9ecec98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9dfe3fade520c1ca5b1edbe50989658"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#aa9dfe3fade520c1ca5b1edbe50989658">svn_subst_copy_and_translate</a> (const char *src, const char *dst, const char *eol_str, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> repair, const <a class="el" href="structsvn__subst__keywords__t.html">svn_subst_keywords_t</a> *keywords, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> expand, apr_pool_t *pool)</td></tr>
<tr class="memdesc:aa9dfe3fade520c1ca5b1edbe50989658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="svn__subst_8h.html#a9bbccf6a71c3e07a112e1e44f9ecec98" title="Similar to svn_subst_copy_and_translate3() except that keywords is a svn_subst_keywords_t struct inst...">svn_subst_copy_and_translate2()</a> except that <em>special</em> is always set to <code>FALSE</code>.  <a href="#aa9dfe3fade520c1ca5b1edbe50989658">More...</a><br/></td></tr>
<tr class="separator:aa9dfe3fade520c1ca5b1edbe50989658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9030b641b1ef299e68c35670014ea747"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#a9030b641b1ef299e68c35670014ea747">svn_subst_translate_cstring2</a> (const char *src, const char **dst, const char *eol_str, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> repair, apr_hash_t *keywords, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> expand, apr_pool_t *pool)</td></tr>
<tr class="memdesc:a9030b641b1ef299e68c35670014ea747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*dst</em> to a copy of the string <em>src</em>, possibly performing line ending and keyword translations.  <a href="#a9030b641b1ef299e68c35670014ea747">More...</a><br/></td></tr>
<tr class="separator:a9030b641b1ef299e68c35670014ea747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1b28fcddc78254ca6b6ed4ad149b89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#aab1b28fcddc78254ca6b6ed4ad149b89">svn_subst_translate_cstring</a> (const char *src, const char **dst, const char *eol_str, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> repair, const <a class="el" href="structsvn__subst__keywords__t.html">svn_subst_keywords_t</a> *keywords, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> expand, apr_pool_t *pool)</td></tr>
<tr class="memdesc:aab1b28fcddc78254ca6b6ed4ad149b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="svn__subst_8h.html#a9030b641b1ef299e68c35670014ea747" title="Set *dst to a copy of the string src, possibly performing line ending and keyword translations...">svn_subst_translate_cstring2()</a> except that <em>keywords</em> is a <code><a class="el" href="structsvn__subst__keywords__t.html" title="Values used in keyword expansion. ">svn_subst_keywords_t</a></code> struct instead of a keywords hash.  <a href="#aab1b28fcddc78254ca6b6ed4ad149b89">More...</a><br/></td></tr>
<tr class="separator:aab1b28fcddc78254ca6b6ed4ad149b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace41f93ffd67e19f15cc705a855e8a98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#ace41f93ffd67e19f15cc705a855e8a98">svn_subst_translate_to_normal_form</a> (const char *src, const char *dst, <a class="el" href="svn__subst_8h.html#a82d6196808784a7a73e098f8d8534edb">svn_subst_eol_style_t</a> eol_style, const char *eol_str, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> always_repair_eols, apr_hash_t *keywords, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> special, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ace41f93ffd67e19f15cc705a855e8a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate the file <em>src</em> in working copy form to a file <em>dst</em> in normal form.  <a href="#ace41f93ffd67e19f15cc705a855e8a98">More...</a><br/></td></tr>
<tr class="separator:ace41f93ffd67e19f15cc705a855e8a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9174c224c4fc71aaba0d2b9e93482df6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#a9174c224c4fc71aaba0d2b9e93482df6">svn_subst_stream_detranslated</a> (<a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **stream_p, const char *src, <a class="el" href="svn__subst_8h.html#a82d6196808784a7a73e098f8d8534edb">svn_subst_eol_style_t</a> eol_style, const char *eol_str, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> always_repair_eols, apr_hash_t *keywords, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> special, apr_pool_t *pool)</td></tr>
<tr class="memdesc:a9174c224c4fc71aaba0d2b9e93482df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*stream_p</em> to a stream that detranslates the file <em>src</em> from working copy form to normal form, allocated in <em>pool</em>.  <a href="#a9174c224c4fc71aaba0d2b9e93482df6">More...</a><br/></td></tr>
<tr class="separator:a9174c224c4fc71aaba0d2b9e93482df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2cf0f290bfe975e4ef8400eaa9e0add"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#af2cf0f290bfe975e4ef8400eaa9e0add">svn_subst_translate_string2</a> (<a class="el" href="structsvn__string__t.html">svn_string_t</a> **new_value, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *translated_to_utf8, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *translated_line_endings, const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *value, const char *encoding, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> repair, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:af2cf0f290bfe975e4ef8400eaa9e0add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate the string <em>value</em> from character encoding <em>encoding</em> to UTF8, and also from its current line-ending style to LF line-endings.  <a href="#af2cf0f290bfe975e4ef8400eaa9e0add">More...</a><br/></td></tr>
<tr class="separator:af2cf0f290bfe975e4ef8400eaa9e0add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626c5dcfbbf5057ebc0e384187f6d330"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#a626c5dcfbbf5057ebc0e384187f6d330">svn_subst_translate_string</a> (<a class="el" href="structsvn__string__t.html">svn_string_t</a> **new_value, const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *value, const char *encoding, apr_pool_t *pool)</td></tr>
<tr class="memdesc:a626c5dcfbbf5057ebc0e384187f6d330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="svn__subst_8h.html#af2cf0f290bfe975e4ef8400eaa9e0add" title="Translate the string value from character encoding encoding to UTF8, and also from its current line-e...">svn_subst_translate_string2()</a>, except that the information about whether re-encoding or line ending translation were performed is discarded.  <a href="#a626c5dcfbbf5057ebc0e384187f6d330">More...</a><br/></td></tr>
<tr class="separator:a626c5dcfbbf5057ebc0e384187f6d330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0510e7ebae885c80b227ccc3a13685"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#a7b0510e7ebae885c80b227ccc3a13685">svn_subst_detranslate_string</a> (<a class="el" href="structsvn__string__t.html">svn_string_t</a> **new_value, const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *value, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> for_output, apr_pool_t *pool)</td></tr>
<tr class="memdesc:a7b0510e7ebae885c80b227ccc3a13685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate the string <em>value</em> from UTF8 and LF line-endings into native character encoding and native line-endings.  <a href="#a7b0510e7ebae885c80b227ccc3a13685">More...</a><br/></td></tr>
<tr class="separator:a7b0510e7ebae885c80b227ccc3a13685"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Data substitution (keywords and EOL style) </p>

<p>Definition in file <a class="el" href="svn__subst_8h_source.html">svn_subst.h</a>.</p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a82d6196808784a7a73e098f8d8534edb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="svn__subst_8h.html#a160543c34edb8318de8cbe4543bbca28">svn_subst_eol_style</a>  <a class="el" href="svn__subst_8h.html#a82d6196808784a7a73e098f8d8534edb">svn_subst_eol_style_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Valid states for 'svn:eol-style' property. </p>
<p>Property nonexistence is equivalent to 'none'. </p>

</div>
</div>
<a class="anchor" id="a23f86ade6d1361383d284d423bd333ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structsvn__subst__keywords__t.html">svn_subst_keywords_t</a>  <a class="el" href="structsvn__subst__keywords__t.html">svn_subst_keywords_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Values used in keyword expansion. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000383">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.2 API. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a160543c34edb8318de8cbe4543bbca28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="svn__subst_8h.html#a160543c34edb8318de8cbe4543bbca28">svn_subst_eol_style</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Valid states for 'svn:eol-style' property. </p>
<p>Property nonexistence is equivalent to 'none'. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a160543c34edb8318de8cbe4543bbca28a6e1bf631a8574e3cf1e52b6599785fdf"></a>svn_subst_eol_style_unknown</em>&nbsp;</td><td class="fielddoc">
<p>An unrecognized style. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a160543c34edb8318de8cbe4543bbca28ac33cc2b19c97a910b90d4efef275043f"></a>svn_subst_eol_style_none</em>&nbsp;</td><td class="fielddoc">
<p>EOL translation is "off" or ignored value. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a160543c34edb8318de8cbe4543bbca28a2fdd9ef5ba015f6ecc6d59458df5c055"></a>svn_subst_eol_style_native</em>&nbsp;</td><td class="fielddoc">
<p>Translation is set to client's native eol. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a160543c34edb8318de8cbe4543bbca28a6e778790cbc23c4028f73aaaf5524069"></a>svn_subst_eol_style_fixed</em>&nbsp;</td><td class="fielddoc">
<p>Translation is set to one of LF, CR, CRLF. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="svn__subst_8h_source.html#l00053">53</a> of file <a class="el" href="svn__subst_8h_source.html">svn_subst.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ab004042c7b9a26349d68d625128041c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_subst_build_keywords </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__subst__keywords__t.html">svn_subst_keywords_t</a> *&#160;</td>
          <td class="paramname"><em>kw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>keywords_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_time_t&#160;</td>
          <td class="paramname"><em>date</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>author</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="svn__subst_8h.html#a42f73d2001ac889b1d9883c5601e55f8" title="Similar to svn_subst_build_keywords3() except that it does not accept the repos_root_url parameter an...">svn_subst_build_keywords2()</a> except that it populates an existing structure <em>*kw</em> instead of creating a keywords hash. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000385">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.2 API. </dd></dl>

</div>
</div>
<a class="anchor" id="a42f73d2001ac889b1d9883c5601e55f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_subst_build_keywords2 </td>
          <td>(</td>
          <td class="paramtype">apr_hash_t **&#160;</td>
          <td class="paramname"><em>kw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>keywords_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_time_t&#160;</td>
          <td class="paramname"><em>date</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>author</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="svn__subst_8h.html#a3887317efcb79a36c06da495b30136fd" title="Set *kw to a new keywords hash filled with the appropriate contents given a keywords_string (the cont...">svn_subst_build_keywords3()</a> except that it does not accept the <em>repos_root_url</em> parameter and hence supports less substitutions, and also does not support custom keyword definitions. </p>
<dl class="section since"><dt>Since</dt><dd>New in 1.3. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000384">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.7 API. </dd></dl>

</div>
</div>
<a class="anchor" id="a3887317efcb79a36c06da495b30136fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_subst_build_keywords3 </td>
          <td>(</td>
          <td class="paramtype">apr_hash_t **&#160;</td>
          <td class="paramname"><em>kw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>keywords_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>repos_root_url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_time_t&#160;</td>
          <td class="paramname"><em>date</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>author</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>*kw</em> to a new keywords hash filled with the appropriate contents given a <em>keywords_string</em> (the contents of the svn:keywords property for the file in question), the revision <em>rev</em>, the <em>url</em>, the <em>date</em> the file was committed on, the <em>author</em> of the last commit, and the URL of the repository root <em>repos_root_url</em>. </p>
<p>Custom keywords defined in svn:keywords properties are expanded using the provided parameters and in accordance with the following format substitutions in the <em>keywords_string:</em> a - The author. b - The basename of the URL. d - Short format of the date. D - Long format of the date. P - The file's path, relative to the repository root URL. r - The revision. R - The URL to the root of the repository. u - The URL of the file. _ - A space (keyword definitions cannot contain a literal space). %% - A literal ''. H - Equivalent to P_r_d_a. I - Equivalent to b_r_d_a.</p>
<p>Custom keywords are defined by appending '=' to the keyword name, followed by a string containing any combination of the format substitutions.</p>
<p>Any of the inputs <em>rev</em>, <em>url</em>, <em>date</em>, <em>author</em>, and <em>repos_root_url</em> can be <code>NULL</code>, or <code>0</code> for <em>date</em>, to indicate that the information is not present. Each piece of information that is not present expands to the empty string wherever it appears in an expanded keyword value. (This can result in multiple adjacent spaces in the expansion of a multi-valued keyword such as "Id".)</p>
<p>Hash keys are of type <code>const char *</code>. Hash values are of type <code><a class="el" href="structsvn__string__t.html" title="A simple counted string. ">svn_string_t</a> *</code>.</p>
<p>All memory is allocated out of <em>pool</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.8. </dd></dl>

</div>
</div>
<a class="anchor" id="aa9dfe3fade520c1ca5b1edbe50989658"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_subst_copy_and_translate </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>eol_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>repair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsvn__subst__keywords__t.html">svn_subst_keywords_t</a> *&#160;</td>
          <td class="paramname"><em>keywords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>expand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="svn__subst_8h.html#a9bbccf6a71c3e07a112e1e44f9ecec98" title="Similar to svn_subst_copy_and_translate3() except that keywords is a svn_subst_keywords_t struct inst...">svn_subst_copy_and_translate2()</a> except that <em>special</em> is always set to <code>FALSE</code>. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000394">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.0 API. </dd></dl>

</div>
</div>
<a class="anchor" id="a9bbccf6a71c3e07a112e1e44f9ecec98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_subst_copy_and_translate2 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>eol_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>repair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsvn__subst__keywords__t.html">svn_subst_keywords_t</a> *&#160;</td>
          <td class="paramname"><em>keywords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>expand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>special</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="svn__subst_8h.html#a18dbb80be4ef26b2a978454716539d0c" title="Similar to svn_subst_copy_and_translate4() but without a cancellation function and baton...">svn_subst_copy_and_translate3()</a> except that <em>keywords</em> is a <code><a class="el" href="structsvn__subst__keywords__t.html" title="Values used in keyword expansion. ">svn_subst_keywords_t</a></code> struct instead of a keywords hash. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000393">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.2 API. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.1. </dd></dl>

</div>
</div>
<a class="anchor" id="a18dbb80be4ef26b2a978454716539d0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_subst_copy_and_translate3 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>eol_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>repair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_hash_t *&#160;</td>
          <td class="paramname"><em>keywords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>expand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>special</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="svn__subst_8h.html#a8ae011aa19ef5cae54c604b61ca40a16" title="Copy the contents of file-path src to file-path dst atomically, either creating dst or overwriting ds...">svn_subst_copy_and_translate4()</a> but without a cancellation function and baton. </p>
<dl class="section since"><dt>Since</dt><dd>New in 1.3. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000392">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.6 API. </dd></dl>

</div>
</div>
<a class="anchor" id="a8ae011aa19ef5cae54c604b61ca40a16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_subst_copy_and_translate4 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>eol_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>repair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_hash_t *&#160;</td>
          <td class="paramname"><em>keywords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>expand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>special</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#addaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a>&#160;</td>
          <td class="paramname"><em>cancel_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cancel_baton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the contents of file-path <em>src</em> to file-path <em>dst</em> atomically, either creating <em>dst</em> or overwriting <em>dst</em> if it exists, possibly performing line ending and keyword translations. </p>
<p>The parameters <em>*eol_str</em>, <em>repair</em>, <em>*keywords</em> and <em>expand</em> are defined the same as in <a class="el" href="svn__subst_8h.html#a8055c67113fea26360d05820e91de8b1" title="Copy and translate the data in src_stream into dst_stream. ">svn_subst_translate_stream3()</a>.</p>
<p>In addition, it will create a special file from normal form or translate one to normal form if <em>special</em> is <code>TRUE</code>.</p>
<p>If anything goes wrong during the copy, attempt to delete <em>dst</em> (if it exists).</p>
<p>If <em>eol_str</em> and <em>keywords</em> are <code>NULL</code>, behavior is just a byte-for-byte copy.</p>
<p><em>cancel_func</em> and <em>cancel_baton</em> will be called (if not NULL) periodically to check for cancellation.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="adc53c6941cb7760a87dc86e87dbe5741"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_subst_create_specialfile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>*stream</em> to a writable stream that accepts content in the "normal form" for a special file, to be located at <em>path</em>, and will create that file when the stream is closed. </p>
<p>The stream will be allocated in <em>result_pool</em>, and any temporary allocations will be made in <em>scratch_pool</em>.</p>
<p>If the platform does not support the semantics of the special file, write a regular file containing the "normal form" text. This enables special files to be written and read on platforms that do not treat them as special.</p>
<p>Note: the target file is created in a temporary location, then renamed into position, so the creation can be considered "atomic".</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a class="anchor" id="a7b0510e7ebae885c80b227ccc3a13685"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_subst_detranslate_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__string__t.html">svn_string_t</a> **&#160;</td>
          <td class="paramname"><em>new_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>for_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate the string <em>value</em> from UTF8 and LF line-endings into native character encoding and native line-endings. </p>
<p>If <em>for_output</em> is TRUE, translate to the character encoding of the output locale, else to that of the default locale.</p>
<p>Set <em>*new_value</em> to the translated string, allocated in <em>pool</em>. </p>

</div>
</div>
<a class="anchor" id="adee8f25af905f8a450092b61ba79ea5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_subst_eol_style_from_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__subst_8h.html#a82d6196808784a7a73e098f8d8534edb">svn_subst_eol_style_t</a> *&#160;</td>
          <td class="paramname"><em>style</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>eol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>*style</em> to the appropriate <code>svn_subst_eol_style_t</code> and <em>*eol</em> to the appropriate cstring for a given svn:eol-style property value. </p>
<p>Set <em>*eol</em> to</p>
<ul>
<li><code>NULL</code> for <code>svn_subst_eol_style_none</code>, or</li>
<li>a NULL-terminated C string containing the native eol marker for this platform, for <code>svn_subst_eol_style_native</code>, or</li>
<li>a NULL-terminated C string containing the eol marker indicated by the property value, for <code>svn_subst_eol_style_fixed</code>.</li>
</ul>
<p>If <em>*style</em> is NULL, it is ignored. </p>

</div>
</div>
<a class="anchor" id="a598cb9236b80298a904c4b8d7b5ab113"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> svn_subst_keywords_differ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsvn__subst__keywords__t.html">svn_subst_keywords_t</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsvn__subst__keywords__t.html">svn_subst_keywords_t</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>compare_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="svn__subst_8h.html#ac1bd03f2381659cd0358dd74e7f882e5" title="Return TRUE if a and b do not hold the same keywords. ">svn_subst_keywords_differ2()</a> except that it compares two <code><a class="el" href="structsvn__subst__keywords__t.html" title="Values used in keyword expansion. ">svn_subst_keywords_t</a></code> structs instead of keyword hashes. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000386">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.2 API. </dd></dl>

</div>
</div>
<a class="anchor" id="ac1bd03f2381659cd0358dd74e7f882e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> svn_subst_keywords_differ2 </td>
          <td>(</td>
          <td class="paramtype">apr_hash_t *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_hash_t *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>compare_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>TRUE</code> if <em>a</em> and <em>b</em> do not hold the same keywords. </p>
<p><em>a</em> and <em>b</em> are hashes of the form produced by <a class="el" href="svn__subst_8h.html#a42f73d2001ac889b1d9883c5601e55f8" title="Similar to svn_subst_build_keywords3() except that it does not accept the repos_root_url parameter an...">svn_subst_build_keywords2()</a>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.3.</dd></dl>
<p>If <em>compare_values</em> is <code>TRUE</code>, "same" means that the <em>a</em> and <em>b</em> contain exactly the same set of keywords, and the values of corresponding keywords match as well. Else if <em>compare_values</em> is <code>FALSE</code>, then "same" merely means that <em>a</em> and <em>b</em> hold the same set of keywords, although those keywords' values might differ.</p>
<p><em>a</em> and/or <em>b</em> may be <code>NULL</code>; for purposes of comparison, <code>NULL</code> is equivalent to holding no keywords. </p>

</div>
</div>
<a class="anchor" id="a8e764bcb9bebd55a9679308d439cf35f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_subst_read_specialfile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>*stream</em> to a readable stream containing the "normal form" of the special file located at <em>path</em>. </p>
<p>The stream will be allocated in <em>result_pool</em>, and any temporary allocations will be made in <em>scratch_pool</em>.</p>
<p>If the file at <em>path</em> is in fact a regular file, just read its content, which should be in the "normal form" for a special file. This enables special files to be written and read on platforms that do not treat them as special.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a class="anchor" id="a9174c224c4fc71aaba0d2b9e93482df6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_subst_stream_detranslated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **&#160;</td>
          <td class="paramname"><em>stream_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__subst_8h.html#a82d6196808784a7a73e098f8d8534edb">svn_subst_eol_style_t</a>&#160;</td>
          <td class="paramname"><em>eol_style</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>eol_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>always_repair_eols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_hash_t *&#160;</td>
          <td class="paramname"><em>keywords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>special</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>*stream_p</em> to a stream that detranslates the file <em>src</em> from working copy form to normal form, allocated in <em>pool</em>. </p>
<p>The values specified for <em>eol_style</em>, <em>*eol_str</em>, <em>keywords</em> and <em>special</em>, should be the ones used to translate the file to its working copy form. Usually, these are the values specified by the user in the files' properties.</p>
<p>Inconsistent line endings in the file will be automatically repaired (made consistent) for some eol styles. For all others, an error is returned. By setting <em>always_repair_eols</em> to <code>TRUE</code>, eols will be made consistent even for those styles which don't have it by default.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.4.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000397">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.5 API. Use svn_subst_stream_from_specialfile if the source is special; otherwise, use svn_subst_stream_translated_to_normal_form. </dd></dl>

</div>
</div>
<a class="anchor" id="ae4e5f664140910fecfce37994ba949dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_subst_stream_from_specialfile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>*stream</em> to a stream which translates the special file at <em>path</em> to the internal representation for special files when read from. </p>
<p>When written to, it does the reverse: creating a special file when the stream is closed.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.5.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000391">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.5 API. Callers should use svn_subst_read_specialfile or svn_subst_create_specialfile as appropriate. </dd></dl>

</div>
</div>
<a class="anchor" id="a5dff1f4ae902e9d96a648b647545c559"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>* svn_subst_stream_translated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>eol_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>repair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_hash_t *&#160;</td>
          <td class="paramname"><em>keywords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>expand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a stream which performs eol translation and keyword expansion when read from or written to. </p>
<p>The stream <em>stream</em> is used to read and write all data.</p>
<p>Make sure you call <a class="el" href="group__svn__io__byte__streams.html#ga7d9cdab4d5d8707d59a1b1d3dab95bb4" title="Close a generic stream. ">svn_stream_close()</a> on the returned stream to ensure all data is flushed and cleaned up (this will also close the provided <em>stream</em>).</p>
<p>Read operations from and write operations to the stream perform the same operation: if <em>expand</em> is <code>FALSE</code>, both contract keywords. One stream supports both read and write operations. Reads and writes may be mixed.</p>
<p>If <em>eol_str</em> is non-<code>NULL</code>, replace whatever bytestring the input uses to denote line endings with <em>eol_str</em> in the output. If the input has an inconsistent line ending style, then: if <em>repair</em> is <code>FALSE</code>, then a subsequent read, write or other operation on the stream will return <code>SVN_ERR_IO_INCONSISTENT_EOL</code> when the inconsistency is detected, else if <em>repair</em> is <code>TRUE</code>, convert any line ending to <em>eol_str</em>. Recognized line endings are: "\n", "\r", and "\r\n".</p>
<p>Expand and contract keywords using the contents of <em>keywords</em> as the new values. If <em>expand</em> is <code>TRUE</code>, expand contracted keywords and re-expand expanded keywords. If <em>expand</em> is <code>FALSE</code>, contract expanded keywords and ignore contracted ones. Keywords not found in the hash are ignored (not contracted or expanded). If the <em>keywords</em> hash itself is <code>NULL</code>, keyword substitution will be altogether ignored.</p>
<p>Detect only keywords that are no longer than <code>SVN_KEYWORD_MAX_LEN</code> bytes, including the delimiters and the keyword itself.</p>
<p>Recommendation: if <em>expand</em> is FALSE, then you don't care about the keyword values, so use empty strings as non-NULL signifiers when you build the keywords hash.</p>
<p>The stream returned is allocated in <em>result_pool</em>.</p>
<p>If the inner stream implements resetting via <a class="el" href="group__svn__io__byte__streams.html#gac7574ccd5c0f60779bdaef7f5b44febd" title="Reset a generic stream back to its origin. ">svn_stream_reset()</a>, or marking and seeking via <a class="el" href="group__svn__io__byte__streams.html#ga47c17fbf09effd084d6b426d18175942" title="Set a mark at the current position of a generic stream, which can later be sought back to using svn_s...">svn_stream_mark()</a> and <a class="el" href="group__svn__io__byte__streams.html#ga1cb32df4e14164a911490bae5e58e99e" title="Seek to a mark in a generic stream. ">svn_stream_seek()</a>, the translated stream will too.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.4. </dd></dl>

</div>
</div>
<a class="anchor" id="a4f47ae70ef1b063543924891f3fb71d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_subst_stream_translated_to_normal_form </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__subst_8h.html#a82d6196808784a7a73e098f8d8534edb">svn_subst_eol_style_t</a>&#160;</td>
          <td class="paramname"><em>eol_style</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>eol_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>always_repair_eols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_hash_t *&#160;</td>
          <td class="paramname"><em>keywords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>*stream</em> to a stream which performs eol translation and keyword expansion when read from or written to. </p>
<p>The stream <em>source</em> is used to read and write all data. Make sure you call <a class="el" href="group__svn__io__byte__streams.html#ga7d9cdab4d5d8707d59a1b1d3dab95bb4" title="Close a generic stream. ">svn_stream_close()</a> on <em>stream</em> to make sure all data are flushed and cleaned up.</p>
<p>When <em>stream</em> is closed, then <em>source</em> will be closed.</p>
<p>Read and write operations perform the same transformation: all data is translated to normal form.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="svn__subst_8h.html#ace41f93ffd67e19f15cc705a855e8a98" title="Translate the file src in working copy form to a file dst in normal form. ">svn_subst_translate_to_normal_form()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.5. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000390">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.5 API. </dd></dl>

</div>
</div>
<a class="anchor" id="aab1b28fcddc78254ca6b6ed4ad149b89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_subst_translate_cstring </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>eol_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>repair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsvn__subst__keywords__t.html">svn_subst_keywords_t</a> *&#160;</td>
          <td class="paramname"><em>keywords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>expand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="svn__subst_8h.html#a9030b641b1ef299e68c35670014ea747" title="Set *dst to a copy of the string src, possibly performing line ending and keyword translations...">svn_subst_translate_cstring2()</a> except that <em>keywords</em> is a <code><a class="el" href="structsvn__subst__keywords__t.html" title="Values used in keyword expansion. ">svn_subst_keywords_t</a></code> struct instead of a keywords hash. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000395">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.2 API. </dd></dl>

</div>
</div>
<a class="anchor" id="a9030b641b1ef299e68c35670014ea747"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_subst_translate_cstring2 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>eol_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>repair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_hash_t *&#160;</td>
          <td class="paramname"><em>keywords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>expand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>*dst</em> to a copy of the string <em>src</em>, possibly performing line ending and keyword translations. </p>
<p>This is a variant of <a class="el" href="svn__subst_8h.html#a8055c67113fea26360d05820e91de8b1" title="Copy and translate the data in src_stream into dst_stream. ">svn_subst_translate_stream3()</a> that operates on cstrings. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="svn__subst_8h.html#a5dff1f4ae902e9d96a648b647545c559" title="Return a stream which performs eol translation and keyword expansion when read from or written to...">svn_subst_stream_translated()</a> for details of the translation and of <em>eol_str</em>, <em>repair</em>, <em>keywords</em> and <em>expand</em>.</dd></dl>
<p>If <em>eol_str</em> and <em>keywords</em> are <code>NULL</code>, behavior is just a byte-for-byte copy.</p>
<p>Allocate <em>*dst</em> in <em>pool</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.3. </dd></dl>

</div>
</div>
<a class="anchor" id="a81b349bf8cb380a0421327013e00d626"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_subst_translate_stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>src_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>dst_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>eol_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>repair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsvn__subst__keywords__t.html">svn_subst_keywords_t</a> *&#160;</td>
          <td class="paramname"><em>keywords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>expand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="svn__subst_8h.html#a4b2918175c4dbeef269a8537aa33c5bb" title="Similar to svn_subst_translate_stream3() except relies upon a svn_subst_keywords_t struct instead of ...">svn_subst_translate_stream2()</a>, but does not take a <em>pool</em> argument, instead creates a temporary subpool of the global pool, and destroys it before returning. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000389">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.1 API. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b2918175c4dbeef269a8537aa33c5bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_subst_translate_stream2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>src_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>dst_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>eol_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>repair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsvn__subst__keywords__t.html">svn_subst_keywords_t</a> *&#160;</td>
          <td class="paramname"><em>keywords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>expand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="svn__subst_8h.html#a8055c67113fea26360d05820e91de8b1" title="Copy and translate the data in src_stream into dst_stream. ">svn_subst_translate_stream3()</a> except relies upon a <code><a class="el" href="structsvn__subst__keywords__t.html" title="Values used in keyword expansion. ">svn_subst_keywords_t</a></code> struct instead of a hash for the keywords. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000388">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.2 API. </dd></dl>

</div>
</div>
<a class="anchor" id="a8055c67113fea26360d05820e91de8b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_subst_translate_stream3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>src_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#ga06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&#160;</td>
          <td class="paramname"><em>dst_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>eol_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>repair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_hash_t *&#160;</td>
          <td class="paramname"><em>keywords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>expand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy and translate the data in <em>src_stream</em> into <em>dst_stream</em>. </p>
<p>It is assumed that <em>src_stream</em> is a readable stream and <em>dst_stream</em> is a writable stream.</p>
<p>If <em>eol_str</em> is non-<code>NULL</code>, replace whatever bytestring <em>src_stream</em> uses to denote line endings with <em>eol_str</em> in the output. If <em>src_stream</em> has an inconsistent line ending style, then: if <em>repair</em> is <code>FALSE</code>, return <code>SVN_ERR_IO_INCONSISTENT_EOL</code>, else if <em>repair</em> is <code>TRUE</code>, convert any line ending in <em>src_stream</em> to <em>eol_str</em> in <em>dst_stream</em>. Recognized line endings are: "\n", "\r", and "\r\n".</p>
<p>See <a class="el" href="svn__subst_8h.html#a5dff1f4ae902e9d96a648b647545c559" title="Return a stream which performs eol translation and keyword expansion when read from or written to...">svn_subst_stream_translated()</a> for details of the keyword substitution which is controlled by the <em>expand</em> and <em>keywords</em> parameters.</p>
<p>Note that a translation request is <em>required</em>: one of <em>eol_str</em> or <em>keywords</em> must be non-<code>NULL</code>.</p>
<p>Notes:</p>
<p>See svn_wc__get_keywords() and svn_wc__get_eol_style() for a convenient way to get <em>eol_str</em> and <em>keywords</em> if in libsvn_wc.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.3.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000387">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.5 API. Callers should use <a class="el" href="svn__subst_8h.html#a5dff1f4ae902e9d96a648b647545c559" title="Return a stream which performs eol translation and keyword expansion when read from or written to...">svn_subst_stream_translated()</a> instead. </dd></dl>

</div>
</div>
<a class="anchor" id="a626c5dcfbbf5057ebc0e384187f6d330"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_subst_translate_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__string__t.html">svn_string_t</a> **&#160;</td>
          <td class="paramname"><em>new_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>encoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="svn__subst_8h.html#af2cf0f290bfe975e4ef8400eaa9e0add" title="Translate the string value from character encoding encoding to UTF8, and also from its current line-e...">svn_subst_translate_string2()</a>, except that the information about whether re-encoding or line ending translation were performed is discarded. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000398">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.6 API. </dd></dl>

</div>
</div>
<a class="anchor" id="af2cf0f290bfe975e4ef8400eaa9e0add"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_subst_translate_string2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__string__t.html">svn_string_t</a> **&#160;</td>
          <td class="paramname"><em>new_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *&#160;</td>
          <td class="paramname"><em>translated_to_utf8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *&#160;</td>
          <td class="paramname"><em>translated_line_endings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>encoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>repair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate the string <em>value</em> from character encoding <em>encoding</em> to UTF8, and also from its current line-ending style to LF line-endings. </p>
<p>If <em>encoding</em> is <code>NULL</code>, translate from the system-default encoding.</p>
<p>If <em>translated_to_utf8</em> is not <code>NULL</code>, then set <em>*translated_to_utf8</em> to <code>TRUE</code> if at least one character of <em>value</em> in the source character encoding was translated to UTF-8, or to <code>FALSE</code> otherwise.</p>
<p>If <em>translated_line_endings</em> is not <code>NULL</code>, then set <em>*translated_line_endings</em> to <code>TRUE</code> if at least one line ending was changed to LF, or to <code>FALSE</code> otherwise.</p>
<p>If <em>value</em> has an inconsistent line ending style, then: if <em>repair</em> is <code>FALSE</code>, return <code>SVN_ERR_IO_INCONSISTENT_EOL</code>, else if <em>repair</em> is <code>TRUE</code>, convert any line ending in <em>value</em> to "\n" in <em>*new_value</em>. Recognized line endings are: "\n", "\r", and "\r\n".</p>
<p>Set <em>*new_value</em> to the translated string, allocated in <em>result_pool</em>.</p>
<p><em>scratch_pool</em> is used for temporary allocations.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="ace41f93ffd67e19f15cc705a855e8a98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_subst_translate_to_normal_form </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__subst_8h.html#a82d6196808784a7a73e098f8d8534edb">svn_subst_eol_style_t</a>&#160;</td>
          <td class="paramname"><em>eol_style</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>eol_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>always_repair_eols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_hash_t *&#160;</td>
          <td class="paramname"><em>keywords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>special</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate the file <em>src</em> in working copy form to a file <em>dst</em> in normal form. </p>
<p>The values specified for <em>eol_style</em>, <em>*eol_str</em>, <em>keywords</em> and <em>special</em>, should be the ones used to translate the file to its working copy form. Usually, these are the values specified by the user in the files' properties.</p>
<p>Inconsistent line endings in the file will be automatically repaired (made consistent) for some eol styles. For all others, an error is returned. By setting <em>always_repair_eols</em> to <code>TRUE</code>, eols will be made consistent even for those styles which don't have it by default.</p>
<dl class="section note"><dt>Note</dt><dd>To translate a file FROM normal form, use <a class="el" href="svn__subst_8h.html#a18dbb80be4ef26b2a978454716539d0c" title="Similar to svn_subst_copy_and_translate4() but without a cancellation function and baton...">svn_subst_copy_and_translate3()</a>.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.4 </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000396">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.5 API </dd></dl>

</div>
</div>
<a class="anchor" id="a8655a649e193b8eb96ba8ea59433a6b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> svn_subst_translation_required </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__subst_8h.html#a82d6196808784a7a73e098f8d8534edb">svn_subst_eol_style_t</a>&#160;</td>
          <td class="paramname"><em>style</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>eol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_hash_t *&#160;</td>
          <td class="paramname"><em>keywords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>special</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>force_eol_check</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether the working copy and normalized versions of a file with the given the parameters differ. </p>
<p>If <em>force_eol_check</em> is TRUE, the routine also accounts for all translations required due to repairing fixed eol styles.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.4 </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Aug 19 2015 09:37:23 for Subversion by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
