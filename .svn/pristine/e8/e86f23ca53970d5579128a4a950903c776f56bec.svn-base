<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Subversion: svn_mergeinfo.h File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Subversion
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">svn_mergeinfo.h File Reference</div>  </div>
</div>
<div class="contents">

<p>mergeinfo handling and processing  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;apr_pools.h&gt;</code><br/>
<code>#include &lt;apr_tables.h&gt;</code><br/>
<code>#include &lt;apr_hash.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="svn__types_8h_source.html">svn_types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="svn__string_8h_source.html">svn_string.h</a>&quot;</code><br/>
</div>
<p><a href="svn__mergeinfo_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#ad46a80dbdd6128bcf03ce27aa6cccf1f">SVN_MERGEINFO_NONINHERITABLE_STR</a>&#160;&#160;&#160;&quot;*&quot;</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Overview of the <code>SVN_PROP_MERGEINFO</code> property.  <a href="#ad46a80dbdd6128bcf03ce27aa6cccf1f"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef apr_hash_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminology for data structures that contain mergeinfo.  <a href="#a340ffb05cc24befa2b9e7d838c8b2b0e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45980e323aebefdb319fb015a9e4b5e8"></a><!-- doxytag: member="svn_mergeinfo.h::svn_mergeinfo_catalog_t" ref="a45980e323aebefdb319fb015a9e4b5e8" args="" -->
typedef apr_hash_t *&#160;</td><td class="memItemRight" valign="bottom"><b>svn_mergeinfo_catalog_t</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef enum <br class="typebreak"/>
<a class="el" href="svn__mergeinfo_8h.html#acd81e9d0f5bcc4eec4df7b8a140f435c">svn_mergeinfo_inheritance_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#a0519ea4415b98c27c0553a11054227de">svn_mergeinfo_inheritance_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The three ways to request mergeinfo affecting a given path.  <a href="#a0519ea4415b98c27c0553a11054227de"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#acd81e9d0f5bcc4eec4df7b8a140f435c">svn_mergeinfo_inheritance_t</a> { <br/>
&#160;&#160;<a class="el" href="svn__mergeinfo_8h.html#acd81e9d0f5bcc4eec4df7b8a140f435ca104caea58683f50ffb88947511affe62">svn_mergeinfo_explicit</a>, 
<br/>
&#160;&#160;<a class="el" href="svn__mergeinfo_8h.html#acd81e9d0f5bcc4eec4df7b8a140f435ca8ff16f9a275e6c06dad0b2d8a5d47a73">svn_mergeinfo_inherited</a>, 
<br/>
&#160;&#160;<a class="el" href="svn__mergeinfo_8h.html#acd81e9d0f5bcc4eec4df7b8a140f435cad027e914f050dbdc7163f90a519a22a9">svn_mergeinfo_nearest_ancestor</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The three ways to request mergeinfo affecting a given path.  <a href="svn__mergeinfo_8h.html#acd81e9d0f5bcc4eec4df7b8a140f435c">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#a238379edb4832a622e786df5451eb047">svn_mergeinfo_parse</a> (<a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a> *mergeinfo, const char *input, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the mergeinfo from <em>input</em> into <em>*mergeinfo</em>.  <a href="#a238379edb4832a622e786df5451eb047"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#a99924a6f5f1ffa833fd3ab72e8661778">svn_mergeinfo_diff</a> (<a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a> *deleted, <a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a> *added, <a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a> mergefrom, <a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a> mergeto, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> consider_inheritance, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the delta between two mergeinfos, <em>mergefrom</em> and <em>mergeto</em> (which may be <code>NULL</code>), and place the result in <em>*deleted</em> and <em>*added</em> (neither output argument may be <code>NULL</code>).  <a href="#a99924a6f5f1ffa833fd3ab72e8661778"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#a0bab0a2e1d9cd707dd752644144b13bc">svn_mergeinfo_merge</a> (<a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a> mergeinfo, <a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a> changes, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge a shallow copy of one mergeinfo, <em>changes</em>, into another mergeinfo <em>mergeinfo</em>.  <a href="#a0bab0a2e1d9cd707dd752644144b13bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#a3ca8987194d80d57773c0014863d734b">svn_mergeinfo_catalog_merge</a> (svn_mergeinfo_catalog_t mergeinfo_catalog, svn_mergeinfo_catalog_t changes_catalog, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine one mergeinfo catalog, <em>changes_catalog</em>, into another mergeinfo catalog <em>mergeinfo_catalog</em>.  <a href="#a3ca8987194d80d57773c0014863d734b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#af5293e26d8af012fb839ca96ee6cbfc8">svn_mergeinfo_remove</a> (<a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a> *mergeinfo, <a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a> eraser, <a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a> whiteboard, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Like svn_mergeinfo_remove2, but always considers inheritance.  <a href="#af5293e26d8af012fb839ca96ee6cbfc8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#afe2e8565251b0506deaf4fe69e622072">svn_mergeinfo_remove2</a> (<a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a> *mergeinfo, <a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a> eraser, <a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a> whiteboard, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> consider_inheritance, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes <em>eraser</em> (the subtrahend) from <em>whiteboard</em> (the minuend), and places the resulting difference in <em>*mergeinfo</em>.  <a href="#afe2e8565251b0506deaf4fe69e622072"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#ade733917b34518716d828644a2c17c6b">svn_rangelist_diff</a> (apr_array_header_t **deleted, apr_array_header_t **added, const apr_array_header_t *from, const apr_array_header_t *to, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> consider_inheritance, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the delta between two rangelists consisting of <code><a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions.">svn_merge_range_t</a></code> * elements (sorted in ascending order), <em>from</em> and <em>to</em>, and place the result in <em>*deleted</em> and <em>*added</em> (neither output argument will ever be <code>NULL</code>).  <a href="#ade733917b34518716d828644a2c17c6b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#a5d4327d794c76999e3282ace65802bdb">svn_rangelist_merge</a> (apr_array_header_t **rangelist, const apr_array_header_t *changes, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge two rangelists consisting of <code><a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions.">svn_merge_range_t</a></code> * elements, <em>*rangelist</em> and <em>changes</em>, placing the results in <em>*rangelist</em>.  <a href="#a5d4327d794c76999e3282ace65802bdb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#ae29908cfa10805deaf51b68b087f740d">svn_rangelist_remove</a> (apr_array_header_t **output, const apr_array_header_t *eraser, const apr_array_header_t *whiteboard, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> consider_inheritance, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes <em>eraser</em> (the subtrahend) from <em>whiteboard</em> (the minuend), and places the resulting difference in <em>output</em>.  <a href="#ae29908cfa10805deaf51b68b087f740d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#ab9c5c6a53ea94792a9575d1d36b819a3">svn_mergeinfo_intersect2</a> (<a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a> *mergeinfo, <a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a> mergeinfo1, <a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a> mergeinfo2, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> consider_inheritance, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the intersection of two mergeinfos, <em>mergeinfo1</em> and <em>mergeinfo2</em>, and place the result in <em>*mergeinfo</em>, which is (deeply) allocated in <em>result_pool</em>.  <a href="#ab9c5c6a53ea94792a9575d1d36b819a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#afc1287fa5e9e5a902ebd8ea30cac1ec5">svn_mergeinfo_intersect</a> (<a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a> *mergeinfo, <a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a> mergeinfo1, <a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a> mergeinfo2, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Like svn_mergeinfo_intersect2, but always considers inheritance.  <a href="#afc1287fa5e9e5a902ebd8ea30cac1ec5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#a4c7615be2d2d61a63b36b00f75236238">svn_rangelist_intersect</a> (apr_array_header_t **rangelist, const apr_array_header_t *rangelist1, const apr_array_header_t *rangelist2, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> consider_inheritance, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the intersection of two rangelists consisting of <code><a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions.">svn_merge_range_t</a></code> * elements, <em>rangelist1</em> and <em>rangelist2</em>, and place the result in <em>*rangelist</em> (which is never <code>NULL</code>).  <a href="#a4c7615be2d2d61a63b36b00f75236238"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#a6d5a31b9ddb2c98deca8f722042522b0">svn_rangelist_reverse</a> (apr_array_header_t *rangelist, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse <em>rangelist</em>, and the <code>start</code> and <code>end</code> fields of each range in <em>rangelist</em>, in place.  <a href="#a6d5a31b9ddb2c98deca8f722042522b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#a08a20e3e45b984c7a08cb95037a7d9a3">svn_rangelist_to_string</a> (<a class="el" href="structsvn__string__t.html">svn_string_t</a> **output, const apr_array_header_t *rangelist, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Take an array of <a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions.">svn_merge_range_t</a> *'s in <em>rangelist</em>, and convert it back to a text format rangelist in <em>output</em>.  <a href="#a08a20e3e45b984c7a08cb95037a7d9a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#a07b0fd1a89ab3a1f2abfd01dca01c38f">svn_rangelist_inheritable2</a> (apr_array_header_t **inheritable_rangelist, const apr_array_header_t *rangelist, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> start, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> end, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> inheritable, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a deep copy of <code><a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions.">svn_merge_range_t</a></code> *'s in <em>rangelist</em> excluding all non-inheritable <code><a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions.">svn_merge_range_t</a></code> if <em>inheritable</em> is TRUE or excluding all inheritable <code><a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions.">svn_merge_range_t</a></code> otherwise.  <a href="#a07b0fd1a89ab3a1f2abfd01dca01c38f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#a061fdd15bb5e1d695799c7d46786feab">svn_rangelist_inheritable</a> (apr_array_header_t **inheritable_rangelist, const apr_array_header_t *rangelist, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> start, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> end, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Like svn_rangelist_inheritable2, but always finds inheritable ranges.  <a href="#a061fdd15bb5e1d695799c7d46786feab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#a4ba301bd63dd00dbfe45f614b09abff8">svn_mergeinfo_inheritable2</a> (<a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a> *inheritable_mergeinfo, <a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a> mergeinfo, const char *path, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> start, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> end, <a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> inheritable, apr_pool_t *result_pool, apr_pool_t *scratch_pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a deep copy of <em>mergeinfo</em>, excluding all non-inheritable <code><a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions.">svn_merge_range_t</a></code> if <em>inheritable</em> is TRUE or excluding all inheritable <code><a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions.">svn_merge_range_t</a></code> otherwise.  <a href="#a4ba301bd63dd00dbfe45f614b09abff8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#afe89ba236af678f4c2a1562e34d937f6">svn_mergeinfo_inheritable</a> (<a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a> *inheritable_mergeinfo, <a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a> mergeinfo, const char *path, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> start, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> end, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Like svn_mergeinfo_inheritable2, but always finds inheritable mergeinfo.  <a href="#afe89ba236af678f4c2a1562e34d937f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#a4be44bfd77bb7b3b4bbcc516e82655ac">svn_mergeinfo_to_string</a> (<a class="el" href="structsvn__string__t.html">svn_string_t</a> **output, <a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a> mergeinput, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a mergeinfo in <em>mergeinput</em>, and convert it to unparsed mergeinfo.  <a href="#a4be44bfd77bb7b3b4bbcc516e82655ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#aa3e1605436e43a23f5055649f4a831f4">svn_mergeinfo_sort</a> (<a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a> mergeinfo, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a hash of mergeinfo in <em>mergeinfo</em>, and sort the rangelists associated with each key (in place).  <a href="#aa3e1605436e43a23f5055649f4a831f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">svn_mergeinfo_catalog_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#abf96ca398215933518d77cbb6aacab83">svn_mergeinfo_catalog_dup</a> (svn_mergeinfo_catalog_t mergeinfo_catalog, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a deep copy of <em>mergeinfo_catalog</em>, allocated in <em>pool</em>.  <a href="#abf96ca398215933518d77cbb6aacab83"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#a97c3bd21f6e96a0d1d29a18ce0769842">svn_mergeinfo_dup</a> (<a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a> mergeinfo, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a deep copy of <em>mergeinfo</em>, allocated in <em>pool</em>.  <a href="#a97c3bd21f6e96a0d1d29a18ce0769842"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">apr_array_header_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#a8d3f741bcd18616e829de1156c98fcc5">svn_rangelist_dup</a> (const apr_array_header_t *rangelist, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a deep copy of <em>rangelist</em>, allocated in <em>pool</em>.  <a href="#a8d3f741bcd18616e829de1156c98fcc5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#a4060ce759919b37939a9d231e7922f55">svn_inheritance_to_word</a> (<a class="el" href="svn__mergeinfo_8h.html#acd81e9d0f5bcc4eec4df7b8a140f435c">svn_mergeinfo_inheritance_t</a> inherit)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a constant string expressing <em>inherit</em> as an English word, i.e., "explicit" (default), "inherited", or "nearest_ancestor".  <a href="#a4060ce759919b37939a9d231e7922f55"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="svn__mergeinfo_8h.html#acd81e9d0f5bcc4eec4df7b8a140f435c">svn_mergeinfo_inheritance_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__mergeinfo_8h.html#a7cd9e433323caa7bd14d34c0d2a07afe">svn_inheritance_from_word</a> (const char *word)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the appropriate <code>svn_mergeinfo_inheritance_t</code> for <em>word</em>.  <a href="#a7cd9e433323caa7bd14d34c0d2a07afe"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>mergeinfo handling and processing </p>

<p>Definition in file <a class="el" href="svn__mergeinfo_8h_source.html">svn_mergeinfo.h</a>.</p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="ad46a80dbdd6128bcf03ce27aa6cccf1f"></a><!-- doxytag: member="svn_mergeinfo.h::SVN_MERGEINFO_NONINHERITABLE_STR" ref="ad46a80dbdd6128bcf03ce27aa6cccf1f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SVN_MERGEINFO_NONINHERITABLE_STR&#160;&#160;&#160;&quot;*&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overview of the <code>SVN_PROP_MERGEINFO</code> property. </p>
<p>Merge history is stored in the <code>SVN_PROP_MERGEINFO</code> property of files and directories. The <code>SVN_PROP_MERGEINFO</code> property on a path stores the complete list of changes merged to that path, either directly or via the path's parent, grand-parent, etc.. A path may have empty mergeinfo which means that nothing has been merged to that path or all previous merges to the path were reversed. Note that a path may have no mergeinfo, this is not the same as empty mergeinfo.</p>
<p>Every path in a tree may have <code>SVN_PROP_MERGEINFO</code> set, but if the <code>SVN_PROP_MERGEINFO</code> for a path is equivalent to the <code>SVN_PROP_MERGEINFO</code> for its parent, then the <code>SVN_PROP_MERGEINFO</code> on the path will 'elide' (be removed) from the path as a post step to any merge. If a path's parent does not have any <code>SVN_PROP_MERGEINFO</code> set, the path's mergeinfo can elide to its nearest grand-parent, great-grand-parent, etc. that has equivalent <code>SVN_PROP_MERGEINFO</code> set on it.</p>
<p>If a path has no <code>SVN_PROP_MERGEINFO</code> of its own, it inherits mergeinfo from its nearest parent that has <code>SVN_PROP_MERGEINFO</code> set. The exception to this is <code>SVN_PROP_MERGEINFO</code> with non-inheritable revision ranges. These non-inheritable ranges apply only to the path which they are set on.</p>
<p>Due to Subversion's allowance for mixed revision working copies, both elision and inheritance within the working copy presume the path between a path and its nearest parent with mergeinfo is at the same working revision. If this is not the case then neither inheritance nor elision can occur.</p>
<p>The value of the <code>SVN_PROP_MERGEINFO</code> property is either an empty string (representing empty mergeinfo) or a non-empty string consisting of a path, a colon, and comma separated revision list, containing one or more revision or revision ranges. Revision range start and end points are separated by "-". Revisions and revision ranges may have the optional <code>SVN_MERGEINFO_NONINHERITABLE_STR</code> suffix to signify a non-inheritable revision/revision range.</p>
<p><code>SVN_PROP_MERGEINFO</code> Value Grammar:</p>
<p>Token Definition ----- ---------- revisionrange REVISION1 "-" REVISION2 revisioneelement (revisionrange | REVISION)"*"? rangelist revisioneelement (COMMA revisioneelement)* revisionline PATHNAME COLON rangelist top "" | (revisionline (NEWLINE revisionline))*</p>
<p>The PATHNAME is the source of a merge and the rangelist the revision(s) merged to the path <code>SVN_PROP_MERGEINFO</code> is set on directly or indirectly via inheritance. PATHNAME must always exist at the specified rangelist and thus a single merge may result in multiple revisionlines if the source was renamed.</p>
<p>Rangelists must be sorted from lowest to highest revision and cannot contain overlapping revisionlistelements. REVISION1 must be less than REVISION2. Consecutive single revisions that can be represented by a revisionrange are allowed however (e.g. '5,6,7,8,9-12' or '5-12' are both acceptable). </p>

<p>Definition at line <a class="el" href="svn__mergeinfo_8h_source.html#l00107">107</a> of file <a class="el" href="svn__mergeinfo_8h_source.html">svn_mergeinfo.h</a>.</p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a0519ea4415b98c27c0553a11054227de"></a><!-- doxytag: member="svn_mergeinfo.h::svn_mergeinfo_inheritance_t" ref="a0519ea4415b98c27c0553a11054227de" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="svn__mergeinfo_8h.html#acd81e9d0f5bcc4eec4df7b8a140f435c">svn_mergeinfo_inheritance_t</a>  <a class="el" href="svn__mergeinfo_8h.html#acd81e9d0f5bcc4eec4df7b8a140f435c">svn_mergeinfo_inheritance_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The three ways to request mergeinfo affecting a given path. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="a340ffb05cc24befa2b9e7d838c8b2b0e"></a><!-- doxytag: member="svn_mergeinfo.h::svn_mergeinfo_t" ref="a340ffb05cc24befa2b9e7d838c8b2b0e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef apr_hash_t* <a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Terminology for data structures that contain mergeinfo. </p>
<p>Subversion commonly uses several data structures to represent mergeinfo in RAM:</p>
<p>(a) Strings (<code><a class="el" href="structsvn__string__t.html" title="A simple counted string.">svn_string_t</a></code> *) containing "unparsed mergeinfo".</p>
<p>(b) A "rangelist". An array (<code>apr_array_header_t</code> *) of non-overlapping merge ranges (<code><a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions.">svn_merge_range_t</a></code> *), sorted as said by <code><a class="el" href="svn__sorts_8h.html#a58a32c4f0a5c14672865be8768b1113a" title="Compare two svn_merge_range_t *&#39;s, returning an integer greater than, equal to, or less than 0 if the...">svn_sort_compare_ranges()</a></code>. An empty range list is represented by an empty array. Unless specifically noted otherwise, all APIs require rangelists that describe only forward ranges, i.e. the range's start revision is less than its end revision.</p>
<p>(c) <code>svn_mergeinfo_t</code>, called "mergeinfo". A hash mapping merge source paths (<code>const</code> char *, starting with slashes) to non-empty rangelist arrays. A <code>NULL</code> hash is used to represent no mergeinfo and an empty hash is used to represent empty mergeinfo.</p>
<p>(d) <code>svn_mergeinfo_catalog_t</code>, called a "mergeinfo catalog". A hash mapping paths (<code>const</code> char *) to <code>svn_mergeinfo_t</code>.</p>
<p>Both <code>svn_mergeinfo_t</code> and <code>svn_mergeinfo_catalog_t</code> are just typedefs for <code>apr_hash_t</code> *; there is no static type-checking, and you still use standard <code>apr_hash_t</code> functions to interact with them.</p>
<p>Note that while the keys of mergeinfos are always absolute from the repository root, the keys of a catalog may be relative to something else, such as an RA session root. </p>

<p>Definition at line <a class="el" href="svn__mergeinfo_8h_source.html#l00142">142</a> of file <a class="el" href="svn__mergeinfo_8h_source.html">svn_mergeinfo.h</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="acd81e9d0f5bcc4eec4df7b8a140f435c"></a><!-- doxytag: member="svn_mergeinfo.h::svn_mergeinfo_inheritance_t" ref="acd81e9d0f5bcc4eec4df7b8a140f435c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="svn__mergeinfo_8h.html#acd81e9d0f5bcc4eec4df7b8a140f435c">svn_mergeinfo_inheritance_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The three ways to request mergeinfo affecting a given path. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="acd81e9d0f5bcc4eec4df7b8a140f435ca104caea58683f50ffb88947511affe62"></a><!-- doxytag: member="svn_mergeinfo_explicit" ref="acd81e9d0f5bcc4eec4df7b8a140f435ca104caea58683f50ffb88947511affe62" args="" -->svn_mergeinfo_explicit</em>&nbsp;</td><td>
<p>Explicit mergeinfo only. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acd81e9d0f5bcc4eec4df7b8a140f435ca8ff16f9a275e6c06dad0b2d8a5d47a73"></a><!-- doxytag: member="svn_mergeinfo_inherited" ref="acd81e9d0f5bcc4eec4df7b8a140f435ca8ff16f9a275e6c06dad0b2d8a5d47a73" args="" -->svn_mergeinfo_inherited</em>&nbsp;</td><td>
<p>Explicit mergeinfo, or if that doesn't exist, the inherited mergeinfo from a target's nearest (path-wise, not history-wise) ancestor. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acd81e9d0f5bcc4eec4df7b8a140f435cad027e914f050dbdc7163f90a519a22a9"></a><!-- doxytag: member="svn_mergeinfo_nearest_ancestor" ref="acd81e9d0f5bcc4eec4df7b8a140f435cad027e914f050dbdc7163f90a519a22a9" args="" -->svn_mergeinfo_nearest_ancestor</em>&nbsp;</td><td>
<p>Mergeinfo on target's nearest (path-wise, not history-wise) ancestor, regardless of whether target has explicit mergeinfo. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="svn__mergeinfo_8h_source.html#l00514">514</a> of file <a class="el" href="svn__mergeinfo_8h_source.html">svn_mergeinfo.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a7cd9e433323caa7bd14d34c0d2a07afe"></a><!-- doxytag: member="svn_mergeinfo.h::svn_inheritance_from_word" ref="a7cd9e433323caa7bd14d34c0d2a07afe" args="(const char *word)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__mergeinfo_8h.html#acd81e9d0f5bcc4eec4df7b8a140f435c">svn_mergeinfo_inheritance_t</a> svn_inheritance_from_word </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>word</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the appropriate <code>svn_mergeinfo_inheritance_t</code> for <em>word</em>. </p>
<p><em>word</em> is as returned from <a class="el" href="svn__mergeinfo_8h.html#a4060ce759919b37939a9d231e7922f55" title="Return a constant string expressing inherit as an English word, i.e., &quot;explicit&quot; (default), &quot;inherited&quot;, or &quot;nearest_ancestor&quot;.">svn_inheritance_to_word()</a>. Defaults to <code>svn_mergeinfo_explicit</code>.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="a4060ce759919b37939a9d231e7922f55"></a><!-- doxytag: member="svn_mergeinfo.h::svn_inheritance_to_word" ref="a4060ce759919b37939a9d231e7922f55" args="(svn_mergeinfo_inheritance_t inherit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* svn_inheritance_to_word </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#acd81e9d0f5bcc4eec4df7b8a140f435c">svn_mergeinfo_inheritance_t</a>&#160;</td>
          <td class="paramname"><em>inherit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a constant string expressing <em>inherit</em> as an English word, i.e., "explicit" (default), "inherited", or "nearest_ancestor". </p>
<p>The string is not localized, as it may be used for client&lt;-&gt;server communications.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="abf96ca398215933518d77cbb6aacab83"></a><!-- doxytag: member="svn_mergeinfo.h::svn_mergeinfo_catalog_dup" ref="abf96ca398215933518d77cbb6aacab83" args="(svn_mergeinfo_catalog_t mergeinfo_catalog, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">svn_mergeinfo_catalog_t svn_mergeinfo_catalog_dup </td>
          <td>(</td>
          <td class="paramtype">svn_mergeinfo_catalog_t&#160;</td>
          <td class="paramname"><em>mergeinfo_catalog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a deep copy of <em>mergeinfo_catalog</em>, allocated in <em>pool</em>. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ca8987194d80d57773c0014863d734b"></a><!-- doxytag: member="svn_mergeinfo.h::svn_mergeinfo_catalog_merge" ref="a3ca8987194d80d57773c0014863d734b" args="(svn_mergeinfo_catalog_t mergeinfo_catalog, svn_mergeinfo_catalog_t changes_catalog, apr_pool_t *result_pool, apr_pool_t *scratch_pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_mergeinfo_catalog_merge </td>
          <td>(</td>
          <td class="paramtype">svn_mergeinfo_catalog_t&#160;</td>
          <td class="paramname"><em>mergeinfo_catalog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">svn_mergeinfo_catalog_t&#160;</td>
          <td class="paramname"><em>changes_catalog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Combine one mergeinfo catalog, <em>changes_catalog</em>, into another mergeinfo catalog <em>mergeinfo_catalog</em>. </p>
<p>If both catalogs have mergeinfo for the same key, use <a class="el" href="svn__mergeinfo_8h.html#a0bab0a2e1d9cd707dd752644144b13bc" title="Merge a shallow copy of one mergeinfo, changes, into another mergeinfo mergeinfo.">svn_mergeinfo_merge()</a> to combine the mergeinfos.</p>
<p>Additions to <em>mergeinfo_catalog</em> are deep copies allocated in <em>result_pool</em>. Temporary allocations are made in <em>scratch_pool</em>.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="a99924a6f5f1ffa833fd3ab72e8661778"></a><!-- doxytag: member="svn_mergeinfo.h::svn_mergeinfo_diff" ref="a99924a6f5f1ffa833fd3ab72e8661778" args="(svn_mergeinfo_t *deleted, svn_mergeinfo_t *added, svn_mergeinfo_t mergefrom, svn_mergeinfo_t mergeto, svn_boolean_t consider_inheritance, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_mergeinfo_diff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a> *&#160;</td>
          <td class="paramname"><em>deleted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a> *&#160;</td>
          <td class="paramname"><em>added</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a>&#160;</td>
          <td class="paramname"><em>mergefrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a>&#160;</td>
          <td class="paramname"><em>mergeto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>consider_inheritance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the delta between two mergeinfos, <em>mergefrom</em> and <em>mergeto</em> (which may be <code>NULL</code>), and place the result in <em>*deleted</em> and <em>*added</em> (neither output argument may be <code>NULL</code>). </p>
<p><em>consider_inheritance</em> determines how the rangelists in the two hashes are compared for equality. If <em>consider_inheritance</em> is FALSE, then the start and end revisions of the <code>svn_merge_range_t's</code> being compared are the only factors considered when determining equality.</p>
<p>e.g. '/trunk: 1,3-4*,5' == '/trunk: 1,3-5'</p>
<p>If <em>consider_inheritance</em> is TRUE, then the inheritability of the <code>svn_merge_range_t's</code> is also considered and must be the same for two otherwise identical ranges to be judged equal.</p>
<p>e.g. '/trunk: 1,3-4*,5' != '/trunk: 1,3-5' '/trunk: 1,3-4*,5' == '/trunk: 1,3-4*,5' '/trunk: 1,3-4,5' == '/trunk: 1,3-4,5'</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="a97c3bd21f6e96a0d1d29a18ce0769842"></a><!-- doxytag: member="svn_mergeinfo.h::svn_mergeinfo_dup" ref="a97c3bd21f6e96a0d1d29a18ce0769842" args="(svn_mergeinfo_t mergeinfo, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a> svn_mergeinfo_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a>&#160;</td>
          <td class="paramname"><em>mergeinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a deep copy of <em>mergeinfo</em>, allocated in <em>pool</em>. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="afe89ba236af678f4c2a1562e34d937f6"></a><!-- doxytag: member="svn_mergeinfo.h::svn_mergeinfo_inheritable" ref="afe89ba236af678f4c2a1562e34d937f6" args="(svn_mergeinfo_t *inheritable_mergeinfo, svn_mergeinfo_t mergeinfo, const char *path, svn_revnum_t start, svn_revnum_t end, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_mergeinfo_inheritable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a> *&#160;</td>
          <td class="paramname"><em>inheritable_mergeinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a>&#160;</td>
          <td class="paramname"><em>mergeinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like svn_mergeinfo_inheritable2, but always finds inheritable mergeinfo. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000211">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.6 API. </dd></dl>

</div>
</div>
<a class="anchor" id="a4ba301bd63dd00dbfe45f614b09abff8"></a><!-- doxytag: member="svn_mergeinfo.h::svn_mergeinfo_inheritable2" ref="a4ba301bd63dd00dbfe45f614b09abff8" args="(svn_mergeinfo_t *inheritable_mergeinfo, svn_mergeinfo_t mergeinfo, const char *path, svn_revnum_t start, svn_revnum_t end, svn_boolean_t inheritable, apr_pool_t *result_pool, apr_pool_t *scratch_pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_mergeinfo_inheritable2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a> *&#160;</td>
          <td class="paramname"><em>inheritable_mergeinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a>&#160;</td>
          <td class="paramname"><em>mergeinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>inheritable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a deep copy of <em>mergeinfo</em>, excluding all non-inheritable <code><a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions.">svn_merge_range_t</a></code> if <em>inheritable</em> is TRUE or excluding all inheritable <code><a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions.">svn_merge_range_t</a></code> otherwise. </p>
<p>If <em>start</em> and <em>end</em> are valid revisions and <em>start</em> is less than or equal to <em>end</em>, then exclude only the non-inheritable revisions that intersect inclusively with the range defined by <em>start</em> and <em>end</em>. If <em>path</em> is not NULL remove non-inheritable ranges only for <em>path</em>. If all ranges are removed for a given path then remove that path as well. If all paths are removed or <em>rangelist</em> is empty then set <em>*inheritable_rangelist</em> to an empty array. Allocate the copy in <em>result_pool</em>, use <em>scratch_pool</em> for temporary allocations.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="afc1287fa5e9e5a902ebd8ea30cac1ec5"></a><!-- doxytag: member="svn_mergeinfo.h::svn_mergeinfo_intersect" ref="afc1287fa5e9e5a902ebd8ea30cac1ec5" args="(svn_mergeinfo_t *mergeinfo, svn_mergeinfo_t mergeinfo1, svn_mergeinfo_t mergeinfo2, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_mergeinfo_intersect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a> *&#160;</td>
          <td class="paramname"><em>mergeinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a>&#160;</td>
          <td class="paramname"><em>mergeinfo1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a>&#160;</td>
          <td class="paramname"><em>mergeinfo2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like svn_mergeinfo_intersect2, but always considers inheritance. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000209">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.6 API. </dd></dl>

</div>
</div>
<a class="anchor" id="ab9c5c6a53ea94792a9575d1d36b819a3"></a><!-- doxytag: member="svn_mergeinfo.h::svn_mergeinfo_intersect2" ref="ab9c5c6a53ea94792a9575d1d36b819a3" args="(svn_mergeinfo_t *mergeinfo, svn_mergeinfo_t mergeinfo1, svn_mergeinfo_t mergeinfo2, svn_boolean_t consider_inheritance, apr_pool_t *result_pool, apr_pool_t *scratch_pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_mergeinfo_intersect2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a> *&#160;</td>
          <td class="paramname"><em>mergeinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a>&#160;</td>
          <td class="paramname"><em>mergeinfo1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a>&#160;</td>
          <td class="paramname"><em>mergeinfo2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>consider_inheritance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the intersection of two mergeinfos, <em>mergeinfo1</em> and <em>mergeinfo2</em>, and place the result in <em>*mergeinfo</em>, which is (deeply) allocated in <em>result_pool</em>. </p>
<p>Temporary allocations will be performed in <em>scratch_pool</em>.</p>
<p><em>consider_inheritance</em> determines how to account for the inheritability of the two mergeinfo's ranges when calculating the range equivalence, </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="svn__mergeinfo_8h.html#a4c7615be2d2d61a63b36b00f75236238" title="Find the intersection of two rangelists consisting of svn_merge_range_t * elements, rangelist1 and rangelist2, and place the result in *rangelist (which is never NULL).">svn_rangelist_intersect()</a>.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="a0bab0a2e1d9cd707dd752644144b13bc"></a><!-- doxytag: member="svn_mergeinfo.h::svn_mergeinfo_merge" ref="a0bab0a2e1d9cd707dd752644144b13bc" args="(svn_mergeinfo_t mergeinfo, svn_mergeinfo_t changes, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_mergeinfo_merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a>&#160;</td>
          <td class="paramname"><em>mergeinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a>&#160;</td>
          <td class="paramname"><em>changes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Merge a shallow copy of one mergeinfo, <em>changes</em>, into another mergeinfo <em>mergeinfo</em>. </p>
<p>When intersecting rangelists for a path are merged, the inheritability of the resulting <a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions.">svn_merge_range_t</a> depends on the inheritability of the operands. If two non-inheritable ranges are merged the result is always non-inheritable, in all other cases the resulting range is inheritable.</p>
<p>e.g. '/A: 1,3-4' merged with '/A: 1,3,4*,5' --&gt; '/A: 1,3-5' '/A: 1,3-4*' merged with '/A: 1,3,4*,5' --&gt; '/A: 1,3,4*,5'</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="a238379edb4832a622e786df5451eb047"></a><!-- doxytag: member="svn_mergeinfo.h::svn_mergeinfo_parse" ref="a238379edb4832a622e786df5451eb047" args="(svn_mergeinfo_t *mergeinfo, const char *input, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_mergeinfo_parse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a> *&#160;</td>
          <td class="paramname"><em>mergeinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parse the mergeinfo from <em>input</em> into <em>*mergeinfo</em>. </p>
<p>If no mergeinfo is available, return an empty mergeinfo (never <code>NULL</code>). Perform temporary allocations in <em>pool</em>.</p>
<p>If <em>input</em> is not a grammatically correct <code>SVN_PROP_MERGEINFO</code> property, contains overlapping revision ranges of differing inheritability, or revision ranges with a start revision greater than or equal to its end revision, or contains paths mapped to empty revision ranges, then return <code>SVN_ERR_MERGEINFO_PARSE_ERROR</code>. Unordered revision ranges are allowed, but will be sorted when placed into <em>*mergeinfo</em>. Overlapping revision ranges of the same inheritability are also allowed, but will be combined into a single range when placed into <em>*mergeinfo</em>.</p>
<p><em>input</em> may contain relative merge source paths, but these are converted to absolute paths in <em>*mergeinfo</em>.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="af5293e26d8af012fb839ca96ee6cbfc8"></a><!-- doxytag: member="svn_mergeinfo.h::svn_mergeinfo_remove" ref="af5293e26d8af012fb839ca96ee6cbfc8" args="(svn_mergeinfo_t *mergeinfo, svn_mergeinfo_t eraser, svn_mergeinfo_t whiteboard, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_mergeinfo_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a> *&#160;</td>
          <td class="paramname"><em>mergeinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a>&#160;</td>
          <td class="paramname"><em>eraser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a>&#160;</td>
          <td class="paramname"><em>whiteboard</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like svn_mergeinfo_remove2, but always considers inheritance. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000208">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.6 API. </dd></dl>

</div>
</div>
<a class="anchor" id="afe2e8565251b0506deaf4fe69e622072"></a><!-- doxytag: member="svn_mergeinfo.h::svn_mergeinfo_remove2" ref="afe2e8565251b0506deaf4fe69e622072" args="(svn_mergeinfo_t *mergeinfo, svn_mergeinfo_t eraser, svn_mergeinfo_t whiteboard, svn_boolean_t consider_inheritance, apr_pool_t *result_pool, apr_pool_t *scratch_pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_mergeinfo_remove2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a> *&#160;</td>
          <td class="paramname"><em>mergeinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a>&#160;</td>
          <td class="paramname"><em>eraser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a>&#160;</td>
          <td class="paramname"><em>whiteboard</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>consider_inheritance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes <em>eraser</em> (the subtrahend) from <em>whiteboard</em> (the minuend), and places the resulting difference in <em>*mergeinfo</em>. </p>
<p>Allocates <em>*mergeinfo</em> in <em>result_pool</em>. Temporary allocations will be performed in <em>scratch_pool</em>.</p>
<p><em>consider_inheritance</em> determines how to account for the inheritability of the two mergeinfo's ranges when calculating the range equivalence, as described for <a class="el" href="svn__mergeinfo_8h.html#a99924a6f5f1ffa833fd3ab72e8661778" title="Calculate the delta between two mergeinfos, mergefrom and mergeto (which may be NULL), and place the result in *deleted and *added (neither output argument may be NULL).">svn_mergeinfo_diff()</a>.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="aa3e1605436e43a23f5055649f4a831f4"></a><!-- doxytag: member="svn_mergeinfo.h::svn_mergeinfo_sort" ref="aa3e1605436e43a23f5055649f4a831f4" args="(svn_mergeinfo_t mergeinfo, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_mergeinfo_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a>&#160;</td>
          <td class="paramname"><em>mergeinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Take a hash of mergeinfo in <em>mergeinfo</em>, and sort the rangelists associated with each key (in place). </p>
<p>TODO(miapi): mergeinfos should *always* be sorted. This should be a private function.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.5 </dd></dl>

</div>
</div>
<a class="anchor" id="a4be44bfd77bb7b3b4bbcc516e82655ac"></a><!-- doxytag: member="svn_mergeinfo.h::svn_mergeinfo_to_string" ref="a4be44bfd77bb7b3b4bbcc516e82655ac" args="(svn_string_t **output, svn_mergeinfo_t mergeinput, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_mergeinfo_to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__string__t.html">svn_string_t</a> **&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#a340ffb05cc24befa2b9e7d838c8b2b0e">svn_mergeinfo_t</a>&#160;</td>
          <td class="paramname"><em>mergeinput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Take a mergeinfo in <em>mergeinput</em>, and convert it to unparsed mergeinfo. </p>
<p>Set <em>*output</em> to the result, allocated in <em>pool</em>. If <em>input</em> contains no elements, set <em>*output</em> to the empty string.</p>
<p><em>mergeinput</em> may contain relative merge source paths, but these are converted to absolute paths in <em>*output</em>.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="ade733917b34518716d828644a2c17c6b"></a><!-- doxytag: member="svn_mergeinfo.h::svn_rangelist_diff" ref="ade733917b34518716d828644a2c17c6b" args="(apr_array_header_t **deleted, apr_array_header_t **added, const apr_array_header_t *from, const apr_array_header_t *to, svn_boolean_t consider_inheritance, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_rangelist_diff </td>
          <td>(</td>
          <td class="paramtype">apr_array_header_t **&#160;</td>
          <td class="paramname"><em>deleted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_array_header_t **&#160;</td>
          <td class="paramname"><em>added</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const apr_array_header_t *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const apr_array_header_t *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>consider_inheritance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the delta between two rangelists consisting of <code><a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions.">svn_merge_range_t</a></code> * elements (sorted in ascending order), <em>from</em> and <em>to</em>, and place the result in <em>*deleted</em> and <em>*added</em> (neither output argument will ever be <code>NULL</code>). </p>
<p><em>consider_inheritance</em> determines how to account for the inheritability of the two rangelist's ranges when calculating the diff, as described for <a class="el" href="svn__mergeinfo_8h.html#a99924a6f5f1ffa833fd3ab72e8661778" title="Calculate the delta between two mergeinfos, mergefrom and mergeto (which may be NULL), and place the result in *deleted and *added (neither output argument may be NULL).">svn_mergeinfo_diff()</a>.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="a8d3f741bcd18616e829de1156c98fcc5"></a><!-- doxytag: member="svn_mergeinfo.h::svn_rangelist_dup" ref="a8d3f741bcd18616e829de1156c98fcc5" args="(const apr_array_header_t *rangelist, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_array_header_t* svn_rangelist_dup </td>
          <td>(</td>
          <td class="paramtype">const apr_array_header_t *&#160;</td>
          <td class="paramname"><em>rangelist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a deep copy of <em>rangelist</em>, allocated in <em>pool</em>. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="a061fdd15bb5e1d695799c7d46786feab"></a><!-- doxytag: member="svn_mergeinfo.h::svn_rangelist_inheritable" ref="a061fdd15bb5e1d695799c7d46786feab" args="(apr_array_header_t **inheritable_rangelist, const apr_array_header_t *rangelist, svn_revnum_t start, svn_revnum_t end, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_rangelist_inheritable </td>
          <td>(</td>
          <td class="paramtype">apr_array_header_t **&#160;</td>
          <td class="paramname"><em>inheritable_rangelist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const apr_array_header_t *&#160;</td>
          <td class="paramname"><em>rangelist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like svn_rangelist_inheritable2, but always finds inheritable ranges. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000210">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.6 API. </dd></dl>

</div>
</div>
<a class="anchor" id="a07b0fd1a89ab3a1f2abfd01dca01c38f"></a><!-- doxytag: member="svn_mergeinfo.h::svn_rangelist_inheritable2" ref="a07b0fd1a89ab3a1f2abfd01dca01c38f" args="(apr_array_header_t **inheritable_rangelist, const apr_array_header_t *rangelist, svn_revnum_t start, svn_revnum_t end, svn_boolean_t inheritable, apr_pool_t *result_pool, apr_pool_t *scratch_pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_rangelist_inheritable2 </td>
          <td>(</td>
          <td class="paramtype">apr_array_header_t **&#160;</td>
          <td class="paramname"><em>inheritable_rangelist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const apr_array_header_t *&#160;</td>
          <td class="paramname"><em>rangelist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>inheritable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>scratch_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a deep copy of <code><a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions.">svn_merge_range_t</a></code> *'s in <em>rangelist</em> excluding all non-inheritable <code><a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions.">svn_merge_range_t</a></code> if <em>inheritable</em> is TRUE or excluding all inheritable <code><a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions.">svn_merge_range_t</a></code> otherwise. </p>
<p>If <em>start</em> and <em>end</em> are valid revisions and <em>start</em> is less than or equal to <em>end</em>, then exclude only the non-inheritable revision ranges that intersect inclusively with the range defined by <em>start</em> and <em>end</em>. If <em>rangelist</em> contains no elements, return an empty array. Allocate the copy in <em>result_pool</em>, use <em>scratch_pool</em> for temporary allocations.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="a4c7615be2d2d61a63b36b00f75236238"></a><!-- doxytag: member="svn_mergeinfo.h::svn_rangelist_intersect" ref="a4c7615be2d2d61a63b36b00f75236238" args="(apr_array_header_t **rangelist, const apr_array_header_t *rangelist1, const apr_array_header_t *rangelist2, svn_boolean_t consider_inheritance, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_rangelist_intersect </td>
          <td>(</td>
          <td class="paramtype">apr_array_header_t **&#160;</td>
          <td class="paramname"><em>rangelist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const apr_array_header_t *&#160;</td>
          <td class="paramname"><em>rangelist1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const apr_array_header_t *&#160;</td>
          <td class="paramname"><em>rangelist2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>consider_inheritance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the intersection of two rangelists consisting of <code><a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions.">svn_merge_range_t</a></code> * elements, <em>rangelist1</em> and <em>rangelist2</em>, and place the result in <em>*rangelist</em> (which is never <code>NULL</code>). </p>
<p><em>consider_inheritance</em> determines how to account for the inheritability of the two rangelist's ranges when calculating the intersection, </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="svn__mergeinfo_8h.html#a99924a6f5f1ffa833fd3ab72e8661778" title="Calculate the delta between two mergeinfos, mergefrom and mergeto (which may be NULL), and place the result in *deleted and *added (neither output argument may be NULL).">svn_mergeinfo_diff()</a>. If <em>consider_inheritance</em> is <a class="el" href="svn__types_8h.html#aa93f0eb578d23995850d61f7d61c55c1" title="uhh...">FALSE</a> then ranges with different inheritance can intersect, but the the resulting <em>*rangelist</em> is non-inheritable only if the corresponding ranges from both <em>rangelist1</em> and <em>rangelist2</em> are non-inheritable. If <em>consider_inheritance</em> is <a class="el" href="svn__types_8h.html#aa8cecfc5c5c054d2875c03e77b7be15d" title="uhh...">TRUE</a>, then ranges with different inheritance can never intersect.</dd></dl>
<p>Note: <em>rangelist1</em> and <em>rangelist2</em> must be sorted as said by <code><a class="el" href="svn__sorts_8h.html#a58a32c4f0a5c14672865be8768b1113a" title="Compare two svn_merge_range_t *&#39;s, returning an integer greater than, equal to, or less than 0 if the...">svn_sort_compare_ranges()</a></code>. <em>*rangelist</em> is guaranteed to be in sorted order. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="a5d4327d794c76999e3282ace65802bdb"></a><!-- doxytag: member="svn_mergeinfo.h::svn_rangelist_merge" ref="a5d4327d794c76999e3282ace65802bdb" args="(apr_array_header_t **rangelist, const apr_array_header_t *changes, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_rangelist_merge </td>
          <td>(</td>
          <td class="paramtype">apr_array_header_t **&#160;</td>
          <td class="paramname"><em>rangelist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const apr_array_header_t *&#160;</td>
          <td class="paramname"><em>changes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Merge two rangelists consisting of <code><a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions.">svn_merge_range_t</a></code> * elements, <em>*rangelist</em> and <em>changes</em>, placing the results in <em>*rangelist</em>. </p>
<p>Either rangelist may be empty.</p>
<p>When intersecting rangelists are merged, the inheritability of the resulting <a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions.">svn_merge_range_t</a> depends on the inheritability of the operands: see <a class="el" href="svn__mergeinfo_8h.html#a0bab0a2e1d9cd707dd752644144b13bc" title="Merge a shallow copy of one mergeinfo, changes, into another mergeinfo mergeinfo.">svn_mergeinfo_merge()</a>.</p>
<p>Note: <em>*rangelist</em> and <em>changes</em> must be sorted as said by <code><a class="el" href="svn__sorts_8h.html#a58a32c4f0a5c14672865be8768b1113a" title="Compare two svn_merge_range_t *&#39;s, returning an integer greater than, equal to, or less than 0 if the...">svn_sort_compare_ranges()</a></code>. <em>*rangelist</em> is guaranteed to remain in sorted order and be compacted to the minimal number of ranges needed to represent the merged result.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="ae29908cfa10805deaf51b68b087f740d"></a><!-- doxytag: member="svn_mergeinfo.h::svn_rangelist_remove" ref="ae29908cfa10805deaf51b68b087f740d" args="(apr_array_header_t **output, const apr_array_header_t *eraser, const apr_array_header_t *whiteboard, svn_boolean_t consider_inheritance, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_rangelist_remove </td>
          <td>(</td>
          <td class="paramtype">apr_array_header_t **&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const apr_array_header_t *&#160;</td>
          <td class="paramname"><em>eraser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const apr_array_header_t *&#160;</td>
          <td class="paramname"><em>whiteboard</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td>
          <td class="paramname"><em>consider_inheritance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes <em>eraser</em> (the subtrahend) from <em>whiteboard</em> (the minuend), and places the resulting difference in <em>output</em>. </p>
<p>Note: <em>eraser</em> and <em>whiteboard</em> must be sorted as said by <code><a class="el" href="svn__sorts_8h.html#a58a32c4f0a5c14672865be8768b1113a" title="Compare two svn_merge_range_t *&#39;s, returning an integer greater than, equal to, or less than 0 if the...">svn_sort_compare_ranges()</a></code>. <em>output</em> is guaranteed to be in sorted order.</p>
<p><em>consider_inheritance</em> determines how to account for the <code><a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions.">svn_merge_range_t</a></code> inheritable field when comparing <em>whiteboard's</em> and <em>*eraser's</em> rangelists for equality. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="svn__mergeinfo_8h.html#a99924a6f5f1ffa833fd3ab72e8661778" title="Calculate the delta between two mergeinfos, mergefrom and mergeto (which may be NULL), and place the result in *deleted and *added (neither output argument may be NULL).">svn_mergeinfo_diff()</a>.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="a6d5a31b9ddb2c98deca8f722042522b0"></a><!-- doxytag: member="svn_mergeinfo.h::svn_rangelist_reverse" ref="a6d5a31b9ddb2c98deca8f722042522b0" args="(apr_array_header_t *rangelist, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_rangelist_reverse </td>
          <td>(</td>
          <td class="paramtype">apr_array_header_t *&#160;</td>
          <td class="paramname"><em>rangelist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reverse <em>rangelist</em>, and the <code>start</code> and <code>end</code> fields of each range in <em>rangelist</em>, in place. </p>
<p>TODO(miapi): Is this really a valid function? Rangelists that aren't sorted, or rangelists containing reverse ranges, are generally not valid in mergeinfo code. Can we rewrite the two places where this is used?</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="a08a20e3e45b984c7a08cb95037a7d9a3"></a><!-- doxytag: member="svn_mergeinfo.h::svn_rangelist_to_string" ref="a08a20e3e45b984c7a08cb95037a7d9a3" args="(svn_string_t **output, const apr_array_header_t *rangelist, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_rangelist_to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__string__t.html">svn_string_t</a> **&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const apr_array_header_t *&#160;</td>
          <td class="paramname"><em>rangelist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Take an array of <a class="el" href="structsvn__merge__range__t.html" title="Mergeinfo representing a merge of a range of revisions.">svn_merge_range_t</a> *'s in <em>rangelist</em>, and convert it back to a text format rangelist in <em>output</em>. </p>
<p>If <em>rangelist</em> contains no elements, sets <em>output</em> to the empty string.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 23 2011 09:20:39 for Subversion by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
