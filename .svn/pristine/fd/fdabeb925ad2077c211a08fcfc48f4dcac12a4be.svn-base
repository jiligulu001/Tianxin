<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Subversion: Properties management utilities</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Subversion
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#groups">Modules</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Properties management utilities</div>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__prop__t.html">svn_prop_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A general in-memory representation of a single property.  <a href="structsvn__prop__t.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="groups"></a>
Modules</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__prop__visible__props.html">Visible properties</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Visible properties. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__prop__invisible__props.html">Invisible properties</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>WC props are props that are invisible to users: they're generated by an RA layer, and stored in secret parts of .svn/. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__props__revision__props.html">Revision properties</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>These are reserved properties attached to a "revision" object in the repository filesystem. </p>
<br/></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__props__support.html#ga17fe0cc2c221f33d00a2c917ad66bfd4">SVN_PROP_PREFIX</a>&#160;&#160;&#160;&quot;svn:&quot;</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">All Subversion property names start with this.  <a href="#ga17fe0cc2c221f33d00a2c917ad66bfd4"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structsvn__prop__t.html">svn_prop_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__props__support.html#ga24696971d508510d6481972c5787ae4d">svn_prop_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A general in-memory representation of a single property.  <a href="#ga24696971d508510d6481972c5787ae4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group__svn__props__support.html#gaa0c97177ba40e8e33fd850e602ddb1dd">svn_prop_kind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__props__support.html#ga8fc9e0c3d9592228a6201fb0427300f2">svn_prop_kind_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Subversion distinguishes among several kinds of properties, particularly on the client-side.  <a href="#ga8fc9e0c3d9592228a6201fb0427300f2"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__props__support.html#gaa0c97177ba40e8e33fd850e602ddb1dd">svn_prop_kind</a> { <br/>
&#160;&#160;<a class="el" href="group__svn__props__support.html#ggaa0c97177ba40e8e33fd850e602ddb1dda0e8d7ebcccd8f8e93d6e841fe99d1555">svn_prop_entry_kind</a>, 
<br/>
&#160;&#160;<a class="el" href="group__svn__props__support.html#ggaa0c97177ba40e8e33fd850e602ddb1ddafdb8cf1192f05d6a527af2a01162b731">svn_prop_wc_kind</a>, 
<br/>
&#160;&#160;<a class="el" href="group__svn__props__support.html#ggaa0c97177ba40e8e33fd850e602ddb1ddae9812bbe73d1c26ebd4ff4bee9a29c55">svn_prop_regular_kind</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Subversion distinguishes among several kinds of properties, particularly on the client-side.  <a href="group__svn__props__support.html#gaa0c97177ba40e8e33fd850e602ddb1dd">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__prop__t.html">svn_prop_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__props__support.html#ga5114675d164192281792515618c35b05">svn_prop_dup</a> (const <a class="el" href="structsvn__prop__t.html">svn_prop_t</a> *prop, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a duplicate of <em>prop</em>, allocated in <em>pool</em>.  <a href="#ga5114675d164192281792515618c35b05"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">apr_array_header_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__props__support.html#ga62cf1379430ffe507fbcf87e3366ec1e">svn_prop_array_dup</a> (const apr_array_header_t *array, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate an <em>array</em> of <a class="el" href="structsvn__prop__t.html" title="A general in-memory representation of a single property.">svn_prop_t</a> items using <em>pool</em>.  <a href="#ga62cf1379430ffe507fbcf87e3366ec1e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">apr_array_header_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__props__support.html#ga319fb0697c00fbf428bbf4f99f2986c7">svn_prop_hash_to_array</a> (apr_hash_t *hash, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a hash (keys <code>const char *</code> and values <code>const <a class="el" href="structsvn__string__t.html" title="A simple counted string.">svn_string_t</a></code>) of properties, returns an array of <a class="el" href="structsvn__prop__t.html" title="A general in-memory representation of a single property.">svn_prop_t</a> items using <em>pool</em>.  <a href="#ga319fb0697c00fbf428bbf4f99f2986c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">apr_hash_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__props__support.html#ga495d98afcbb44cbcbf61c7e1859dbad3">svn_prop_array_to_hash</a> (const apr_array_header_t *properties, apr_pool_t *result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an array of <a class="el" href="structsvn__prop__t.html" title="A general in-memory representation of a single property.">svn_prop_t</a> items, return a hash mapping const char * property names to const <a class="el" href="structsvn__string__t.html" title="A simple counted string.">svn_string_t</a> * values.  <a href="#ga495d98afcbb44cbcbf61c7e1859dbad3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">apr_hash_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__props__support.html#ga1c420c07245de117a278dc1b03d936b6">svn_prop_hash_dup</a> (apr_hash_t *hash, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of <em>hash</em> (keys <code>const char *</code> and values <code>const <a class="el" href="structsvn__string__t.html" title="A simple counted string.">svn_string_t</a></code>) in <em>pool</em>.  <a href="#ga1c420c07245de117a278dc1b03d936b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__props__support.html#ga4f776eecff09c1ef9872abe8bde474f7">svn_prop_get_value</a> (apr_hash_t *properties, const char *prop_name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of property <em>prop_name</em> as it is in <em>properties</em>, with values <code>const <a class="el" href="structsvn__string__t.html" title="A simple counted string.">svn_string_t</a></code>.  <a href="#ga4f776eecff09c1ef9872abe8bde474f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga19f2e2d408625f203ffc15e891d42685"></a><!-- doxytag: member="svn_props_support::svn_property_kind" ref="ga19f2e2d408625f203ffc15e891d42685" args="(int *prefix_len, const char *prop_name)" -->
<a class="el" href="group__svn__props__support.html#ga8fc9e0c3d9592228a6201fb0427300f2">svn_prop_kind_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__props__support.html#ga19f2e2d408625f203ffc15e891d42685">svn_property_kind</a> (int *prefix_len, const char *prop_name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the prop kind of a property named <em>prop_name</em>, and (if <em>prefix_len</em> is non-<code>NULL</code>) set <em>*prefix_len</em> to the length of the prefix of <em>prop_name</em> that was sufficient to distinguish its kind. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga58cc19cd57bb0447ef863a85317927ee"></a><!-- doxytag: member="svn_props_support::svn_prop_is_svn_prop" ref="ga58cc19cd57bb0447ef863a85317927ee" args="(const char *prop_name)" -->
<a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__props__support.html#ga58cc19cd57bb0447ef863a85317927ee">svn_prop_is_svn_prop</a> (const char *prop_name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>TRUE</code> iff <em>prop_name</em> represents the name of a Subversion property. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__props__support.html#ga7a794c955cff9856de467f37b8ab7652">svn_prop_has_svn_prop</a> (const apr_hash_t *props, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>TRUE</code> iff <em>props</em> has at least one property whose name represents the name of a Subversion property.  <a href="#ga7a794c955cff9856de467f37b8ab7652"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__props__support.html#gad4ae64b1be310c63ce845b20c41bdd3e">svn_prop_is_boolean</a> (const char *prop_name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>TRUE</code> iff <em>prop_name</em> is a Subversion property whose value is interpreted as a boolean.  <a href="#gad4ae64b1be310c63ce845b20c41bdd3e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__props__support.html#ga2b23f5fbe4e1736ccced93b538df782d">svn_prop_needs_translation</a> (const char *prop_name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If <em>prop_name</em> requires that its value be stored as UTF8/LF in the repository, then return <code>TRUE</code>.  <a href="#ga2b23f5fbe4e1736ccced93b538df782d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__props__support.html#gae806e7d928a297de625414f2859fb9ba">svn_categorize_props</a> (const apr_array_header_t *proplist, apr_array_header_t **entry_props, apr_array_header_t **wc_props, apr_array_header_t **regular_props, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <em>proplist</em> array of <code><a class="el" href="structsvn__prop__t.html" title="A general in-memory representation of a single property.">svn_prop_t</a></code> structures, allocate three new arrays in <em>pool</em>.  <a href="#gae806e7d928a297de625414f2859fb9ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__props__support.html#ga3f0bef17700d7f2b500272814d6fb905">svn_prop_diffs</a> (apr_array_header_t **propdiffs, apr_hash_t *target_props, apr_hash_t *source_props, apr_pool_t *pool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two property hashes (<code>const char *name</code> -&gt; <code>const <a class="el" href="structsvn__string__t.html" title="A simple counted string.">svn_string_t</a> *value</code>), deduce the differences between them (from <em>source_props</em> -&gt; <code>target_props</code>).  <a href="#ga3f0bef17700d7f2b500272814d6fb905"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__props__support.html#gaac6f7d19c68fa4865d0adea1ee741e4a">svn_prop_name_is_valid</a> (const char *prop_name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>TRUE</code> iff <em>prop_name</em> is a valid property name.  <a href="#gaac6f7d19c68fa4865d0adea1ee741e4a"></a><br/></td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga17fe0cc2c221f33d00a2c917ad66bfd4"></a><!-- doxytag: member="svn_props.h::SVN_PROP_PREFIX" ref="ga17fe0cc2c221f33d00a2c917ad66bfd4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SVN_PROP_PREFIX&#160;&#160;&#160;&quot;svn:&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>All Subversion property names start with this. </p>

<p>Definition at line <a class="el" href="svn__props_8h_source.html#l00260">260</a> of file <a class="el" href="svn__props_8h_source.html">svn_props.h</a>.</p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga8fc9e0c3d9592228a6201fb0427300f2"></a><!-- doxytag: member="svn_props.h::svn_prop_kind_t" ref="ga8fc9e0c3d9592228a6201fb0427300f2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group__svn__props__support.html#gaa0c97177ba40e8e33fd850e602ddb1dd">svn_prop_kind</a>  <a class="el" href="group__svn__props__support.html#ga8fc9e0c3d9592228a6201fb0427300f2">svn_prop_kind_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subversion distinguishes among several kinds of properties, particularly on the client-side. </p>
<p>There is no "unknown" kind; if there's nothing special about a property name, the default category is <code>svn_prop_regular_kind</code>. </p>

</div>
</div>
<a class="anchor" id="ga24696971d508510d6481972c5787ae4d"></a><!-- doxytag: member="svn_props.h::svn_prop_t" ref="ga24696971d508510d6481972c5787ae4d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structsvn__prop__t.html">svn_prop_t</a>  <a class="el" href="structsvn__prop__t.html">svn_prop_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A general in-memory representation of a single property. </p>
<p>Most of the time, property lists will be stored completely in hashes. But sometimes it's useful to have an "ordered" collection of properties, in which case we use an array of these structures.</p>
<p>Also: sometimes we want a list that represents a set of property *changes*, and in this case, an <code>apr_hash_t</code> won't work -- there's no way to represent a property deletion, because we can't store a <code>NULL</code> value in a hash. So instead, we use these structures. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="gaa0c97177ba40e8e33fd850e602ddb1dd"></a><!-- doxytag: member="svn_props.h::svn_prop_kind" ref="gaa0c97177ba40e8e33fd850e602ddb1dd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__svn__props__support.html#gaa0c97177ba40e8e33fd850e602ddb1dd">svn_prop_kind</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subversion distinguishes among several kinds of properties, particularly on the client-side. </p>
<p>There is no "unknown" kind; if there's nothing special about a property name, the default category is <code>svn_prop_regular_kind</code>. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggaa0c97177ba40e8e33fd850e602ddb1dda0e8d7ebcccd8f8e93d6e841fe99d1555"></a><!-- doxytag: member="svn_prop_entry_kind" ref="ggaa0c97177ba40e8e33fd850e602ddb1dda0e8d7ebcccd8f8e93d6e841fe99d1555" args="" -->svn_prop_entry_kind</em>&nbsp;</td><td>
<p>In .svn/entries, i.e., author, date, etc. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa0c97177ba40e8e33fd850e602ddb1ddafdb8cf1192f05d6a527af2a01162b731"></a><!-- doxytag: member="svn_prop_wc_kind" ref="ggaa0c97177ba40e8e33fd850e602ddb1ddafdb8cf1192f05d6a527af2a01162b731" args="" -->svn_prop_wc_kind</em>&nbsp;</td><td>
<p>Client-side only, stored by specific RA layer. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa0c97177ba40e8e33fd850e602ddb1ddae9812bbe73d1c26ebd4ff4bee9a29c55"></a><!-- doxytag: member="svn_prop_regular_kind" ref="ggaa0c97177ba40e8e33fd850e602ddb1ddae9812bbe73d1c26ebd4ff4bee9a29c55" args="" -->svn_prop_regular_kind</em>&nbsp;</td><td>
<p>Seen if user does "svn proplist"; note that this includes some "svn:" props and all user props, i.e. </p>
<p>ones stored in the repository fs. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="svn__props_8h_source.html#l00139">139</a> of file <a class="el" href="svn__props_8h_source.html">svn_props.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gae806e7d928a297de625414f2859fb9ba"></a><!-- doxytag: member="svn_props.h::svn_categorize_props" ref="gae806e7d928a297de625414f2859fb9ba" args="(const apr_array_header_t *proplist, apr_array_header_t **entry_props, apr_array_header_t **wc_props, apr_array_header_t **regular_props, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_categorize_props </td>
          <td>(</td>
          <td class="paramtype">const apr_array_header_t *&#160;</td>
          <td class="paramname"><em>proplist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_array_header_t **&#160;</td>
          <td class="paramname"><em>entry_props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_array_header_t **&#160;</td>
          <td class="paramname"><em>wc_props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_array_header_t **&#160;</td>
          <td class="paramname"><em>regular_props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a <em>proplist</em> array of <code><a class="el" href="structsvn__prop__t.html" title="A general in-memory representation of a single property.">svn_prop_t</a></code> structures, allocate three new arrays in <em>pool</em>. </p>
<p>Categorize each property and then create new <code><a class="el" href="structsvn__prop__t.html" title="A general in-memory representation of a single property.">svn_prop_t</a></code> structures in the proper lists. Each new <code><a class="el" href="structsvn__prop__t.html" title="A general in-memory representation of a single property.">svn_prop_t</a></code> structure's fields will point to the same data within <em>proplist's</em> structures.</p>
<p>Callers may pass NULL for each of the property lists in which they are uninterested. If no props exist in a certain category, and the property list argument for that category is non-NULL, then that array will come back with <code>-&gt;nelts == 0</code>. </p>

</div>
</div>
<a class="anchor" id="ga62cf1379430ffe507fbcf87e3366ec1e"></a><!-- doxytag: member="svn_props.h::svn_prop_array_dup" ref="ga62cf1379430ffe507fbcf87e3366ec1e" args="(const apr_array_header_t *array, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_array_header_t* svn_prop_array_dup </td>
          <td>(</td>
          <td class="paramtype">const apr_array_header_t *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Duplicate an <em>array</em> of <a class="el" href="structsvn__prop__t.html" title="A general in-memory representation of a single property.">svn_prop_t</a> items using <em>pool</em>. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.3. </dd></dl>

</div>
</div>
<a class="anchor" id="ga495d98afcbb44cbcbf61c7e1859dbad3"></a><!-- doxytag: member="svn_props.h::svn_prop_array_to_hash" ref="ga495d98afcbb44cbcbf61c7e1859dbad3" args="(const apr_array_header_t *properties, apr_pool_t *result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_hash_t* svn_prop_array_to_hash </td>
          <td>(</td>
          <td class="paramtype">const apr_array_header_t *&#160;</td>
          <td class="paramname"><em>properties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given an array of <a class="el" href="structsvn__prop__t.html" title="A general in-memory representation of a single property.">svn_prop_t</a> items, return a hash mapping const char * property names to const <a class="el" href="structsvn__string__t.html" title="A simple counted string.">svn_string_t</a> * values. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The behaviour on <a class="el" href="structsvn__prop__t.html" title="A general in-memory representation of a single property.">svn_prop_t</a> objects with a <code>NULL</code> <code><a class="el" href="structsvn__prop__t.html#a3d36920ed6e21ada9c74a1829c4fb068" title="Property value.">svn_prop_t.value</a></code> member is undefined.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3f0bef17700d7f2b500272814d6fb905"></a><!-- doxytag: member="svn_props.h::svn_prop_diffs" ref="ga3f0bef17700d7f2b500272814d6fb905" args="(apr_array_header_t **propdiffs, apr_hash_t *target_props, apr_hash_t *source_props, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_prop_diffs </td>
          <td>(</td>
          <td class="paramtype">apr_array_header_t **&#160;</td>
          <td class="paramname"><em>propdiffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_hash_t *&#160;</td>
          <td class="paramname"><em>target_props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_hash_t *&#160;</td>
          <td class="paramname"><em>source_props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given two property hashes (<code>const char *name</code> -&gt; <code>const <a class="el" href="structsvn__string__t.html" title="A simple counted string.">svn_string_t</a> *value</code>), deduce the differences between them (from <em>source_props</em> -&gt; <code>target_props</code>). </p>
<p>Set <em>propdiffs</em> to a new array of <code><a class="el" href="structsvn__prop__t.html" title="A general in-memory representation of a single property.">svn_prop_t</a></code> structures, with one entry for each property that differs, including properties that exist in <em>source_props</em> or <em>target_props</em> but not both. The <code>value</code> field of each entry is that property's value from <em>target_props</em> or NULL if that property only exists in <em>source_props</em>.</p>
<p>Allocate the array from <em>pool</em>. Allocate the contents of the array from <em>pool</em> or by reference to the storage of the input hashes or both.</p>
<p>For note, here's a quick little table describing the logic of this routine:</p>
<div class="fragment"><pre class="fragment">
   source_props    target_props      event
   ------------    ------------      -----
   value = foo     value = NULL      Deletion occurred.
   value = foo     value = bar       Set occurred (modification)
   value = NULL    value = baz       Set occurred (creation) </pre></div> 
</div>
</div>
<a class="anchor" id="ga5114675d164192281792515618c35b05"></a><!-- doxytag: member="svn_props.h::svn_prop_dup" ref="ga5114675d164192281792515618c35b05" args="(const svn_prop_t *prop, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__prop__t.html">svn_prop_t</a>* svn_prop_dup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsvn__prop__t.html">svn_prop_t</a> *&#160;</td>
          <td class="paramname"><em>prop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a duplicate of <em>prop</em>, allocated in <em>pool</em>. </p>
<p>No part of the new structure will be shared with <em>prop</em>.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.3. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4f776eecff09c1ef9872abe8bde474f7"></a><!-- doxytag: member="svn_props.h::svn_prop_get_value" ref="ga4f776eecff09c1ef9872abe8bde474f7" args="(apr_hash_t *properties, const char *prop_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* svn_prop_get_value </td>
          <td>(</td>
          <td class="paramtype">apr_hash_t *&#160;</td>
          <td class="paramname"><em>properties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prop_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the value of property <em>prop_name</em> as it is in <em>properties</em>, with values <code>const <a class="el" href="structsvn__string__t.html" title="A simple counted string.">svn_string_t</a></code>. </p>
<p>If <em>prop_name</em> is not in <em>properties</em> or <em>properties</em> is NULL, return NULL.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.7. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7a794c955cff9856de467f37b8ab7652"></a><!-- doxytag: member="svn_props.h::svn_prop_has_svn_prop" ref="ga7a794c955cff9856de467f37b8ab7652" args="(const apr_hash_t *props, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> svn_prop_has_svn_prop </td>
          <td>(</td>
          <td class="paramtype">const apr_hash_t *&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return <code>TRUE</code> iff <em>props</em> has at least one property whose name represents the name of a Subversion property. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1c420c07245de117a278dc1b03d936b6"></a><!-- doxytag: member="svn_props.h::svn_prop_hash_dup" ref="ga1c420c07245de117a278dc1b03d936b6" args="(apr_hash_t *hash, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_hash_t* svn_prop_hash_dup </td>
          <td>(</td>
          <td class="paramtype">apr_hash_t *&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a deep copy of <em>hash</em> (keys <code>const char *</code> and values <code>const <a class="el" href="structsvn__string__t.html" title="A simple counted string.">svn_string_t</a></code>) in <em>pool</em>. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a class="anchor" id="ga319fb0697c00fbf428bbf4f99f2986c7"></a><!-- doxytag: member="svn_props.h::svn_prop_hash_to_array" ref="ga319fb0697c00fbf428bbf4f99f2986c7" args="(apr_hash_t *hash, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_array_header_t* svn_prop_hash_to_array </td>
          <td>(</td>
          <td class="paramtype">apr_hash_t *&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a hash (keys <code>const char *</code> and values <code>const <a class="el" href="structsvn__string__t.html" title="A simple counted string.">svn_string_t</a></code>) of properties, returns an array of <a class="el" href="structsvn__prop__t.html" title="A general in-memory representation of a single property.">svn_prop_t</a> items using <em>pool</em>. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="gad4ae64b1be310c63ce845b20c41bdd3e"></a><!-- doxytag: member="svn_props.h::svn_prop_is_boolean" ref="gad4ae64b1be310c63ce845b20c41bdd3e" args="(const char *prop_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> svn_prop_is_boolean </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prop_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return <code>TRUE</code> iff <em>prop_name</em> is a Subversion property whose value is interpreted as a boolean. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.5 </dd></dl>

</div>
</div>
<a class="anchor" id="gaac6f7d19c68fa4865d0adea1ee741e4a"></a><!-- doxytag: member="svn_props.h::svn_prop_name_is_valid" ref="gaac6f7d19c68fa4865d0adea1ee741e4a" args="(const char *prop_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> svn_prop_name_is_valid </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prop_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return <code>TRUE</code> iff <em>prop_name</em> is a valid property name. </p>
<p>For now, "valid" means the ASCII subset of an XML "Name". XML "Name" is defined at <a href="http://www.w3.org/TR/REC-xml#sec-common-syn">http://www.w3.org/TR/REC-xml#sec-common-syn</a></p>
<dl class="since"><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2b23f5fbe4e1736ccced93b538df782d"></a><!-- doxytag: member="svn_props.h::svn_prop_needs_translation" ref="ga2b23f5fbe4e1736ccced93b538df782d" args="(const char *prop_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#a22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> svn_prop_needs_translation </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prop_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If <em>prop_name</em> requires that its value be stored as UTF8/LF in the repository, then return <code>TRUE</code>. </p>
<p>Else return <code>FALSE</code>. This is for users of libsvn_client or libsvn_fs, since it their responsibility to do this translation in both directions. (See <a class="el" href="svn__subst_8h.html#a626c5dcfbbf5057ebc0e384187f6d330" title="Similar to svn_subst_translate_string2(), except that the information about whether re-encoding or li...">svn_subst_translate_string()</a>/svn_subst_detranslate_string() for help with this task.) </p>

</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 23 2011 09:20:41 for Subversion by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
